   1               		.file	"draw.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	clip_hline:
  12               	.LFB15:
  13               		.file 1 "draw.c"
   1:draw.c        **** /* -*- c++ -*- ***************************************************************
   2:draw.c        ****  *
   3:draw.c        ****  *  System      : Serial GLCD
   4:draw.c        ****  *  Module      : Draw functions
   5:draw.c        ****  *  Object Name : $RCSfile: draw.c,v $
   6:draw.c        ****  *  Revision    : $Revision: 1.24 $
   7:draw.c        ****  *  Date        : $Date: 2015/05/31 21:05:23 $
   8:draw.c        ****  *  Author      : $Author: jon $
   9:draw.c        ****  *  Created By  : Jon Green
  10:draw.c        ****  *  Created     : Sun Apr 5 08:43:33 2015 Last Modified : <150531.2205>
  11:draw.c        ****  *
  12:draw.c        ****  *  Description : The main program for driving the serial 160x128 screen
  13:draw.c        ****  *
  14:draw.c        ****  *  Notes       : Derrived from the 128x64 code by Jennifer Holt and adapted
  15:draw.c        ****  *                for the 160x128 screen.
  16:draw.c        ****  *
  17:draw.c        ****  *  History     :
  18:draw.c        ****  *
  19:draw.c        ****  *****************************************************************************
  20:draw.c        ****  *
  21:draw.c        ****  *  Copyright (c) 2010 Jennifer Holt
  22:draw.c        ****  *  Copyright (c) 2015 Jon Green
  23:draw.c        ****  *
  24:draw.c        ****  *  Permission is hereby granted, free of charge, to any person obtaining a
  25:draw.c        ****  *  copy of this software and associated documentation files (the "Software"),
  26:draw.c        ****  *  to deal in the Software without restriction, including without limitation
  27:draw.c        ****  *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  28:draw.c        ****  *  and/or sell copies of the Software, and to permit persons to whom the
  29:draw.c        ****  *  Software is furnished to do so, subject to the following conditions:
  30:draw.c        ****  *
  31:draw.c        ****  *  The above copyright notice and this permission notice shall be included in
  32:draw.c        ****  *  all copies or substantial portions of the Software.
  33:draw.c        ****  *
  34:draw.c        ****  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  35:draw.c        ****  *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  36:draw.c        ****  *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  37:draw.c        ****  *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  38:draw.c        ****  *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  39:draw.c        ****  *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  40:draw.c        ****  *  DEALINGS IN THE SOFTWARE.
  41:draw.c        ****  *
  42:draw.c        ****  ****************************************************************************/
  43:draw.c        **** 
  44:draw.c        **** #include <stdlib.h>
  45:draw.c        **** #include <string.h>
  46:draw.c        **** #include <avr/pgmspace.h>
  47:draw.c        **** 
  48:draw.c        **** #include "glcd.h"
  49:draw.c        **** 
  50:draw.c        **** // Buffer used for bitblt and other draw operations.
  51:draw.c        **** uint8_t draw_buffer [SCREEN_MAX_WIDTH];
  52:draw.c        **** 
  53:draw.c        **** // Buffer used for line blitting; this is 8 pairs of coordinates.
  54:draw.c        **** uint8_t line_buffer [LINE_BUFFER_MAX];
  55:draw.c        **** 
  56:draw.c        **** // The current draw mode.
  57:draw.c        **** uint8_t drawing_mode;
  58:draw.c        **** 
  59:draw.c        **** /////////////////////////////////////////////////////////////////////////////
  60:draw.c        **** /// Change the current drawing mode.
  61:draw.c        **** ///
  62:draw.c        **** /// @param [in] mode The new drawing mode.
  63:draw.c        **** ///
  64:draw.c        **** void
  65:draw.c        **** draw_mode (uint8_t mode)
  66:draw.c        **** {
  67:draw.c        ****     drawing_mode = mode;
  68:draw.c        **** }
  69:draw.c        **** 
  70:draw.c        **** /////////////////////////////////////////////////////////////////////////////
  71:draw.c        **** /// line performs a Bresenhams line draw. This uses the buffer storage
  72:draw.c        **** /// so cannot be used with any operation that uses the buffer.
  73:draw.c        **** ///
  74:draw.c        **** /// The function caches a block in the buffer to allow multiple joined
  75:draw.c        **** /// line draws to be perfomed in succession. This allows the line drawing
  76:draw.c        **** /// to be used with XOR type functions.
  77:draw.c        **** ///
  78:draw.c        **** /// @param [in] x0 is the first x-coordinate to start drawing.
  79:draw.c        **** /// @param [in] y0 is the first y-coordinate to start drawing.
  80:draw.c        **** /// @param [in] x1 is the second x-coordinate to start drawing.
  81:draw.c        **** /// @param [in] y1 is the second y-coordinate to start drawing.
  82:draw.c        **** /// @param [in] s_r A bit mask of the drawer.
  83:draw.c        **** ///                 0x01 draws or 0x00 erases a line
  84:draw.c        **** ///                 0x40 Do not flush the data on completion.
  85:draw.c        **** ///                 0x80 when bit is set then the last pixel is not
  86:draw.c        **** ///                      drawn. used for polygons.
  87:draw.c        **** ///
  88:draw.c        **** void
  89:draw.c        **** draw_line (uint8_t x, uint8_t y, uint8_t x1, uint8_t y1, uint8_t s_r)
  90:draw.c        **** {
  91:draw.c        ****     // Working variables.
  92:draw.c        ****     int16_t deltax;                     // Difference in x;
  93:draw.c        ****     int16_t deltay;                     // Difference in y;
  94:draw.c        ****     int8_t xinc;                        // X-coordinate increment.
  95:draw.c        ****     int8_t yinc;                        // X-coordinate increment.
  96:draw.c        ****     uint8_t ps_r;
  97:draw.c        **** 
  98:draw.c        ****     ps_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & MODE_MODIFIER);
  99:draw.c        **** 
 100:draw.c        ****     // Sort out tge x values.
 101:draw.c        ****     if (x1 >= x)                        // The x-values are increasing
 102:draw.c        ****     {
 103:draw.c        ****         xinc = 1;
 104:draw.c        ****         deltax = x1 - x;                // The difference between the x's
 105:draw.c        ****     }
 106:draw.c        ****     else                                // The x-values are decreasing
 107:draw.c        ****     {
 108:draw.c        ****         xinc = -1;
 109:draw.c        ****         deltax = x - x1;
 110:draw.c        ****     }
 111:draw.c        **** 
 112:draw.c        ****     // Sort out the y value
 113:draw.c        ****     if (y1 >= y)                       // The y-values are increasing
 114:draw.c        ****     {
 115:draw.c        ****         yinc = 1;
 116:draw.c        ****         deltay = y1 - y;
 117:draw.c        ****     }
 118:draw.c        ****     else                                // The y-values are decreasing
 119:draw.c        ****     {
 120:draw.c        ****         yinc = -1;
 121:draw.c        ****         deltay = y - y1;
 122:draw.c        ****     }
 123:draw.c        **** 
 124:draw.c        ****     // There is at least one x-value for every y-value. Handle the incrementing
 125:draw.c        ****     // and decremening separately.
 126:draw.c        ****     if (deltax >= deltay)
 127:draw.c        ****     {
 128:draw.c        ****         int16_t denominator;             // Denominator
 129:draw.c        ****         int16_t numerator;               // Numerator
 130:draw.c        ****         int16_t numadd;                  // Numerator to add.
 131:draw.c        ****         int16_t numpixels;               // Number of pixels to write.
 132:draw.c        ****         uint8_t xstart;                 // The x start position
 133:draw.c        ****         uint8_t written;                // Written the line
 134:draw.c        **** 
 135:draw.c        ****         // Calculate the Bresenham parameters
 136:draw.c        ****         denominator = deltax;           // The denominator
 137:draw.c        ****         numerator = deltax / 2;         // The numerator
 138:draw.c        ****         numadd = deltay;                // Increment of the numerator
 139:draw.c        ****         numpixels = deltax;             // There are more x-values than y-values
 140:draw.c        **** 
 141:draw.c        ****         // If we are skipping the last pixel the decrement the write length.
 142:draw.c        ****         if ((s_r & MODE_LINE_SKIP_LAST) == 0)
 143:draw.c        ****             numpixels++;
 144:draw.c        **** 
 145:draw.c        ****         xstart = x;
 146:draw.c        ****         written = numpixels - 1;
 147:draw.c        **** 
 148:draw.c        ****         // Write all of the pixels
 149:draw.c        ****         while (--numpixels >= 0)
 150:draw.c        ****         {
 151:draw.c        ****             numerator += numadd;        // Increase the numerator by the top of the fraction
 152:draw.c        ****             if (numerator >= denominator) // Check if numerator >= denominator
 153:draw.c        ****             {
 154:draw.c        ****                 numerator -= denominator; // Calculate the new numerator value
 155:draw.c        ****                 draw_hline (xstart, y, x, ps_r);
 156:draw.c        **** 
 157:draw.c        ****                 y += yinc;              // Change the y as appropriate
 158:draw.c        ****                 x += xinc;              // Increment x as required.
 159:draw.c        **** 
 160:draw.c        ****                 xstart = x;             // New start position
 161:draw.c        ****                 written = numpixels;    // Save the write position
 162:draw.c        ****             }
 163:draw.c        ****             else
 164:draw.c        ****                 x += xinc;
 165:draw.c        ****         }
 166:draw.c        **** 
 167:draw.c        ****         // Make sure that any line fragment has been flushed.
 168:draw.c        ****         if (written != 0)
 169:draw.c        ****             draw_hline (xstart, y, x - xinc, ps_r);
 170:draw.c        **** 
 171:draw.c        ****     }
 172:draw.c        ****     // There is at least one y-value for every x-value
 173:draw.c        ****     else
 174:draw.c        ****     {
 175:draw.c        ****         int16_t denominator;             // Denominator
 176:draw.c        ****         int16_t numerator;               // Numerator
 177:draw.c        ****         int16_t numadd;                  // Numerator to add.
 178:draw.c        ****         int16_t numpixels;              // Number of pixels to write.
 179:draw.c        ****         uint8_t ystart;                 // The y start position
 180:draw.c        ****         uint8_t written;                // Written the line
 181:draw.c        **** 
 182:draw.c        ****         // Calculate the Bresenham parameters
 183:draw.c        ****         denominator = deltay;
 184:draw.c        ****         numerator = deltay / 2;
 185:draw.c        ****         numadd = deltax;
 186:draw.c        ****         numpixels = deltay;             // There are more y-values than x-values
 187:draw.c        **** 
 188:draw.c        ****         // If we are skipping the last pixel the decrement the write length.
 189:draw.c        ****         if ((s_r & MODE_LINE_SKIP_LAST) == 0)
 190:draw.c        ****             numpixels++;
 191:draw.c        **** 
 192:draw.c        ****         ystart = y;
 193:draw.c        ****         written = numpixels - 1;
 194:draw.c        **** 
 195:draw.c        ****         // Write all of the pixels
 196:draw.c        ****         while (--numpixels >= 0)
 197:draw.c        ****         {
 198:draw.c        ****             // Increase the numerator by the top of the fraction
 199:draw.c        ****             numerator += numadd;
 200:draw.c        ****             if (numerator >= denominator) // Check if numerator >= denominator
 201:draw.c        ****             {
 202:draw.c        ****                 numerator -= denominator; // Calculate the new numerator value
 203:draw.c        ****                 draw_vline (x, ystart, y, ps_r);
 204:draw.c        **** 
 205:draw.c        ****                 x += xinc;              // Change the x as appropriate
 206:draw.c        ****                 y += yinc;
 207:draw.c        **** 
 208:draw.c        ****                 ystart = y;             // New start position
 209:draw.c        ****                 written = numpixels;    // Save the write position
 210:draw.c        ****             }
 211:draw.c        ****             // Increment y.
 212:draw.c        ****             else
 213:draw.c        ****                 y += yinc;
 214:draw.c        ****         }
 215:draw.c        **** 
 216:draw.c        ****         // Ensure that all pixels are written
 217:draw.c        ****         if (written != 0)
 218:draw.c        ****             draw_vline (x, ystart, y - yinc, ps_r);
 219:draw.c        ****     }
 220:draw.c        **** }
 221:draw.c        **** 
 222:draw.c        **** //////////////////////////////////////////////////////////////////////////////
 223:draw.c        **** /// Draw multiple connected lines
 224:draw.c        **** ///
 225:draw.c        **** /// @param [in] mode The drawing mode.
 226:draw.c        **** /// @param [in] data The list of x,y coordinates. The last y coordinate is
 227:draw.c        **** ///                  marked with the top bit set to 0x80.
 228:draw.c        **** void
 229:draw.c        **** draw_lines (uint8_t s_r, uint8_t x, uint8_t y, uint8_t *data)
 230:draw.c        **** {
 231:draw.c        ****     // Cache line and do not draw endpoint
 232:draw.c        ****     s_r |= MODE_LINE_SKIP_LAST;
 233:draw.c        **** 
 234:draw.c        ****     // Iterate over the rest of the coordinate until we have finished.
 235:draw.c        ****     do
 236:draw.c        ****     {
 237:draw.c        ****         uint8_t x1, y1;
 238:draw.c        **** 
 239:draw.c        ****         if (data != NULL)
 240:draw.c        ****         {
 241:draw.c        ****             x1 = *data++;
 242:draw.c        ****             y1 = *data++;
 243:draw.c        ****         }
 244:draw.c        ****         else
 245:draw.c        ****         {
 246:draw.c        ****             x1 = serial_getc (); // Save x
 247:draw.c        ****             y1 = serial_getc (); // Save y
 248:draw.c        ****         }
 249:draw.c        **** 
 250:draw.c        ****         if ((y1 & 0x80) != 0)
 251:draw.c        ****         {
 252:draw.c        ****             y1 &= ~0x80;
 253:draw.c        ****             // Draw last point and flush cache.
 254:draw.c        ****             s_r &= ~MODE_LINE_SKIP_LAST;
 255:draw.c        ****         }
 256:draw.c        **** 
 257:draw.c        ****         // Do the best form of line draw that we can
 258:draw.c        ****         draw_line (x, y, x1, y1, s_r);
 259:draw.c        ****         x = x1;
 260:draw.c        ****         y = y1;
 261:draw.c        ****     }
 262:draw.c        ****     while ((s_r & MODE_LINE_SKIP_LAST) != 0);
 263:draw.c        **** }
 264:draw.c        **** 
 265:draw.c        **** //////////////////////////////////////////////////////////////////////////////
 266:draw.c        **** /// Draw a pixel. Confirm that the pixel is within bounds and then draw it.
 267:draw.c        **** ///
 268:draw.c        **** /// @param [in] x The x-coordinate
 269:draw.c        **** /// @param [in] y The y-coordinate
 270:draw.c        **** /// @param [in] s_r The drawing mode.
 271:draw.c        **** void
 272:draw.c        **** draw_pixel (uint8_t x, uint8_t y, uint8_t s_r)
 273:draw.c        **** {
 274:draw.c        ****     if (x_valid(x) && y_valid(y))
 275:draw.c        ****     {
 276:draw.c        ****         // Compute the current mode based on the reverse preference.
 277:draw.c        ****         s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~MODE_NORMAL_MASK);
 278:draw.c        ****         lcd_set_pixel (x, y, s_r);
 279:draw.c        ****     }
 280:draw.c        **** }
 281:draw.c        **** 
 282:draw.c        **** static void
 283:draw.c        **** clip_hline (int x0, int y0, int x1, uint8_t s_r)
 284:draw.c        **** {
  14               		.loc 1 284 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 285:draw.c        ****     // Make sure y is on screen
 286:draw.c        ****     if (y_valid (y0))
  21               		.loc 1 286 0
  22 0000 E091 0000 		lds r30,y_dim
  23 0004 F0E0      		ldi r31,0
  24 0006 F195      		neg r31
  25 0008 E195      		neg r30
  26 000a F109      		sbc r31,__zero_reg__
  27 000c E623      		and r30,r22
  28 000e F723      		and r31,r23
  29 0010 EF2B      		or r30,r31
  30 0012 01F4      		brne .L1
  31               	.LVL1:
  32               	.LBB10:
  33               	.LBB11:
 287:draw.c        ****     {
 288:draw.c        ****         // Swap the word if in the incorrect order.
 289:draw.c        ****         if (x0 > x1)
  34               		.loc 1 289 0
  35 0014 4817      		cp r20,r24
  36 0016 5907      		cpc r21,r25
  37 0018 04F4      		brge .L3
  38 001a E82F      		mov r30,r24
  39 001c 392F      		mov r19,r25
  40 001e CA01      		movw r24,r20
  41               	.LVL2:
  42 0020 4E2F      		mov r20,r30
  43               	.LVL3:
  44 0022 532F      		mov r21,r19
  45               	.LVL4:
  46               	.L3:
 290:draw.c        ****         {
 291:draw.c        ****             int temp;
 292:draw.c        **** 
 293:draw.c        ****             temp = x0;
 294:draw.c        ****             x0 = x1;
 295:draw.c        ****             x1 = temp;
 296:draw.c        ****         }
 297:draw.c        **** 
 298:draw.c        ****         // Ensure end point is on screen
 299:draw.c        ****         if (x1 >= 0)
  47               		.loc 1 299 0
  48 0024 57FD      		sbrc r21,7
  49 0026 00C0      		rjmp .L1
 300:draw.c        ****         {
 301:draw.c        ****             // Ensure start point is on screen */
 302:draw.c        ****             if (x0 < x_dim)
  50               		.loc 1 302 0
  51 0028 E091 0000 		lds r30,x_dim
  52 002c F0E0      		ldi r31,0
  53 002e 8E17      		cp r24,r30
  54 0030 9F07      		cpc r25,r31
  55 0032 04F4      		brge .L1
 303:draw.c        ****             {
 304:draw.c        ****                 // Ensure endpoint is not off screen
 305:draw.c        ****                 if (x1 >= x_dim)
  56               		.loc 1 305 0
  57 0034 4E17      		cp r20,r30
  58 0036 5F07      		cpc r21,r31
  59 0038 04F0      		brlt .L4
 306:draw.c        ****                     x1 = x_dim - 1;     // Clip end point to screen.
  60               		.loc 1 306 0
  61 003a AF01      		movw r20,r30
  62               	.LVL5:
  63 003c 4150      		subi r20,1
  64 003e 5109      		sbc r21,__zero_reg__
  65               	.L4:
  66               	.LVL6:
  67               	.LBB12:
 307:draw.c        ****                 if (x0 < 0)
 308:draw.c        ****                     x0 = 0;             // Clip start point to screen.
 309:draw.c        ****                 draw_hline (x0, y0, x1, s_r);
  68               		.loc 1 309 0
  69 0040 E091 0000 		lds r30,functabP
  70 0044 F091 0000 		lds r31,functabP+1
  71               	.LVL7:
  72               	/* #APP */
  73               	 ;  309 "draw.c" 1
  74 0048 A591      		lpm r26, Z+
  75 004a B491      		lpm r27, Z
  76               		
  77               	 ;  0 "" 2
  78               	.LVL8:
  79               	/* #NOAPP */
  80 004c 97FF      		sbrs r25,7
  81 004e 00C0      		rjmp .L5
  82 0050 80E0      		ldi r24,0
  83 0052 90E0      		ldi r25,0
  84               	.LVL9:
  85               	.L5:
  86               	.LBE12:
  87 0054 FD01      		movw r30,r26
  88 0056 0994      		ijmp
  89               	.LVL10:
  90               	.L1:
  91 0058 0895      		ret
  92               	.LBE11:
  93               	.LBE10:
  94               		.cfi_endproc
  95               	.LFE15:
  98               	clip_vline:
  99               	.LFB16:
 310:draw.c        ****             }
 311:draw.c        ****         }
 312:draw.c        ****     }
 313:draw.c        **** }
 314:draw.c        **** 
 315:draw.c        **** static void
 316:draw.c        **** clip_vline (int x0, int y0, int y1, uint8_t s_r)
 317:draw.c        **** {
 100               		.loc 1 317 0
 101               		.cfi_startproc
 102               	.LVL11:
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
 318:draw.c        ****     // Make sure y is on screen
 319:draw.c        ****     if (x_valid (x0))
 107               		.loc 1 319 0
 108 005a 97FD      		sbrc r25,7
 109 005c 00C0      		rjmp .L8
 110               		.loc 1 319 0 is_stmt 0 discriminator 1
 111 005e E091 0000 		lds r30,x_dim
 112 0062 F0E0      		ldi r31,0
 113 0064 8E17      		cp r24,r30
 114 0066 9F07      		cpc r25,r31
 115 0068 04F4      		brge .L8
 116               	.LVL12:
 117               	.LBB17:
 118               	.LBB18:
 320:draw.c        ****     {
 321:draw.c        ****         // Swap the word if in the incorrect order.
 322:draw.c        ****         if (y0 > y1)
 119               		.loc 1 322 0 is_stmt 1
 120 006a 4617      		cp r20,r22
 121 006c 5707      		cpc r21,r23
 122 006e 04F4      		brge .L10
 123 0070 E62F      		mov r30,r22
 124 0072 372F      		mov r19,r23
 125 0074 BA01      		movw r22,r20
 126               	.LVL13:
 127 0076 4E2F      		mov r20,r30
 128               	.LVL14:
 129 0078 532F      		mov r21,r19
 130               	.LVL15:
 131               	.L10:
 323:draw.c        ****         {
 324:draw.c        ****             int temp;
 325:draw.c        **** 
 326:draw.c        ****             temp = y0;
 327:draw.c        ****             y0 = y1;
 328:draw.c        ****             y1 = temp;
 329:draw.c        ****         }
 330:draw.c        **** 
 331:draw.c        ****         // Ensure end point is on screen
 332:draw.c        ****         if (y1 >= 0)
 132               		.loc 1 332 0
 133 007a 57FD      		sbrc r21,7
 134 007c 00C0      		rjmp .L8
 333:draw.c        ****         {
 334:draw.c        ****             // Ensure start point is on screen */
 335:draw.c        ****             if (y0 < y_dim)
 135               		.loc 1 335 0
 136 007e E091 0000 		lds r30,y_dim
 137 0082 F0E0      		ldi r31,0
 138 0084 6E17      		cp r22,r30
 139 0086 7F07      		cpc r23,r31
 140 0088 04F4      		brge .L8
 336:draw.c        ****             {
 337:draw.c        ****                 // Ensure endpoint is not off screen
 338:draw.c        ****                 if (y1 >= y_dim)
 141               		.loc 1 338 0
 142 008a 4E17      		cp r20,r30
 143 008c 5F07      		cpc r21,r31
 144 008e 04F0      		brlt .L11
 339:draw.c        ****                     y1 = y_dim - 1;     // Clip end point to screen.
 145               		.loc 1 339 0
 146 0090 AF01      		movw r20,r30
 147               	.LVL16:
 148 0092 4150      		subi r20,1
 149 0094 5109      		sbc r21,__zero_reg__
 150               	.L11:
 151               	.LVL17:
 152               	.LBB19:
 340:draw.c        ****                 if (y0 < 0)
 341:draw.c        ****                     y0 = 0;             // Clip start point to screen.
 342:draw.c        ****                 draw_vline (x0, y0, y1, s_r);
 153               		.loc 1 342 0
 154 0096 E091 0000 		lds r30,functabP
 155 009a F091 0000 		lds r31,functabP+1
 156 009e 3C96      		adiw r30,12
 157               	.LVL18:
 158               	/* #APP */
 159               	 ;  342 "draw.c" 1
 160 00a0 A591      		lpm r26, Z+
 161 00a2 B491      		lpm r27, Z
 162               		
 163               	 ;  0 "" 2
 164               	.LVL19:
 165               	/* #NOAPP */
 166 00a4 77FF      		sbrs r23,7
 167 00a6 00C0      		rjmp .L12
 168 00a8 60E0      		ldi r22,0
 169 00aa 70E0      		ldi r23,0
 170               	.LVL20:
 171               	.L12:
 172               	.LBE19:
 173 00ac FD01      		movw r30,r26
 174 00ae 0994      		ijmp
 175               	.LVL21:
 176               	.L8:
 177 00b0 0895      		ret
 178               	.LBE18:
 179               	.LBE17:
 180               		.cfi_endproc
 181               	.LFE16:
 184               	_draw_circle:
 185               	.LFB17:
 343:draw.c        ****             }
 344:draw.c        ****         }
 345:draw.c        ****     }
 346:draw.c        **** }
 347:draw.c        **** 
 348:draw.c        **** // Draws (s_r = 1) or erases (s_r = 0) a filled circle at x, y with radius r,
 349:draw.c        **** // using midpoint circle algorithm. For efficiency in drawing then the
 350:draw.c        **** // algorith draws staight line vertical and horizontal segments which degrade
 351:draw.c        **** // to a single pixel in the worst case.
 352:draw.c        **** //
 353:draw.c        **** // Noted that the Sparkfun circle algorithm is a little easier however the
 354:draw.c        **** // circle quality is dubious at a small radius so we keep the existing one
 355:draw.c        **** // used by Jennifer Holt.
 356:draw.c        **** static void
 357:draw.c        **** _draw_circle (uint8_t xin, uint8_t yin, uint8_t xgap, uint8_t ygap, uint8_t rin, uint8_t s_r)
 358:draw.c        **** {
 186               		.loc 1 358 0
 187               		.cfi_startproc
 188               	.LVL22:
 189 00b2 2F92      		push r2
 190               	.LCFI0:
 191               		.cfi_def_cfa_offset 3
 192               		.cfi_offset 2, -2
 193 00b4 3F92      		push r3
 194               	.LCFI1:
 195               		.cfi_def_cfa_offset 4
 196               		.cfi_offset 3, -3
 197 00b6 4F92      		push r4
 198               	.LCFI2:
 199               		.cfi_def_cfa_offset 5
 200               		.cfi_offset 4, -4
 201 00b8 5F92      		push r5
 202               	.LCFI3:
 203               		.cfi_def_cfa_offset 6
 204               		.cfi_offset 5, -5
 205 00ba 6F92      		push r6
 206               	.LCFI4:
 207               		.cfi_def_cfa_offset 7
 208               		.cfi_offset 6, -6
 209 00bc 7F92      		push r7
 210               	.LCFI5:
 211               		.cfi_def_cfa_offset 8
 212               		.cfi_offset 7, -7
 213 00be 8F92      		push r8
 214               	.LCFI6:
 215               		.cfi_def_cfa_offset 9
 216               		.cfi_offset 8, -8
 217 00c0 9F92      		push r9
 218               	.LCFI7:
 219               		.cfi_def_cfa_offset 10
 220               		.cfi_offset 9, -9
 221 00c2 AF92      		push r10
 222               	.LCFI8:
 223               		.cfi_def_cfa_offset 11
 224               		.cfi_offset 10, -10
 225 00c4 BF92      		push r11
 226               	.LCFI9:
 227               		.cfi_def_cfa_offset 12
 228               		.cfi_offset 11, -11
 229 00c6 CF92      		push r12
 230               	.LCFI10:
 231               		.cfi_def_cfa_offset 13
 232               		.cfi_offset 12, -12
 233 00c8 DF92      		push r13
 234               	.LCFI11:
 235               		.cfi_def_cfa_offset 14
 236               		.cfi_offset 13, -13
 237 00ca EF92      		push r14
 238               	.LCFI12:
 239               		.cfi_def_cfa_offset 15
 240               		.cfi_offset 14, -14
 241 00cc FF92      		push r15
 242               	.LCFI13:
 243               		.cfi_def_cfa_offset 16
 244               		.cfi_offset 15, -15
 245 00ce 0F93      		push r16
 246               	.LCFI14:
 247               		.cfi_def_cfa_offset 17
 248               		.cfi_offset 16, -16
 249 00d0 1F93      		push r17
 250               	.LCFI15:
 251               		.cfi_def_cfa_offset 18
 252               		.cfi_offset 17, -17
 253 00d2 CF93      		push r28
 254               	.LCFI16:
 255               		.cfi_def_cfa_offset 19
 256               		.cfi_offset 28, -18
 257 00d4 DF93      		push r29
 258               	.LCFI17:
 259               		.cfi_def_cfa_offset 20
 260               		.cfi_offset 29, -19
 261 00d6 CDB7      		in r28,__SP_L__
 262 00d8 DEB7      		in r29,__SP_H__
 263               	.LCFI18:
 264               		.cfi_def_cfa_register 28
 265 00da 6597      		sbiw r28,21
 266               	.LCFI19:
 267               		.cfi_def_cfa_offset 41
 268 00dc 0FB6      		in __tmp_reg__,__SREG__
 269 00de F894      		cli
 270 00e0 DEBF      		out __SP_H__,r29
 271 00e2 0FBE      		out __SREG__,__tmp_reg__
 272 00e4 CDBF      		out __SP_L__,r28
 273               	/* prologue: function */
 274               	/* frame size = 21 */
 275               	/* stack size = 39 */
 276               	.L__stack_usage = 39
 277 00e6 F42E      		mov r15,r20
 359:draw.c        ****     int r = rin;
 278               		.loc 1 359 0
 279 00e8 602E      		mov r6,r16
 280 00ea 712C      		mov r7,__zero_reg__
 281               	.LVL23:
 360:draw.c        ****     int f = 1 - r;
 282               		.loc 1 360 0
 283 00ec 41E0      		ldi r20,lo8(1)
 284 00ee 50E0      		ldi r21,0
 285               	.LVL24:
 286 00f0 4619      		sub r20,r6
 287 00f2 5709      		sbc r21,r7
 288 00f4 5887      		std Y+8,r21
 289 00f6 4F83      		std Y+7,r20
 290               	.LVL25:
 361:draw.c        ****     int ddF_x = 1;
 362:draw.c        ****     int ddF_y = -2 * r;
 291               		.loc 1 362 0
 292 00f8 EE27      		clr r30
 293 00fa FF27      		clr r31
 294 00fc E619      		sub r30,r6
 295 00fe F709      		sbc r31,r7
 296 0100 EE0F      		lsl r30
 297 0102 FF1F      		rol r31
 298 0104 FC87      		std Y+12,r31
 299 0106 EB87      		std Y+11,r30
 300               	.LVL26:
 363:draw.c        ****     int x = 0;
 364:draw.c        ****     int y = r;
 365:draw.c        ****     int x0 = xin;
 301               		.loc 1 365 0
 302 0108 282E      		mov r2,r24
 303 010a 312C      		mov r3,__zero_reg__
 304               	.LVL27:
 366:draw.c        ****     int y0 = yin;
 305               		.loc 1 366 0
 306 010c 862E      		mov r8,r22
 307 010e 912C      		mov r9,__zero_reg__
 308               	.LVL28:
 367:draw.c        ****     int xstart;
 368:draw.c        **** 
 369:draw.c        ****     // Sort out the drawing mode
 370:draw.c        ****     s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~MODE_NORMAL_MASK);
 309               		.loc 1 370 0
 310 0110 8E2D      		mov r24,r14
 311               	.LVL29:
 312 0112 8095      		com r24
 313 0114 9091 0000 		lds r25,prefs+4
 314 0118 8927      		eor r24,r25
 315 011a 80FB      		bst r24,0
 316 011c E0F8      		bld r14,0
 317               	.LVL30:
 318 011e 422F      		mov r20,r18
 319               	.LVL31:
 320 0120 50E0      		ldi r21,0
 321 0122 5E83      		std Y+6,r21
 322 0124 4D83      		std Y+5,r20
 323 0126 480D      		add r20,r8
 324 0128 591D      		adc r21,r9
 325 012a 5C83      		std Y+4,r21
 326 012c 4B83      		std Y+3,r20
 371:draw.c        ****     xstart = x;
 372:draw.c        ****     while(x < y)
 327               		.loc 1 372 0
 328 012e 412C      		mov r4,__zero_reg__
 329 0130 512C      		mov r5,__zero_reg__
 371:draw.c        ****     xstart = x;
 330               		.loc 1 371 0
 331 0132 1D8A      		std Y+21,__zero_reg__
 332 0134 1C8A      		std Y+20,__zero_reg__
 333 0136 388A      		std Y+16,r3
 334 0138 2F86      		std Y+15,r2
 335 013a 8F2D      		mov r24,r15
 336 013c 90E0      		ldi r25,0
 337 013e 9A87      		std Y+10,r25
 338 0140 8987      		std Y+9,r24
 373:draw.c        ****     {
 374:draw.c        ****         if(f >= 0)
 375:draw.c        ****         {
 376:draw.c        ****             if (xstart == 0)
 377:draw.c        ****             {
 378:draw.c        ****                 // For the first co-ordinate x = 0 then coersce the lines as
 379:draw.c        ****                 // they are abutting each other and we do not want them to
 380:draw.c        ****                 // overlap in an xor operation which would cancel out 2 draw operations.
 381:draw.c        ****                 clip_hline (x0 - x, y0 - y,        x0 + x + xgap, s_r);  // 1/8 + 8/8
 382:draw.c        ****                 clip_hline (x0 - x, y0 + y + ygap, x0 + x + xgap, s_r);  // 4/8 + 5/8
 383:draw.c        **** 
 384:draw.c        ****                 if (s_r & MODE_FILL)
 385:draw.c        ****                 {
 386:draw.c        ****                     int ii;
 387:draw.c        **** 
 388:draw.c        ****                     // Fill the lines
 389:draw.c        ****                     for (ii = y0 - x; ii <= y0 + x + ygap; ii++)
 390:draw.c        ****                         clip_hline (x0 - y, ii, x0 + y + xgap, s_r);
 391:draw.c        ****                 }
 392:draw.c        ****                 else
 393:draw.c        ****                 {
 394:draw.c        ****                     // Draw the lines
 395:draw.c        ****                     clip_vline (x0 + y + xgap, y0 + x + ygap, y0 - x, s_r);  // 2/8 + 3/8
 396:draw.c        ****                     clip_vline (x0 - y,        y0 + x + ygap, y0 - x, s_r);  // 6/8 + 7/8
 397:draw.c        ****                 }
 398:draw.c        ****             }
 399:draw.c        ****             else
 400:draw.c        ****             {
 401:draw.c        ****                 if (s_r & MODE_FILL)
 339               		.loc 1 401 0
 340 0142 3E2D      		mov r19,r14
 341 0144 3870      		andi r19,lo8(8)
 342 0146 3B8B      		std Y+19,r19
 343 0148 820D      		add r24,r2
 344 014a 931D      		adc r25,r3
 345 014c 9A8B      		std Y+18,r25
 346 014e 898B      		std Y+17,r24
 347 0150 9E86      		std Y+14,r9
 348 0152 8D86      		std Y+13,r8
 349               	.LVL32:
 350               	.L15:
 372:draw.c        ****     while(x < y)
 351               		.loc 1 372 0 discriminator 1
 352 0154 4614      		cp r4,r6
 353 0156 5704      		cpc r5,r7
 354 0158 04F0      		brlt .+2
 355 015a 00C0      		rjmp .L36
 374:draw.c        ****         if(f >= 0)
 356               		.loc 1 374 0
 357 015c 4F81      		ldd r20,Y+7
 358 015e 5885      		ldd r21,Y+8
 359 0160 57FD      		sbrc r21,7
 360 0162 00C0      		rjmp .L16
 361 0164 8401      		movw r16,r8
 362 0166 0619      		sub r16,r6
 363 0168 1709      		sbc r17,r7
 376:draw.c        ****             if (xstart == 0)
 364               		.loc 1 376 0
 365 016a 8C89      		ldd r24,Y+20
 366 016c 9D89      		ldd r25,Y+21
 367 016e 892B      		or r24,r25
 368 0170 01F0      		breq .+2
 369 0172 00C0      		rjmp .L17
 381:draw.c        ****                 clip_hline (x0 - x, y0 - y,        x0 + x + xgap, s_r);  // 1/8 + 8/8
 370               		.loc 1 381 0
 371 0174 2E2D      		mov r18,r14
 372 0176 C988      		ldd r12,Y+17
 373 0178 DA88      		ldd r13,Y+18
 374 017a C40C      		add r12,r4
 375 017c D51C      		adc r13,r5
 376 017e A601      		movw r20,r12
 377 0180 B801      		movw r22,r16
 378 0182 0F85      		ldd r16,Y+15
 379 0184 1889      		ldd r17,Y+16
 380 0186 0419      		sub r16,r4
 381 0188 1509      		sbc r17,r5
 382 018a C801      		movw r24,r16
 383 018c 0E94 0000 		call clip_hline
 384               	.LVL33:
 382:draw.c        ****                 clip_hline (x0 - x, y0 + y + ygap, x0 + x + xgap, s_r);  // 4/8 + 5/8
 385               		.loc 1 382 0
 386 0190 B401      		movw r22,r8
 387 0192 660D      		add r22,r6
 388 0194 771D      		adc r23,r7
 389 0196 ED81      		ldd r30,Y+5
 390 0198 FE81      		ldd r31,Y+6
 391 019a 6E0F      		add r22,r30
 392 019c 7F1F      		adc r23,r31
 393 019e 2E2D      		mov r18,r14
 394 01a0 A601      		movw r20,r12
 395 01a2 C801      		movw r24,r16
 396 01a4 0E94 0000 		call clip_hline
 397               	.LVL34:
 384:draw.c        ****                 if (s_r & MODE_FILL)
 398               		.loc 1 384 0
 399 01a8 3B89      		ldd r19,Y+19
 400 01aa 3323      		tst r19
 401 01ac 01F0      		breq .L18
 402 01ae AD84      		ldd r10,Y+13
 403 01b0 BE84      		ldd r11,Y+14
 404 01b2 A418      		sub r10,r4
 405 01b4 B508      		sbc r11,r5
 406               	.LVL35:
 407               	.LBB20:
 390:draw.c        ****                         clip_hline (x0 - y, ii, x0 + y + xgap, s_r);
 408               		.loc 1 390 0
 409 01b6 6101      		movw r12,r2
 410 01b8 C60C      		add r12,r6
 411 01ba D71C      		adc r13,r7
 412 01bc 4985      		ldd r20,Y+9
 413 01be 5A85      		ldd r21,Y+10
 414 01c0 C40E      		add r12,r20
 415 01c2 D51E      		adc r13,r21
 416 01c4 8101      		movw r16,r2
 417 01c6 0619      		sub r16,r6
 418 01c8 1709      		sbc r17,r7
 419               	.L19:
 389:draw.c        ****                     for (ii = y0 - x; ii <= y0 + x + ygap; ii++)
 420               		.loc 1 389 0 discriminator 1
 421 01ca 8B81      		ldd r24,Y+3
 422 01cc 9C81      		ldd r25,Y+4
 423 01ce 8A15      		cp r24,r10
 424 01d0 9B05      		cpc r25,r11
 425 01d2 04F4      		brge .+2
 426 01d4 00C0      		rjmp .L21
 390:draw.c        ****                         clip_hline (x0 - y, ii, x0 + y + xgap, s_r);
 427               		.loc 1 390 0 discriminator 2
 428 01d6 2E2D      		mov r18,r14
 429 01d8 A601      		movw r20,r12
 430 01da B501      		movw r22,r10
 431 01dc C801      		movw r24,r16
 432 01de 0E94 0000 		call clip_hline
 433               	.LVL36:
 389:draw.c        ****                     for (ii = y0 - x; ii <= y0 + x + ygap; ii++)
 434               		.loc 1 389 0 discriminator 2
 435 01e2 5FEF      		ldi r21,-1
 436 01e4 A51A      		sub r10,r21
 437 01e6 B50A      		sbc r11,r21
 438               	.LVL37:
 439 01e8 00C0      		rjmp .L19
 440               	.LVL38:
 441               	.L18:
 442               	.LBE20:
 395:draw.c        ****                     clip_vline (x0 + y + xgap, y0 + x + ygap, y0 - x, s_r);  // 2/8 + 3/8
 443               		.loc 1 395 0
 444 01ea 2E2D      		mov r18,r14
 445 01ec 0D85      		ldd r16,Y+13
 446 01ee 1E85      		ldd r17,Y+14
 447 01f0 0419      		sub r16,r4
 448 01f2 1509      		sbc r17,r5
 449 01f4 A801      		movw r20,r16
 450 01f6 6B81      		ldd r22,Y+3
 451 01f8 7C81      		ldd r23,Y+4
 452 01fa C101      		movw r24,r2
 453 01fc 860D      		add r24,r6
 454 01fe 971D      		adc r25,r7
 455 0200 E985      		ldd r30,Y+9
 456 0202 FA85      		ldd r31,Y+10
 457 0204 8E0F      		add r24,r30
 458 0206 9F1F      		adc r25,r31
 459 0208 0E94 0000 		call clip_vline
 460               	.LVL39:
 396:draw.c        ****                     clip_vline (x0 - y,        y0 + x + ygap, y0 - x, s_r);  // 6/8 + 7/8
 461               		.loc 1 396 0
 462 020c 2E2D      		mov r18,r14
 463 020e A801      		movw r20,r16
 464 0210 6B81      		ldd r22,Y+3
 465 0212 7C81      		ldd r23,Y+4
 466 0214 C101      		movw r24,r2
 467 0216 8619      		sub r24,r6
 468 0218 9709      		sbc r25,r7
 469 021a 00C0      		rjmp .L35
 470               	.LVL40:
 471               	.L17:
 472               		.loc 1 401 0
 473 021c 3B89      		ldd r19,Y+19
 474 021e 3323      		tst r19
 475 0220 01F4      		brne .+2
 476 0222 00C0      		rjmp .L22
 477               	.LBB21:
 402:draw.c        ****                 {
 403:draw.c        ****                     // Fill the lines
 404:draw.c        ****                     clip_hline (x0 - x, y0 - y,        x0 + x + xgap, s_r);  // 1/8 + 8/8
 478               		.loc 1 404 0
 479 0224 2E2D      		mov r18,r14
 480 0226 C988      		ldd r12,Y+17
 481 0228 DA88      		ldd r13,Y+18
 482 022a C40C      		add r12,r4
 483 022c D51C      		adc r13,r5
 484 022e A601      		movw r20,r12
 485               	.LVL41:
 486 0230 B801      		movw r22,r16
 487 0232 0F85      		ldd r16,Y+15
 488 0234 1889      		ldd r17,Y+16
 489 0236 0419      		sub r16,r4
 490 0238 1509      		sbc r17,r5
 491 023a C801      		movw r24,r16
 492               	.LVL42:
 493 023c 0E94 0000 		call clip_hline
 494               	.LVL43:
 405:draw.c        ****                     clip_hline (x0 - x, y0 + y + ygap, x0 + x + xgap, s_r);  // 4/8 + 5/8
 495               		.loc 1 405 0
 496 0240 B401      		movw r22,r8
 497 0242 660D      		add r22,r6
 498 0244 771D      		adc r23,r7
 499 0246 4D81      		ldd r20,Y+5
 500 0248 5E81      		ldd r21,Y+6
 501 024a 640F      		add r22,r20
 502 024c 751F      		adc r23,r21
 503 024e 2E2D      		mov r18,r14
 504 0250 A601      		movw r20,r12
 505 0252 C801      		movw r24,r16
 506 0254 0E94 0000 		call clip_hline
 507               	.LVL44:
 508 0258 0D85      		ldd r16,Y+13
 509 025a 1E85      		ldd r17,Y+14
 510 025c 0419      		sub r16,r4
 511 025e 1509      		sbc r17,r5
 512               	.LVL45:
 406:draw.c        **** 
 407:draw.c        ****                     int ii;
 408:draw.c        ****                     for (ii = y0 - x; ii <= y0 - xstart; ii++)
 513               		.loc 1 408 0
 514 0260 C401      		movw r24,r8
 515 0262 EC89      		ldd r30,Y+20
 516 0264 FD89      		ldd r31,Y+21
 517 0266 8E1B      		sub r24,r30
 518 0268 9F0B      		sbc r25,r31
 519 026a 9A83      		std Y+2,r25
 520 026c 8983      		std Y+1,r24
 409:draw.c        ****                         clip_hline (x0 - y, ii, x0 + y + xgap, s_r);    // 2/8 + 7/8
 521               		.loc 1 409 0
 522 026e 6101      		movw r12,r2
 523 0270 C60C      		add r12,r6
 524 0272 D71C      		adc r13,r7
 525 0274 2985      		ldd r18,Y+9
 526 0276 3A85      		ldd r19,Y+10
 527 0278 C20E      		add r12,r18
 528 027a D31E      		adc r13,r19
 529 027c 5101      		movw r10,r2
 530 027e A618      		sub r10,r6
 531 0280 B708      		sbc r11,r7
 532               	.L23:
 408:draw.c        ****                     for (ii = y0 - x; ii <= y0 - xstart; ii++)
 533               		.loc 1 408 0 discriminator 1
 534 0282 4981      		ldd r20,Y+1
 535 0284 5A81      		ldd r21,Y+2
 536 0286 4017      		cp r20,r16
 537 0288 5107      		cpc r21,r17
 538 028a 04F0      		brlt .L37
 539               		.loc 1 409 0 discriminator 2
 540 028c 2E2D      		mov r18,r14
 541 028e A601      		movw r20,r12
 542 0290 B801      		movw r22,r16
 543 0292 C501      		movw r24,r10
 544 0294 0E94 0000 		call clip_hline
 545               	.LVL46:
 408:draw.c        ****                     for (ii = y0 - x; ii <= y0 - xstart; ii++)
 546               		.loc 1 408 0 discriminator 2
 547 0298 0F5F      		subi r16,-1
 548 029a 1F4F      		sbci r17,-1
 549               	.LVL47:
 550 029c 00C0      		rjmp .L23
 551               	.L37:
 410:draw.c        ****                     for (ii = y0 + xstart + ygap; ii <= y0 + x + ygap; ii++)
 552               		.loc 1 410 0
 553 029e AC88      		ldd r10,Y+20
 554 02a0 BD88      		ldd r11,Y+21
 555 02a2 A80C      		add r10,r8
 556 02a4 B91C      		adc r11,r9
 557 02a6 8D81      		ldd r24,Y+5
 558 02a8 9E81      		ldd r25,Y+6
 559 02aa A80E      		add r10,r24
 560 02ac B91E      		adc r11,r25
 561               	.LVL48:
 411:draw.c        ****                         clip_hline (x0 - y, ii, x0 + y + xgap, s_r);    // 3/8 + 6/8
 562               		.loc 1 411 0
 563 02ae 6101      		movw r12,r2
 564 02b0 C60C      		add r12,r6
 565 02b2 D71C      		adc r13,r7
 566 02b4 E985      		ldd r30,Y+9
 567 02b6 FA85      		ldd r31,Y+10
 568 02b8 CE0E      		add r12,r30
 569 02ba DF1E      		adc r13,r31
 570 02bc 8101      		movw r16,r2
 571 02be 0619      		sub r16,r6
 572 02c0 1709      		sbc r17,r7
 573               	.L25:
 410:draw.c        ****                     for (ii = y0 + xstart + ygap; ii <= y0 + x + ygap; ii++)
 574               		.loc 1 410 0 discriminator 1
 575 02c2 2B81      		ldd r18,Y+3
 576 02c4 3C81      		ldd r19,Y+4
 577 02c6 2A15      		cp r18,r10
 578 02c8 3B05      		cpc r19,r11
 579 02ca 04F4      		brge .+2
 580 02cc 00C0      		rjmp .L21
 581               		.loc 1 411 0 discriminator 2
 582 02ce 2E2D      		mov r18,r14
 583 02d0 A601      		movw r20,r12
 584 02d2 B501      		movw r22,r10
 585 02d4 C801      		movw r24,r16
 586 02d6 0E94 0000 		call clip_hline
 587               	.LVL49:
 410:draw.c        ****                     for (ii = y0 + xstart + ygap; ii <= y0 + x + ygap; ii++)
 588               		.loc 1 410 0 discriminator 2
 589 02da FFEF      		ldi r31,-1
 590 02dc AF1A      		sub r10,r31
 591 02de BF0A      		sbc r11,r31
 592               	.LVL50:
 593 02e0 00C0      		rjmp .L25
 594               	.LVL51:
 595               	.L22:
 596               	.LBE21:
 412:draw.c        ****                 }
 413:draw.c        ****                 else
 414:draw.c        ****                 {
 415:draw.c        ****                     // For the rest of the lines then draw each octant.
 416:draw.c        ****                     clip_hline (x0 + xstart + xgap, y0 - y,        x0 + x + xgap, s_r);  // 1/8
 597               		.loc 1 416 0
 598 02e2 AC88      		ldd r10,Y+20
 599 02e4 BD88      		ldd r11,Y+21
 600 02e6 A20C      		add r10,r2
 601 02e8 B31C      		adc r11,r3
 602 02ea 4985      		ldd r20,Y+9
 603 02ec 5A85      		ldd r21,Y+10
 604               	.LVL52:
 605 02ee A40E      		add r10,r20
 606 02f0 B51E      		adc r11,r21
 607 02f2 2E2D      		mov r18,r14
 608 02f4 8989      		ldd r24,Y+17
 609 02f6 9A89      		ldd r25,Y+18
 610               	.LVL53:
 611 02f8 840D      		add r24,r4
 612 02fa 951D      		adc r25,r5
 613 02fc 9A83      		std Y+2,r25
 614 02fe 8983      		std Y+1,r24
 615 0300 AC01      		movw r20,r24
 616 0302 B801      		movw r22,r16
 617 0304 C501      		movw r24,r10
 618 0306 0E94 0000 		call clip_hline
 619               	.LVL54:
 417:draw.c        ****                     clip_hline (x0 + xstart + xgap, y0 + y + ygap, x0 + x + xgap, s_r);  // 4/8
 620               		.loc 1 417 0
 621 030a 6401      		movw r12,r8
 622 030c C60C      		add r12,r6
 623 030e D71C      		adc r13,r7
 624 0310 ED81      		ldd r30,Y+5
 625 0312 FE81      		ldd r31,Y+6
 626 0314 CE0E      		add r12,r30
 627 0316 DF1E      		adc r13,r31
 628 0318 2E2D      		mov r18,r14
 629 031a 4981      		ldd r20,Y+1
 630 031c 5A81      		ldd r21,Y+2
 631 031e B601      		movw r22,r12
 632 0320 C501      		movw r24,r10
 633 0322 0E94 0000 		call clip_hline
 634               	.LVL55:
 418:draw.c        ****                     clip_hline (x0 - xstart,        y0 + y + ygap, x0 - x,        s_r);  // 5/8
 635               		.loc 1 418 0
 636 0326 5101      		movw r10,r2
 637 0328 2C89      		ldd r18,Y+20
 638 032a 3D89      		ldd r19,Y+21
 639 032c A21A      		sub r10,r18
 640 032e B30A      		sbc r11,r19
 641 0330 2E2D      		mov r18,r14
 642 0332 4F85      		ldd r20,Y+15
 643 0334 5889      		ldd r21,Y+16
 644 0336 4419      		sub r20,r4
 645 0338 5509      		sbc r21,r5
 646 033a 5A83      		std Y+2,r21
 647 033c 4983      		std Y+1,r20
 648 033e B601      		movw r22,r12
 649 0340 C501      		movw r24,r10
 650 0342 0E94 0000 		call clip_hline
 651               	.LVL56:
 419:draw.c        ****                     clip_hline (x0 - xstart,        y0 - y,        x0 - x,        s_r);  // 8/8
 652               		.loc 1 419 0
 653 0346 2E2D      		mov r18,r14
 654 0348 4981      		ldd r20,Y+1
 655 034a 5A81      		ldd r21,Y+2
 656 034c B801      		movw r22,r16
 657 034e C501      		movw r24,r10
 658 0350 0E94 0000 		call clip_hline
 659               	.LVL57:
 420:draw.c        **** 
 421:draw.c        ****                     clip_vline (x0 + y + xgap, y0 + xstart + ygap, y0 + x + ygap, s_r);  // 3/8
 660               		.loc 1 421 0
 661 0354 0C89      		ldd r16,Y+20
 662 0356 1D89      		ldd r17,Y+21
 663 0358 080D      		add r16,r8
 664 035a 191D      		adc r17,r9
 665 035c 8D81      		ldd r24,Y+5
 666 035e 9E81      		ldd r25,Y+6
 667 0360 080F      		add r16,r24
 668 0362 191F      		adc r17,r25
 669 0364 6101      		movw r12,r2
 670 0366 C60C      		add r12,r6
 671 0368 D71C      		adc r13,r7
 672 036a E985      		ldd r30,Y+9
 673 036c FA85      		ldd r31,Y+10
 674 036e CE0E      		add r12,r30
 675 0370 DF1E      		adc r13,r31
 676 0372 2E2D      		mov r18,r14
 677 0374 4B81      		ldd r20,Y+3
 678 0376 5C81      		ldd r21,Y+4
 679 0378 B801      		movw r22,r16
 680 037a C601      		movw r24,r12
 681 037c 0E94 0000 		call clip_vline
 682               	.LVL58:
 422:draw.c        ****                     clip_vline (x0 + y + xgap, y0 - xstart,        y0 - x,        s_r);  // 2/8
 683               		.loc 1 422 0
 684 0380 9401      		movw r18,r8
 685 0382 4C89      		ldd r20,Y+20
 686 0384 5D89      		ldd r21,Y+21
 687 0386 241B      		sub r18,r20
 688 0388 350B      		sbc r19,r21
 689 038a 3A83      		std Y+2,r19
 690 038c 2983      		std Y+1,r18
 691 038e 2E2D      		mov r18,r14
 692 0390 AD84      		ldd r10,Y+13
 693 0392 BE84      		ldd r11,Y+14
 694 0394 A418      		sub r10,r4
 695 0396 B508      		sbc r11,r5
 696 0398 A501      		movw r20,r10
 697 039a 6981      		ldd r22,Y+1
 698 039c 7A81      		ldd r23,Y+2
 699 039e C601      		movw r24,r12
 700 03a0 0E94 0000 		call clip_vline
 701               	.LVL59:
 423:draw.c        ****                     clip_vline (x0 - y,        y0 - xstart,        y0 - x,        s_r);  // 7/8
 702               		.loc 1 423 0
 703 03a4 2E2D      		mov r18,r14
 704 03a6 A501      		movw r20,r10
 705 03a8 6981      		ldd r22,Y+1
 706 03aa 7A81      		ldd r23,Y+2
 707 03ac 6101      		movw r12,r2
 708 03ae C618      		sub r12,r6
 709 03b0 D708      		sbc r13,r7
 710 03b2 C601      		movw r24,r12
 711 03b4 0E94 0000 		call clip_vline
 712               	.LVL60:
 424:draw.c        ****                     clip_vline (x0 - y,        y0 + xstart + ygap, y0 + x + ygap, s_r);  // 6/8
 713               		.loc 1 424 0
 714 03b8 2E2D      		mov r18,r14
 715 03ba 4B81      		ldd r20,Y+3
 716 03bc 5C81      		ldd r21,Y+4
 717 03be B801      		movw r22,r16
 718 03c0 C601      		movw r24,r12
 719               	.L35:
 720 03c2 0E94 0000 		call clip_vline
 721               	.LVL61:
 722               	.L21:
 425:draw.c        ****                 }
 426:draw.c        ****             }
 427:draw.c        ****             y--;
 723               		.loc 1 427 0 discriminator 2
 724 03c6 51E0      		ldi r21,1
 725 03c8 651A      		sub r6,r21
 726 03ca 7108      		sbc r7,__zero_reg__
 727               	.LVL62:
 428:draw.c        ****             ddF_y += 2;
 728               		.loc 1 428 0 discriminator 2
 729 03cc 8B85      		ldd r24,Y+11
 730 03ce 9C85      		ldd r25,Y+12
 731 03d0 0296      		adiw r24,2
 732 03d2 9C87      		std Y+12,r25
 733 03d4 8B87      		std Y+11,r24
 734               	.LVL63:
 429:draw.c        ****             f += ddF_y;
 735               		.loc 1 429 0 discriminator 2
 736 03d6 EF81      		ldd r30,Y+7
 737 03d8 F885      		ldd r31,Y+8
 738 03da E80F      		add r30,r24
 739 03dc F91F      		adc r31,r25
 740 03de F887      		std Y+8,r31
 741 03e0 EF83      		std Y+7,r30
 742               	.LVL64:
 743 03e2 9201      		movw r18,r4
 744 03e4 2F5F      		subi r18,-1
 745 03e6 3F4F      		sbci r19,-1
 746 03e8 3D8B      		std Y+21,r19
 747 03ea 2C8B      		std Y+20,r18
 748               	.LVL65:
 749               	.L16:
 750 03ec C201      		movw r24,r4
 751 03ee 880F      		lsl r24
 752 03f0 991F      		rol r25
 753 03f2 0396      		adiw r24,3
 754               	.LVL66:
 430:draw.c        ****             x++;
 431:draw.c        ****             xstart = x;
 432:draw.c        ****         }
 433:draw.c        ****         else
 434:draw.c        ****             x++;
 435:draw.c        ****         ddF_x += 2;
 436:draw.c        ****         f += ddF_x;
 755               		.loc 1 436 0
 756 03f4 4F81      		ldd r20,Y+7
 757 03f6 5885      		ldd r21,Y+8
 758 03f8 480F      		add r20,r24
 759 03fa 591F      		adc r21,r25
 760 03fc 5887      		std Y+8,r21
 761 03fe 4F83      		std Y+7,r20
 762               	.LVL67:
 763 0400 5FEF      		ldi r21,-1
 764 0402 451A      		sub r4,r21
 765 0404 550A      		sbc r5,r21
 766 0406 8B81      		ldd r24,Y+3
 767 0408 9C81      		ldd r25,Y+4
 768               	.LVL68:
 769 040a 0196      		adiw r24,1
 770 040c 9C83      		std Y+4,r25
 771 040e 8B83      		std Y+3,r24
 772 0410 00C0      		rjmp .L15
 773               	.LVL69:
 774               	.L36:
 437:draw.c        ****     }
 438:draw.c        **** 
 439:draw.c        ****     // Handle the last round only if the 2 coordinates are the same. When the
 440:draw.c        ****     // coordinates are different then over-drawing occurs which is why we skip.
 441:draw.c        ****     if (x == y)
 775               		.loc 1 441 0
 776 0412 4614      		cp r4,r6
 777 0414 5704      		cpc r5,r7
 778 0416 01F0      		breq .+2
 779 0418 00C0      		rjmp .L14
 780 041a 8F2D      		mov r24,r15
 781 041c 90E0      		ldi r25,0
 782 041e 6101      		movw r12,r2
 783 0420 C40C      		add r12,r4
 784 0422 D51C      		adc r13,r5
 785 0424 8101      		movw r16,r2
 786 0426 0419      		sub r16,r4
 787 0428 1509      		sbc r17,r5
 788 042a 3401      		movw r6,r8
 789               	.LVL70:
 790 042c 640C      		add r6,r4
 791 042e 751C      		adc r7,r5
 442:draw.c        ****     {
 443:draw.c        ****         if (s_r & MODE_FILL)
 444:draw.c        ****         {
 445:draw.c        ****             // Fill the lines.
 446:draw.c        ****             clip_hline (x0 - x, y0 + y + ygap, x0 + x + xgap, s_r); // 3/8 + 5/8
 792               		.loc 1 446 0
 793 0430 C80E      		add r12,r24
 794 0432 D91E      		adc r13,r25
 443:draw.c        ****         if (s_r & MODE_FILL)
 795               		.loc 1 443 0
 796 0434 E3FE      		sbrs r14,3
 797 0436 00C0      		rjmp .L31
 798               		.loc 1 446 0
 799 0438 6D81      		ldd r22,Y+5
 800 043a 7E81      		ldd r23,Y+6
 801 043c 660D      		add r22,r6
 802 043e 771D      		adc r23,r7
 803 0440 2E2D      		mov r18,r14
 804 0442 A601      		movw r20,r12
 805 0444 C801      		movw r24,r16
 806 0446 0E94 0000 		call clip_hline
 807               	.LVL71:
 447:draw.c        ****             clip_hline (x0 - x, y0 - y,        x0 + x + xgap, s_r); // 1/8 + 7/8
 808               		.loc 1 447 0
 809 044a B401      		movw r22,r8
 810 044c 6419      		sub r22,r4
 811 044e 7509      		sbc r23,r5
 812 0450 2E2D      		mov r18,r14
 813 0452 A601      		movw r20,r12
 814 0454 C801      		movw r24,r16
 815 0456 0E94 0000 		call clip_hline
 816               	.LVL72:
 448:draw.c        ****         }
 449:draw.c        ****         else
 450:draw.c        ****         {
 451:draw.c        ****             // Draw the lines
 452:draw.c        ****             clip_hline (x0 + xstart + xgap, y0 + y + ygap, x0 + x + xgap, s_r);    // 3/8
 453:draw.c        ****             clip_hline (x0 + xstart + xgap, y0 - y,        x0 + x + xgap, s_r);    // 1/8
 454:draw.c        ****             clip_hline (x0 - xstart,        y0 + y + ygap, x0 - x,        s_r);    // 5/8
 455:draw.c        ****             clip_hline (x0 - xstart,        y0 - y,        x0 - x,        s_r);    // 7/8
 456:draw.c        ****         }
 457:draw.c        ****         if (xstart < x)
 817               		.loc 1 457 0
 818 045a EC89      		ldd r30,Y+20
 819 045c FD89      		ldd r31,Y+21
 820 045e E415      		cp r30,r4
 821 0460 F505      		cpc r31,r5
 822 0462 04F0      		brlt .+2
 823 0464 00C0      		rjmp .L14
 458:draw.c        ****         {
 459:draw.c        ****             // In this case then the line is longer than 1 pixel, ensure that
 460:draw.c        ****             // the x is not re-drawn.
 461:draw.c        ****             if (s_r & MODE_FILL)
 462:draw.c        ****             {
 463:draw.c        ****                 // Fill the lines
 464:draw.c        ****                 clip_hline (x0 - y, y0 + xstart + ygap, x0 + y + xgap, s_r);
 824               		.loc 1 464 0
 825 0466 6C89      		ldd r22,Y+20
 826 0468 7D89      		ldd r23,Y+21
 827 046a 680D      		add r22,r8
 828 046c 791D      		adc r23,r9
 829 046e 2D81      		ldd r18,Y+5
 830 0470 3E81      		ldd r19,Y+6
 831 0472 620F      		add r22,r18
 832 0474 731F      		adc r23,r19
 833 0476 2E2D      		mov r18,r14
 834 0478 A601      		movw r20,r12
 835 047a C801      		movw r24,r16
 836 047c 0E94 0000 		call clip_hline
 837               	.LVL73:
 465:draw.c        ****                 clip_hline (x0 - y, y0 - xstart,        x0 + y + xgap, s_r);
 838               		.loc 1 465 0
 839 0480 B401      		movw r22,r8
 840 0482 4C89      		ldd r20,Y+20
 841 0484 5D89      		ldd r21,Y+21
 842 0486 641B      		sub r22,r20
 843 0488 750B      		sbc r23,r21
 844 048a 2E2D      		mov r18,r14
 845 048c A601      		movw r20,r12
 846 048e C801      		movw r24,r16
 847               	/* epilogue start */
 466:draw.c        ****             }
 467:draw.c        ****             else
 468:draw.c        ****             {
 469:draw.c        ****                 // Draw the lines
 470:draw.c        ****                 clip_vline (x0 + y + xgap, y0 + xstart + ygap, y0 + xstart + ygap, s_r);
 471:draw.c        ****                 clip_vline (x0 - y,        y0 + xstart + ygap, y0 + xstart + ygap, s_r);
 472:draw.c        ****                 clip_vline (x0 + y + xgap, y0 - xstart,        y0 - xstart,        s_r);  // 2/8
 473:draw.c        ****                 clip_vline (x0 - y,        y0 - xstart,        y0 - xstart,        s_r);
 474:draw.c        ****             }
 475:draw.c        ****         }
 476:draw.c        ****     }
 477:draw.c        **** }
 848               		.loc 1 477 0
 849 0490 6596      		adiw r28,21
 850 0492 0FB6      		in __tmp_reg__,__SREG__
 851 0494 F894      		cli
 852 0496 DEBF      		out __SP_H__,r29
 853 0498 0FBE      		out __SREG__,__tmp_reg__
 854 049a CDBF      		out __SP_L__,r28
 855 049c DF91      		pop r29
 856 049e CF91      		pop r28
 857 04a0 1F91      		pop r17
 858 04a2 0F91      		pop r16
 859 04a4 FF90      		pop r15
 860               	.LVL74:
 861 04a6 EF90      		pop r14
 862               	.LVL75:
 863 04a8 DF90      		pop r13
 864 04aa CF90      		pop r12
 865 04ac BF90      		pop r11
 866 04ae AF90      		pop r10
 867 04b0 9F90      		pop r9
 868 04b2 8F90      		pop r8
 869               	.LVL76:
 870 04b4 7F90      		pop r7
 871 04b6 6F90      		pop r6
 872 04b8 5F90      		pop r5
 873 04ba 4F90      		pop r4
 874               	.LVL77:
 875 04bc 3F90      		pop r3
 876 04be 2F90      		pop r2
 877               	.LVL78:
 465:draw.c        ****                 clip_hline (x0 - y, y0 - xstart,        x0 + y + xgap, s_r);
 878               		.loc 1 465 0
 879 04c0 0C94 0000 		jmp clip_hline
 880               	.LVL79:
 881               	.L31:
 452:draw.c        ****             clip_hline (x0 + xstart + xgap, y0 + y + ygap, x0 + x + xgap, s_r);    // 3/8
 882               		.loc 1 452 0
 883 04c4 2D81      		ldd r18,Y+5
 884 04c6 3E81      		ldd r19,Y+6
 885 04c8 620E      		add r6,r18
 886 04ca 731E      		adc r7,r19
 887 04cc AC88      		ldd r10,Y+20
 888 04ce BD88      		ldd r11,Y+21
 889 04d0 A20C      		add r10,r2
 890 04d2 B31C      		adc r11,r3
 891 04d4 A80E      		add r10,r24
 892 04d6 B91E      		adc r11,r25
 893 04d8 2E2D      		mov r18,r14
 894 04da A601      		movw r20,r12
 895 04dc B301      		movw r22,r6
 896 04de C501      		movw r24,r10
 897 04e0 0E94 0000 		call clip_hline
 898               	.LVL80:
 453:draw.c        ****             clip_hline (x0 + xstart + xgap, y0 - y,        x0 + x + xgap, s_r);    // 1/8
 899               		.loc 1 453 0
 900 04e4 A401      		movw r20,r8
 901 04e6 4419      		sub r20,r4
 902 04e8 5509      		sbc r21,r5
 903 04ea 5C83      		std Y+4,r21
 904 04ec 4B83      		std Y+3,r20
 905 04ee 2E2D      		mov r18,r14
 906 04f0 A601      		movw r20,r12
 907 04f2 6B81      		ldd r22,Y+3
 908 04f4 7C81      		ldd r23,Y+4
 909 04f6 C501      		movw r24,r10
 910 04f8 0E94 0000 		call clip_hline
 911               	.LVL81:
 454:draw.c        ****             clip_hline (x0 - xstart,        y0 + y + ygap, x0 - x,        s_r);    // 5/8
 912               		.loc 1 454 0
 913 04fc 5101      		movw r10,r2
 914 04fe 8C89      		ldd r24,Y+20
 915 0500 9D89      		ldd r25,Y+21
 916 0502 A81A      		sub r10,r24
 917 0504 B90A      		sbc r11,r25
 918 0506 2E2D      		mov r18,r14
 919 0508 A801      		movw r20,r16
 920 050a B301      		movw r22,r6
 921 050c C501      		movw r24,r10
 922 050e 0E94 0000 		call clip_hline
 923               	.LVL82:
 455:draw.c        ****             clip_hline (x0 - xstart,        y0 - y,        x0 - x,        s_r);    // 7/8
 924               		.loc 1 455 0
 925 0512 2E2D      		mov r18,r14
 926 0514 A801      		movw r20,r16
 927 0516 6B81      		ldd r22,Y+3
 928 0518 7C81      		ldd r23,Y+4
 929 051a C501      		movw r24,r10
 930 051c 0E94 0000 		call clip_hline
 931               	.LVL83:
 457:draw.c        ****         if (xstart < x)
 932               		.loc 1 457 0
 933 0520 EC89      		ldd r30,Y+20
 934 0522 FD89      		ldd r31,Y+21
 935 0524 E415      		cp r30,r4
 936 0526 F505      		cpc r31,r5
 937 0528 04F4      		brge .L14
 470:draw.c        ****                 clip_vline (x0 + y + xgap, y0 + xstart + ygap, y0 + xstart + ygap, s_r);
 938               		.loc 1 470 0
 939 052a AC88      		ldd r10,Y+20
 940 052c BD88      		ldd r11,Y+21
 941 052e A80C      		add r10,r8
 942 0530 B91C      		adc r11,r9
 943 0532 8D81      		ldd r24,Y+5
 944 0534 9E81      		ldd r25,Y+6
 945 0536 A80E      		add r10,r24
 946 0538 B91E      		adc r11,r25
 947 053a 2E2D      		mov r18,r14
 948 053c A501      		movw r20,r10
 949 053e B501      		movw r22,r10
 950 0540 C601      		movw r24,r12
 951 0542 0E94 0000 		call clip_vline
 952               	.LVL84:
 471:draw.c        ****                 clip_vline (x0 - y,        y0 + xstart + ygap, y0 + xstart + ygap, s_r);
 953               		.loc 1 471 0
 954 0546 2E2D      		mov r18,r14
 955 0548 A501      		movw r20,r10
 956 054a B501      		movw r22,r10
 957 054c C801      		movw r24,r16
 958 054e 0E94 0000 		call clip_vline
 959               	.LVL85:
 472:draw.c        ****                 clip_vline (x0 + y + xgap, y0 - xstart,        y0 - xstart,        s_r);  // 2/8
 960               		.loc 1 472 0
 961 0552 EC89      		ldd r30,Y+20
 962 0554 FD89      		ldd r31,Y+21
 963 0556 8E1A      		sub r8,r30
 964 0558 9F0A      		sbc r9,r31
 965               	.LVL86:
 966 055a 2E2D      		mov r18,r14
 967 055c A401      		movw r20,r8
 968 055e B401      		movw r22,r8
 969 0560 C601      		movw r24,r12
 970 0562 0E94 0000 		call clip_vline
 971               	.LVL87:
 473:draw.c        ****                 clip_vline (x0 - y,        y0 - xstart,        y0 - xstart,        s_r);
 972               		.loc 1 473 0
 973 0566 2E2D      		mov r18,r14
 974 0568 A401      		movw r20,r8
 975 056a B401      		movw r22,r8
 976 056c C801      		movw r24,r16
 977               	/* epilogue start */
 978               		.loc 1 477 0
 979 056e 6596      		adiw r28,21
 980 0570 0FB6      		in __tmp_reg__,__SREG__
 981 0572 F894      		cli
 982 0574 DEBF      		out __SP_H__,r29
 983 0576 0FBE      		out __SREG__,__tmp_reg__
 984 0578 CDBF      		out __SP_L__,r28
 985 057a DF91      		pop r29
 986 057c CF91      		pop r28
 987 057e 1F91      		pop r17
 988 0580 0F91      		pop r16
 989 0582 FF90      		pop r15
 990               	.LVL88:
 991 0584 EF90      		pop r14
 992               	.LVL89:
 993 0586 DF90      		pop r13
 994 0588 CF90      		pop r12
 995 058a BF90      		pop r11
 996 058c AF90      		pop r10
 997 058e 9F90      		pop r9
 998 0590 8F90      		pop r8
 999 0592 7F90      		pop r7
 1000 0594 6F90      		pop r6
 1001 0596 5F90      		pop r5
 1002 0598 4F90      		pop r4
 1003               	.LVL90:
 1004 059a 3F90      		pop r3
 1005 059c 2F90      		pop r2
 1006               	.LVL91:
 473:draw.c        ****                 clip_vline (x0 - y,        y0 - xstart,        y0 - xstart,        s_r);
 1007               		.loc 1 473 0
 1008 059e 0C94 0000 		jmp clip_vline
 1009               	.LVL92:
 1010               	.L14:
 1011               	/* epilogue start */
 1012               		.loc 1 477 0
 1013 05a2 6596      		adiw r28,21
 1014 05a4 0FB6      		in __tmp_reg__,__SREG__
 1015 05a6 F894      		cli
 1016 05a8 DEBF      		out __SP_H__,r29
 1017 05aa 0FBE      		out __SREG__,__tmp_reg__
 1018 05ac CDBF      		out __SP_L__,r28
 1019 05ae DF91      		pop r29
 1020 05b0 CF91      		pop r28
 1021 05b2 1F91      		pop r17
 1022 05b4 0F91      		pop r16
 1023 05b6 FF90      		pop r15
 1024               	.LVL93:
 1025 05b8 EF90      		pop r14
 1026               	.LVL94:
 1027 05ba DF90      		pop r13
 1028 05bc CF90      		pop r12
 1029 05be BF90      		pop r11
 1030 05c0 AF90      		pop r10
 1031 05c2 9F90      		pop r9
 1032 05c4 8F90      		pop r8
 1033               	.LVL95:
 1034 05c6 7F90      		pop r7
 1035 05c8 6F90      		pop r6
 1036 05ca 5F90      		pop r5
 1037 05cc 4F90      		pop r4
 1038               	.LVL96:
 1039 05ce 3F90      		pop r3
 1040 05d0 2F90      		pop r2
 1041               	.LVL97:
 1042 05d2 0895      		ret
 1043               		.cfi_endproc
 1044               	.LFE17:
 1046               	.global	draw_mode
 1048               	draw_mode:
 1049               	.LFB11:
  66:draw.c        **** {
 1050               		.loc 1 66 0
 1051               		.cfi_startproc
 1052               	.LVL98:
 1053               	/* prologue: function */
 1054               	/* frame size = 0 */
 1055               	/* stack size = 0 */
 1056               	.L__stack_usage = 0
  67:draw.c        ****     drawing_mode = mode;
 1057               		.loc 1 67 0
 1058 05d4 8093 0000 		sts drawing_mode,r24
 1059 05d8 0895      		ret
 1060               		.cfi_endproc
 1061               	.LFE11:
 1063               	.global	draw_line
 1065               	draw_line:
 1066               	.LFB12:
  90:draw.c        **** {
 1067               		.loc 1 90 0
 1068               		.cfi_startproc
 1069               	.LVL99:
 1070 05da 6F92      		push r6
 1071               	.LCFI20:
 1072               		.cfi_def_cfa_offset 3
 1073               		.cfi_offset 6, -2
 1074 05dc 7F92      		push r7
 1075               	.LCFI21:
 1076               		.cfi_def_cfa_offset 4
 1077               		.cfi_offset 7, -3
 1078 05de 8F92      		push r8
 1079               	.LCFI22:
 1080               		.cfi_def_cfa_offset 5
 1081               		.cfi_offset 8, -4
 1082 05e0 9F92      		push r9
 1083               	.LCFI23:
 1084               		.cfi_def_cfa_offset 6
 1085               		.cfi_offset 9, -5
 1086 05e2 AF92      		push r10
 1087               	.LCFI24:
 1088               		.cfi_def_cfa_offset 7
 1089               		.cfi_offset 10, -6
 1090 05e4 BF92      		push r11
 1091               	.LCFI25:
 1092               		.cfi_def_cfa_offset 8
 1093               		.cfi_offset 11, -7
 1094 05e6 CF92      		push r12
 1095               	.LCFI26:
 1096               		.cfi_def_cfa_offset 9
 1097               		.cfi_offset 12, -8
 1098 05e8 DF92      		push r13
 1099               	.LCFI27:
 1100               		.cfi_def_cfa_offset 10
 1101               		.cfi_offset 13, -9
 1102 05ea EF92      		push r14
 1103               	.LCFI28:
 1104               		.cfi_def_cfa_offset 11
 1105               		.cfi_offset 14, -10
 1106 05ec FF92      		push r15
 1107               	.LCFI29:
 1108               		.cfi_def_cfa_offset 12
 1109               		.cfi_offset 15, -11
 1110 05ee 0F93      		push r16
 1111               	.LCFI30:
 1112               		.cfi_def_cfa_offset 13
 1113               		.cfi_offset 16, -12
 1114 05f0 1F93      		push r17
 1115               	.LCFI31:
 1116               		.cfi_def_cfa_offset 14
 1117               		.cfi_offset 17, -13
 1118 05f2 CF93      		push r28
 1119               	.LCFI32:
 1120               		.cfi_def_cfa_offset 15
 1121               		.cfi_offset 28, -14
 1122 05f4 DF93      		push r29
 1123               	.LCFI33:
 1124               		.cfi_def_cfa_offset 16
 1125               		.cfi_offset 29, -15
 1126               	/* prologue: function */
 1127               	/* frame size = 0 */
 1128               	/* stack size = 14 */
 1129               	.L__stack_usage = 14
 1130 05f6 B82E      		mov r11,r24
 1131 05f8 A62E      		mov r10,r22
  98:draw.c        ****     ps_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & MODE_MODIFIER);
 1132               		.loc 1 98 0
 1133 05fa 902E      		mov r9,r16
 1134 05fc 9094      		com r9
 1135 05fe 8091 0000 		lds r24,prefs+4
 1136               	.LVL100:
 1137 0602 9826      		eor r9,r24
 1138 0604 392D      		mov r19,r9
 1139 0606 3170      		andi r19,lo8(1)
 1140 0608 932E      		mov r9,r19
 1141 060a 802F      		mov r24,r16
 1142 060c 8671      		andi r24,lo8(22)
 1143 060e 982A      		or r9,r24
 1144               	.LVL101:
 1145 0610 842F      		mov r24,r20
 1146 0612 90E0      		ldi r25,0
 1147 0614 CB2D      		mov r28,r11
 1148 0616 D0E0      		ldi r29,0
 101:draw.c        ****     if (x1 >= x)                        // The x-values are increasing
 1149               		.loc 1 101 0
 1150 0618 4B15      		cp r20,r11
 1151 061a 00F0      		brlo .L40
 1152               	.LVL102:
 104:draw.c        ****         deltax = x1 - x;                // The difference between the x's
 1153               		.loc 1 104 0
 1154 061c AC01      		movw r20,r24
 1155               	.LVL103:
 1156 061e 4C1B      		sub r20,r28
 1157 0620 5D0B      		sbc r21,r29
 1158 0622 EA01      		movw r28,r20
 1159               	.LVL104:
 103:draw.c        ****         xinc = 1;
 1160               		.loc 1 103 0
 1161 0624 7724      		clr r7
 1162 0626 7394      		inc r7
 1163 0628 00C0      		rjmp .L41
 1164               	.LVL105:
 1165               	.L40:
 109:draw.c        ****         deltax = x - x1;
 1166               		.loc 1 109 0
 1167 062a C81B      		sub r28,r24
 1168 062c D90B      		sbc r29,r25
 1169               	.LVL106:
 108:draw.c        ****         xinc = -1;
 1170               		.loc 1 108 0
 1171 062e 7724      		clr r7
 1172 0630 7A94      		dec r7
 1173               	.LVL107:
 1174               	.L41:
 1175 0632 822F      		mov r24,r18
 1176               	.LVL108:
 1177 0634 90E0      		ldi r25,0
 1178 0636 EA2C      		mov r14,r10
 1179 0638 F12C      		mov r15,__zero_reg__
 113:draw.c        ****     if (y1 >= y)                       // The y-values are increasing
 1180               		.loc 1 113 0
 1181 063a 2A15      		cp r18,r10
 1182 063c 00F0      		brlo .L42
 1183               	.LVL109:
 116:draw.c        ****         deltay = y1 - y;
 1184               		.loc 1 116 0
 1185 063e FC01      		movw r30,r24
 1186 0640 EE19      		sub r30,r14
 1187 0642 FF09      		sbc r31,r15
 1188 0644 7F01      		movw r14,r30
 1189               	.LVL110:
 115:draw.c        ****         yinc = 1;
 1190               		.loc 1 115 0
 1191 0646 8824      		clr r8
 1192 0648 8394      		inc r8
 1193 064a 00C0      		rjmp .L43
 1194               	.LVL111:
 1195               	.L42:
 121:draw.c        ****         deltay = y - y1;
 1196               		.loc 1 121 0
 1197 064c E81A      		sub r14,r24
 1198 064e F90A      		sbc r15,r25
 1199               	.LVL112:
 120:draw.c        ****         yinc = -1;
 1200               		.loc 1 120 0
 1201 0650 8824      		clr r8
 1202 0652 8A94      		dec r8
 1203               	.LVL113:
 1204               	.L43:
 126:draw.c        ****     if (deltax >= deltay)
 1205               		.loc 1 126 0
 1206 0654 CE15      		cp r28,r14
 1207 0656 DF05      		cpc r29,r15
 1208 0658 04F4      		brge .+2
 1209 065a 00C0      		rjmp .L44
 1210               	.LVL114:
 1211               	.LBB22:
 137:draw.c        ****         numerator = deltax / 2;         // The numerator
 1212               		.loc 1 137 0
 1213 065c 6E01      		movw r12,r28
 1214 065e D7FF      		sbrs r29,7
 1215 0660 00C0      		rjmp .L45
 1216               	.LVL115:
 1217 0662 FFEF      		ldi r31,-1
 1218 0664 CF1A      		sub r12,r31
 1219 0666 DF0A      		sbc r13,r31
 1220               	.LVL116:
 1221               	.L45:
 1222 0668 D594      		asr r13
 1223 066a C794      		ror r12
 1224               	.LVL117:
 142:draw.c        ****         if ((s_r & MODE_LINE_SKIP_LAST) == 0)
 1225               		.loc 1 142 0
 1226 066c 07FD      		sbrc r16,7
 1227 066e 00C0      		rjmp .L60
 143:draw.c        ****             numpixels++;
 1228               		.loc 1 143 0
 1229 0670 8E01      		movw r16,r28
 1230               	.LVL118:
 1231 0672 0F5F      		subi r16,-1
 1232 0674 1F4F      		sbci r17,-1
 1233               	.LVL119:
 1234 0676 00C0      		rjmp .L46
 1235               	.LVL120:
 1236               	.L60:
 1237 0678 8E01      		movw r16,r28
 1238               	.LVL121:
 1239               	.L46:
 146:draw.c        ****         written = numpixels - 1;
 1240               		.loc 1 146 0
 1241 067a 9FEF      		ldi r25,lo8(-1)
 1242 067c 900F      		add r25,r16
 1243               	.LVL122:
 1244               	.L65:
 160:draw.c        ****                 xstart = x;             // New start position
 1245               		.loc 1 160 0
 1246 067e 8B2D      		mov r24,r11
 1247               	.LVL123:
 1248               	.L47:
 149:draw.c        ****         while (--numpixels >= 0)
 1249               		.loc 1 149 0 discriminator 1
 1250 0680 0150      		subi r16,1
 1251 0682 1109      		sbc r17,__zero_reg__
 1252               	.LVL124:
 1253 0684 17FD      		sbrc r17,7
 1254 0686 00C0      		rjmp .L67
 151:draw.c        ****             numerator += numadd;        // Increase the numerator by the top of the fraction
 1255               		.loc 1 151 0
 1256 0688 CE0C      		add r12,r14
 1257 068a DF1C      		adc r13,r15
 1258               	.LVL125:
 1259 068c 6B2C      		mov r6,r11
 1260 068e 670C      		add r6,r7
 152:draw.c        ****             if (numerator >= denominator) // Check if numerator >= denominator
 1261               		.loc 1 152 0
 1262 0690 CC16      		cp r12,r28
 1263 0692 DD06      		cpc r13,r29
 1264 0694 04F0      		brlt .L48
 154:draw.c        ****                 numerator -= denominator; // Calculate the new numerator value
 1265               		.loc 1 154 0
 1266 0696 CC1A      		sub r12,r28
 1267 0698 DD0A      		sbc r13,r29
 1268               	.LVL126:
 1269               	.LBB23:
 155:draw.c        ****                 draw_hline (xstart, y, x, ps_r);
 1270               		.loc 1 155 0
 1271 069a E091 0000 		lds r30,functabP
 1272 069e F091 0000 		lds r31,functabP+1
 1273               	.LVL127:
 1274               	/* #APP */
 1275               	 ;  155 "draw.c" 1
 1276 06a2 A591      		lpm r26, Z+
 1277 06a4 B491      		lpm r27, Z
 1278               		
 1279               	 ;  0 "" 2
 1280               	.LVL128:
 1281               	/* #NOAPP */
 1282               	.LBE23:
 1283 06a6 292D      		mov r18,r9
 1284 06a8 4B2D      		mov r20,r11
 1285 06aa 6A2D      		mov r22,r10
 1286 06ac FD01      		movw r30,r26
 1287 06ae 0995      		icall
 1288               	.LVL129:
 157:draw.c        ****                 y += yinc;              // Change the y as appropriate
 1289               		.loc 1 157 0
 1290 06b0 A80C      		add r10,r8
 1291               	.LVL130:
 158:draw.c        ****                 x += xinc;              // Increment x as required.
 1292               		.loc 1 158 0
 1293 06b2 B62C      		mov r11,r6
 1294               	.LVL131:
 161:draw.c        ****                 written = numpixels;    // Save the write position
 1295               		.loc 1 161 0
 1296 06b4 902F      		mov r25,r16
 1297 06b6 00C0      		rjmp .L65
 1298               	.LVL132:
 1299               	.L48:
 164:draw.c        ****                 x += xinc;
 1300               		.loc 1 164 0
 1301 06b8 B62C      		mov r11,r6
 1302               	.LVL133:
 1303 06ba 00C0      		rjmp .L47
 1304               	.LVL134:
 1305               	.L67:
 168:draw.c        ****         if (written != 0)
 1306               		.loc 1 168 0
 1307 06bc 9923      		tst r25
 1308 06be 01F4      		brne .+2
 1309 06c0 00C0      		rjmp .L39
 1310               	.LBB24:
 169:draw.c        ****             draw_hline (xstart, y, x - xinc, ps_r);
 1311               		.loc 1 169 0
 1312 06c2 E091 0000 		lds r30,functabP
 1313 06c6 F091 0000 		lds r31,functabP+1
 1314               	.LVL135:
 1315               	/* #APP */
 1316               	 ;  169 "draw.c" 1
 1317 06ca A591      		lpm r26, Z+
 1318 06cc B491      		lpm r27, Z
 1319               		
 1320               	 ;  0 "" 2
 1321               	.LVL136:
 1322               	/* #NOAPP */
 1323               	.LBE24:
 1324 06ce 4B2D      		mov r20,r11
 1325 06d0 4719      		sub r20,r7
 1326 06d2 292D      		mov r18,r9
 1327 06d4 6A2D      		mov r22,r10
 1328 06d6 00C0      		rjmp .L66
 1329               	.LVL137:
 1330               	.L44:
 1331               	.LBE22:
 1332               	.LBB25:
 184:draw.c        ****         numerator = deltay / 2;
 1333               		.loc 1 184 0
 1334 06d8 6701      		movw r12,r14
 1335 06da F7FE      		sbrs r15,7
 1336 06dc 00C0      		rjmp .L53
 1337               	.LVL138:
 1338 06de FFEF      		ldi r31,-1
 1339 06e0 CF1A      		sub r12,r31
 1340 06e2 DF0A      		sbc r13,r31
 1341               	.LVL139:
 1342               	.L53:
 1343 06e4 D594      		asr r13
 1344 06e6 C794      		ror r12
 1345               	.LVL140:
 189:draw.c        ****         if ((s_r & MODE_LINE_SKIP_LAST) == 0)
 1346               		.loc 1 189 0
 1347 06e8 07FD      		sbrc r16,7
 1348 06ea 00C0      		rjmp .L61
 190:draw.c        ****             numpixels++;
 1349               		.loc 1 190 0
 1350 06ec 8701      		movw r16,r14
 1351               	.LVL141:
 1352 06ee 0F5F      		subi r16,-1
 1353 06f0 1F4F      		sbci r17,-1
 1354               	.LVL142:
 1355 06f2 00C0      		rjmp .L54
 1356               	.LVL143:
 1357               	.L61:
 1358 06f4 8701      		movw r16,r14
 1359               	.LVL144:
 1360               	.L54:
 193:draw.c        ****         written = numpixels - 1;
 1361               		.loc 1 193 0
 1362 06f6 8FEF      		ldi r24,lo8(-1)
 1363 06f8 800F      		add r24,r16
 1364               	.LVL145:
 196:draw.c        ****         while (--numpixels >= 0)
 1365               		.loc 1 196 0
 1366 06fa 6A2D      		mov r22,r10
 1367               	.LVL146:
 1368               	.L55:
 196:draw.c        ****         while (--numpixels >= 0)
 1369               		.loc 1 196 0 is_stmt 0 discriminator 1
 1370 06fc 0150      		subi r16,1
 1371 06fe 1109      		sbc r17,__zero_reg__
 1372               	.LVL147:
 1373 0700 17FD      		sbrc r17,7
 1374 0702 00C0      		rjmp .L68
 199:draw.c        ****             numerator += numadd;
 1375               		.loc 1 199 0 is_stmt 1
 1376 0704 CC0E      		add r12,r28
 1377 0706 DD1E      		adc r13,r29
 1378               	.LVL148:
 1379 0708 6A2C      		mov r6,r10
 1380 070a 680C      		add r6,r8
 200:draw.c        ****             if (numerator >= denominator) // Check if numerator >= denominator
 1381               		.loc 1 200 0
 1382 070c CE14      		cp r12,r14
 1383 070e DF04      		cpc r13,r15
 1384 0710 04F0      		brlt .L56
 202:draw.c        ****                 numerator -= denominator; // Calculate the new numerator value
 1385               		.loc 1 202 0
 1386 0712 CE18      		sub r12,r14
 1387 0714 DF08      		sbc r13,r15
 1388               	.LVL149:
 1389               	.LBB26:
 203:draw.c        ****                 draw_vline (x, ystart, y, ps_r);
 1390               		.loc 1 203 0
 1391 0716 E091 0000 		lds r30,functabP
 1392 071a F091 0000 		lds r31,functabP+1
 1393 071e 3C96      		adiw r30,12
 1394               	.LVL150:
 1395               	/* #APP */
 1396               	 ;  203 "draw.c" 1
 1397 0720 A591      		lpm r26, Z+
 1398 0722 B491      		lpm r27, Z
 1399               		
 1400               	 ;  0 "" 2
 1401               	.LVL151:
 1402               	/* #NOAPP */
 1403               	.LBE26:
 1404 0724 292D      		mov r18,r9
 1405 0726 4A2D      		mov r20,r10
 1406 0728 8B2D      		mov r24,r11
 1407               	.LVL152:
 1408 072a FD01      		movw r30,r26
 1409 072c 0995      		icall
 1410               	.LVL153:
 205:draw.c        ****                 x += xinc;              // Change the x as appropriate
 1411               		.loc 1 205 0
 1412 072e B70C      		add r11,r7
 1413               	.LVL154:
 206:draw.c        ****                 y += yinc;
 1414               		.loc 1 206 0
 1415 0730 662D      		mov r22,r6
 1416               	.LVL155:
 209:draw.c        ****                 written = numpixels;    // Save the write position
 1417               		.loc 1 209 0
 1418 0732 802F      		mov r24,r16
 1419               	.LVL156:
 206:draw.c        ****                 y += yinc;
 1420               		.loc 1 206 0
 1421 0734 A62C      		mov r10,r6
 1422 0736 00C0      		rjmp .L55
 1423               	.LVL157:
 1424               	.L56:
 213:draw.c        ****                 y += yinc;
 1425               		.loc 1 213 0
 1426 0738 A62C      		mov r10,r6
 1427               	.LVL158:
 1428 073a 00C0      		rjmp .L55
 1429               	.LVL159:
 1430               	.L68:
 217:draw.c        ****         if (written != 0)
 1431               		.loc 1 217 0
 1432 073c 8823      		tst r24
 1433 073e 01F0      		breq .L39
 1434               	.LBB27:
 218:draw.c        ****             draw_vline (x, ystart, y - yinc, ps_r);
 1435               		.loc 1 218 0
 1436 0740 E091 0000 		lds r30,functabP
 1437 0744 F091 0000 		lds r31,functabP+1
 1438 0748 3C96      		adiw r30,12
 1439               	.LVL160:
 1440               	/* #APP */
 1441               	 ;  218 "draw.c" 1
 1442 074a A591      		lpm r26, Z+
 1443 074c B491      		lpm r27, Z
 1444               		
 1445               	 ;  0 "" 2
 1446               	.LVL161:
 1447               	/* #NOAPP */
 1448               	.LBE27:
 1449 074e 4A2D      		mov r20,r10
 1450 0750 4819      		sub r20,r8
 1451 0752 292D      		mov r18,r9
 1452 0754 8B2D      		mov r24,r11
 1453               	.LVL162:
 1454               	.L66:
 1455 0756 FD01      		movw r30,r26
 1456               	/* epilogue start */
 1457               	.LBE25:
 220:draw.c        **** }
 1458               		.loc 1 220 0
 1459 0758 DF91      		pop r29
 1460 075a CF91      		pop r28
 1461               	.LVL163:
 1462 075c 1F91      		pop r17
 1463 075e 0F91      		pop r16
 1464 0760 FF90      		pop r15
 1465 0762 EF90      		pop r14
 1466               	.LVL164:
 1467 0764 DF90      		pop r13
 1468 0766 CF90      		pop r12
 1469 0768 BF90      		pop r11
 1470               	.LVL165:
 1471 076a AF90      		pop r10
 1472               	.LVL166:
 1473 076c 9F90      		pop r9
 1474               	.LVL167:
 1475 076e 8F90      		pop r8
 1476               	.LVL168:
 1477 0770 7F90      		pop r7
 1478               	.LVL169:
 1479 0772 6F90      		pop r6
 1480               	.LBB28:
 218:draw.c        ****             draw_vline (x, ystart, y - yinc, ps_r);
 1481               		.loc 1 218 0
 1482 0774 0994      		ijmp
 1483               	.LVL170:
 1484               	.L39:
 1485               	/* epilogue start */
 1486               	.LBE28:
 220:draw.c        **** }
 1487               		.loc 1 220 0
 1488 0776 DF91      		pop r29
 1489 0778 CF91      		pop r28
 1490               	.LVL171:
 1491 077a 1F91      		pop r17
 1492 077c 0F91      		pop r16
 1493 077e FF90      		pop r15
 1494 0780 EF90      		pop r14
 1495               	.LVL172:
 1496 0782 DF90      		pop r13
 1497 0784 CF90      		pop r12
 1498 0786 BF90      		pop r11
 1499               	.LVL173:
 1500 0788 AF90      		pop r10
 1501               	.LVL174:
 1502 078a 9F90      		pop r9
 1503               	.LVL175:
 1504 078c 8F90      		pop r8
 1505               	.LVL176:
 1506 078e 7F90      		pop r7
 1507               	.LVL177:
 1508 0790 6F90      		pop r6
 1509 0792 0895      		ret
 1510               		.cfi_endproc
 1511               	.LFE12:
 1513               	.global	draw_lines
 1515               	draw_lines:
 1516               	.LFB13:
 230:draw.c        **** {
 1517               		.loc 1 230 0
 1518               		.cfi_startproc
 1519               	.LVL178:
 1520 0794 AF92      		push r10
 1521               	.LCFI34:
 1522               		.cfi_def_cfa_offset 3
 1523               		.cfi_offset 10, -2
 1524 0796 BF92      		push r11
 1525               	.LCFI35:
 1526               		.cfi_def_cfa_offset 4
 1527               		.cfi_offset 11, -3
 1528 0798 DF92      		push r13
 1529               	.LCFI36:
 1530               		.cfi_def_cfa_offset 5
 1531               		.cfi_offset 13, -4
 1532 079a EF92      		push r14
 1533               	.LCFI37:
 1534               		.cfi_def_cfa_offset 6
 1535               		.cfi_offset 14, -5
 1536 079c FF92      		push r15
 1537               	.LCFI38:
 1538               		.cfi_def_cfa_offset 7
 1539               		.cfi_offset 15, -6
 1540 079e 0F93      		push r16
 1541               	.LCFI39:
 1542               		.cfi_def_cfa_offset 8
 1543               		.cfi_offset 16, -7
 1544 07a0 1F93      		push r17
 1545               	.LCFI40:
 1546               		.cfi_def_cfa_offset 9
 1547               		.cfi_offset 17, -8
 1548 07a2 CF93      		push r28
 1549               	.LCFI41:
 1550               		.cfi_def_cfa_offset 10
 1551               		.cfi_offset 28, -9
 1552 07a4 DF93      		push r29
 1553               	.LCFI42:
 1554               		.cfi_def_cfa_offset 11
 1555               		.cfi_offset 29, -10
 1556 07a6 1F92      		push __zero_reg__
 1557               	.LCFI43:
 1558               		.cfi_def_cfa_offset 12
 1559 07a8 CDB7      		in r28,__SP_L__
 1560 07aa DEB7      		in r29,__SP_H__
 1561               	.LCFI44:
 1562               		.cfi_def_cfa_register 28
 1563               	/* prologue: function */
 1564               	/* frame size = 1 */
 1565               	/* stack size = 10 */
 1566               	.L__stack_usage = 10
 1567 07ac D62E      		mov r13,r22
 1568 07ae 642F      		mov r22,r20
 1569               	.LVL179:
 1570 07b0 5901      		movw r10,r18
 232:draw.c        ****     s_r |= MODE_LINE_SKIP_LAST;
 1571               		.loc 1 232 0
 1572 07b2 8068      		ori r24,lo8(-128)
 1573               	.LVL180:
 1574 07b4 F82E      		mov r15,r24
 1575               	.LVL181:
 1576               	.L74:
 1577               	.LBB29:
 239:draw.c        ****         if (data != NULL)
 1578               		.loc 1 239 0
 1579 07b6 A114      		cp r10,__zero_reg__
 1580 07b8 B104      		cpc r11,__zero_reg__
 1581 07ba 01F0      		breq .L70
 1582               	.LVL182:
 241:draw.c        ****             x1 = *data++;
 1583               		.loc 1 241 0
 1584 07bc F501      		movw r30,r10
 1585 07be E080      		ld r14,Z
 1586               	.LVL183:
 242:draw.c        ****             y1 = *data++;
 1587               		.loc 1 242 0
 1588 07c0 1181      		ldd r17,Z+1
 1589               	.LVL184:
 1590 07c2 C501      		movw r24,r10
 1591 07c4 0296      		adiw r24,2
 1592               	.LVL185:
 1593 07c6 5C01      		movw r10,r24
 1594 07c8 00C0      		rjmp .L71
 1595               	.LVL186:
 1596               	.L70:
 246:draw.c        ****             x1 = serial_getc (); // Save x
 1597               		.loc 1 246 0
 1598 07ca 6983      		std Y+1,r22
 1599 07cc 0E94 0000 		call serial_getc
 1600               	.LVL187:
 1601 07d0 E82E      		mov r14,r24
 1602               	.LVL188:
 247:draw.c        ****             y1 = serial_getc (); // Save y
 1603               		.loc 1 247 0
 1604 07d2 0E94 0000 		call serial_getc
 1605               	.LVL189:
 1606 07d6 182F      		mov r17,r24
 1607               	.LVL190:
 1608 07d8 6981      		ldd r22,Y+1
 1609               	.L71:
 250:draw.c        ****         if ((y1 & 0x80) != 0)
 1610               		.loc 1 250 0
 1611 07da 17FF      		sbrs r17,7
 1612 07dc 00C0      		rjmp .L72
 252:draw.c        ****             y1 &= ~0x80;
 1613               		.loc 1 252 0
 1614 07de 1F77      		andi r17,lo8(127)
 1615               	.LVL191:
 254:draw.c        ****             s_r &= ~MODE_LINE_SKIP_LAST;
 1616               		.loc 1 254 0
 1617 07e0 9F2D      		mov r25,r15
 1618 07e2 9F77      		andi r25,lo8(127)
 1619 07e4 F92E      		mov r15,r25
 1620               	.LVL192:
 1621               	.L72:
 258:draw.c        ****         draw_line (x, y, x1, y1, s_r);
 1622               		.loc 1 258 0
 1623 07e6 0F2D      		mov r16,r15
 1624 07e8 212F      		mov r18,r17
 1625 07ea 4E2D      		mov r20,r14
 1626 07ec 8D2D      		mov r24,r13
 1627 07ee 0E94 0000 		call draw_line
 1628               	.LVL193:
 1629               	.LBE29:
 262:draw.c        ****     while ((s_r & MODE_LINE_SKIP_LAST) != 0);
 1630               		.loc 1 262 0
 1631 07f2 F7FE      		sbrs r15,7
 1632 07f4 00C0      		rjmp .L69
 1633               	.LBB30:
 260:draw.c        ****         y = y1;
 1634               		.loc 1 260 0
 1635 07f6 612F      		mov r22,r17
 259:draw.c        ****         x = x1;
 1636               		.loc 1 259 0
 1637 07f8 DE2C      		mov r13,r14
 1638 07fa 00C0      		rjmp .L74
 1639               	.L69:
 1640               	/* epilogue start */
 1641               	.LBE30:
 263:draw.c        **** }
 1642               		.loc 1 263 0
 1643 07fc 0F90      		pop __tmp_reg__
 1644 07fe DF91      		pop r29
 1645 0800 CF91      		pop r28
 1646 0802 1F91      		pop r17
 1647               	.LVL194:
 1648 0804 0F91      		pop r16
 1649 0806 FF90      		pop r15
 1650               	.LVL195:
 1651 0808 EF90      		pop r14
 1652               	.LVL196:
 1653 080a DF90      		pop r13
 1654 080c BF90      		pop r11
 1655 080e AF90      		pop r10
 1656               	.LVL197:
 1657 0810 0895      		ret
 1658               		.cfi_endproc
 1659               	.LFE13:
 1661               	.global	draw_pixel
 1663               	draw_pixel:
 1664               	.LFB14:
 273:draw.c        **** {
 1665               		.loc 1 273 0
 1666               		.cfi_startproc
 1667               	.LVL198:
 1668               	/* prologue: function */
 1669               	/* frame size = 0 */
 1670               	/* stack size = 0 */
 1671               	.L__stack_usage = 0
 274:draw.c        ****     if (x_valid(x) && y_valid(y))
 1672               		.loc 1 274 0
 1673 0812 9091 0000 		lds r25,x_dim
 1674 0816 8917      		cp r24,r25
 1675 0818 00F4      		brsh .L75
 274:draw.c        ****     if (x_valid(x) && y_valid(y))
 1676               		.loc 1 274 0 is_stmt 0 discriminator 1
 1677 081a 262F      		mov r18,r22
 1678 081c 30E0      		ldi r19,0
 1679 081e E091 0000 		lds r30,y_dim
 1680 0822 F0E0      		ldi r31,0
 1681 0824 F195      		neg r31
 1682 0826 E195      		neg r30
 1683 0828 F109      		sbc r31,__zero_reg__
 1684 082a 2E23      		and r18,r30
 1685 082c 3F23      		and r19,r31
 1686 082e 232B      		or r18,r19
 1687 0830 01F4      		brne .L75
 1688               	.LVL199:
 1689               	.LBB31:
 278:draw.c        ****         lcd_set_pixel (x, y, s_r);
 1690               		.loc 1 278 0 is_stmt 1
 1691 0832 E091 0000 		lds r30,functabP
 1692 0836 F091 0000 		lds r31,functabP+1
 1693 083a 3896      		adiw r30,8
 1694               	.LVL200:
 1695               	/* #APP */
 1696               	 ;  278 "draw.c" 1
 1697 083c 2591      		lpm r18, Z+
 1698 083e 3491      		lpm r19, Z
 1699               		
 1700               	 ;  0 "" 2
 1701               	.LVL201:
 1702               	/* #NOAPP */
 1703               	.LBE31:
 277:draw.c        ****         s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~MODE_NORMAL_MASK);
 1704               		.loc 1 277 0
 1705 0840 942F      		mov r25,r20
 1706 0842 9095      		com r25
 1707 0844 5091 0000 		lds r21,prefs+4
 1708 0848 9527      		eor r25,r21
 1709 084a 90FB      		bst r25,0
 1710 084c 40F9      		bld r20,0
 1711               	.LVL202:
 278:draw.c        ****         lcd_set_pixel (x, y, s_r);
 1712               		.loc 1 278 0
 1713 084e F901      		movw r30,r18
 1714 0850 0994      		ijmp
 1715               	.LVL203:
 1716               	.L75:
 1717 0852 0895      		ret
 1718               		.cfi_endproc
 1719               	.LFE14:
 1721               	.global	draw_circle
 1723               	draw_circle:
 1724               	.LFB18:
 478:draw.c        **** 
 479:draw.c        **** // Draws (s_r = 1) or erases (s_r = 0) a filled circle at x, y with radius r,
 480:draw.c        **** // using midpoint circle algorithm. For efficiency in drawing then the
 481:draw.c        **** // algorith draws staight line vertical and horizontal segments which degrade
 482:draw.c        **** // to a single pixel in the worst case.
 483:draw.c        **** //
 484:draw.c        **** // Noted that the Sparkfun circle algorithm is a little easier however the
 485:draw.c        **** // circle quality is dubious at a small radius so we keep the existing one
 486:draw.c        **** // used by Jennifer Holt.
 487:draw.c        **** void
 488:draw.c        **** draw_circle (uint8_t xin, uint8_t yin, uint8_t rin, uint8_t s_r)
 489:draw.c        **** {
 1725               		.loc 1 489 0
 1726               		.cfi_startproc
 1727               	.LVL204:
 1728 0854 EF92      		push r14
 1729               	.LCFI45:
 1730               		.cfi_def_cfa_offset 3
 1731               		.cfi_offset 14, -2
 1732 0856 0F93      		push r16
 1733               	.LCFI46:
 1734               		.cfi_def_cfa_offset 4
 1735               		.cfi_offset 16, -3
 1736               	/* prologue: function */
 1737               	/* frame size = 0 */
 1738               	/* stack size = 2 */
 1739               	.L__stack_usage = 2
 490:draw.c        ****     // Invoke the _draw_circle function
 491:draw.c        ****     _draw_circle (xin, yin, 0, 0, rin, s_r);
 1740               		.loc 1 491 0
 1741 0858 E22E      		mov r14,r18
 1742 085a 042F      		mov r16,r20
 1743 085c 20E0      		ldi r18,0
 1744               	.LVL205:
 1745 085e 40E0      		ldi r20,0
 1746               	.LVL206:
 1747 0860 0E94 0000 		call _draw_circle
 1748               	.LVL207:
 1749               	/* epilogue start */
 492:draw.c        **** }
 1750               		.loc 1 492 0
 1751 0864 0F91      		pop r16
 1752               	.LVL208:
 1753 0866 EF90      		pop r14
 1754               	.LVL209:
 1755 0868 0895      		ret
 1756               		.cfi_endproc
 1757               	.LFE18:
 1759               	.global	draw_rbox
 1761               	draw_rbox:
 1762               	.LFB19:
 493:draw.c        **** 
 494:draw.c        **** /**
 495:draw.c        ****  * Draws a rounded corner box. The box is described by a diagonal line from x, y1 to x2, y2
 496:draw.c        ****  *
 497:draw.c        ****  * @param x1 The upper left x-coordinate.
 498:draw.c        ****  * @param y1 The upper left y-coordingate.
 499:draw.c        ****  * @param x2 The lower right x-coordinate.
 500:draw.c        ****  * @param y2 The lower right y-coordinate
 501:draw.c        ****  * @param radius The radius of the corner.
 502:draw.c        ****  * @param s_r The mode to draw the line
 503:draw.c        ****  */
 504:draw.c        **** void
 505:draw.c        **** draw_rbox (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t radius, uint8_t s_r)
 506:draw.c        **** {
 1763               		.loc 1 506 0
 1764               		.cfi_startproc
 1765               	.LVL210:
 1766 086a EF92      		push r14
 1767               	.LCFI47:
 1768               		.cfi_def_cfa_offset 3
 1769               		.cfi_offset 14, -2
 1770 086c 0F93      		push r16
 1771               	.LCFI48:
 1772               		.cfi_def_cfa_offset 4
 1773               		.cfi_offset 16, -3
 1774               	/* prologue: function */
 1775               	/* frame size = 0 */
 1776               	/* stack size = 2 */
 1777               	.L__stack_usage = 2
 1778 086e 902F      		mov r25,r16
 507:draw.c        ****     uint8_t radius2 = radius << 1;
 1779               		.loc 1 507 0
 1780 0870 302F      		mov r19,r16
 1781 0872 330F      		lsl r19
 1782               	.LVL211:
 508:draw.c        ****     uint8_t xdiff;
 509:draw.c        ****     uint8_t ydiff;
 510:draw.c        ****     uint8_t diff;
 511:draw.c        **** 
 512:draw.c        ****     // Sort the x and y coordinates into ascending order.
 513:draw.c        ****     if (x1 > x2)
 1783               		.loc 1 513 0
 1784 0874 4817      		cp r20,r24
 1785 0876 00F4      		brsh .L79
 514:draw.c        ****         swap_bytes (x1, x2);
 1786               		.loc 1 514 0
 1787 0878 8427      		eor r24,r20
 1788               	.LVL212:
 1789 087a 4827      		eor r20,r24
 1790               	.LVL213:
 1791 087c 8427      		eor r24,r20
 1792               	.LVL214:
 1793               	.L79:
 515:draw.c        ****     if (y1 > y2)
 1794               		.loc 1 515 0
 1795 087e 2617      		cp r18,r22
 1796 0880 00F4      		brsh .L80
 516:draw.c        ****         swap_bytes (y1, y2);
 1797               		.loc 1 516 0
 1798 0882 6227      		eor r22,r18
 1799               	.LVL215:
 1800 0884 2627      		eor r18,r22
 1801               	.LVL216:
 1802 0886 6227      		eor r22,r18
 1803               	.LVL217:
 1804               	.L80:
 517:draw.c        **** 
 518:draw.c        ****     // Determine the maximum radius we can deal with.
 519:draw.c        ****     xdiff = x2 - x1;
 1805               		.loc 1 519 0
 1806 0888 481B      		sub r20,r24
 1807               	.LVL218:
 520:draw.c        ****     ydiff = y2 - y1;
 1808               		.loc 1 520 0
 1809 088a 261B      		sub r18,r22
 1810               	.LVL219:
 1811 088c 522F      		mov r21,r18
 1812 088e 4217      		cp r20,r18
 1813 0890 00F4      		brsh .L81
 1814 0892 542F      		mov r21,r20
 1815               	.L81:
 1816               	.LVL220:
 521:draw.c        ****     diff = xdiff;
 522:draw.c        ****     if (ydiff < xdiff)
 523:draw.c        ****         diff = ydiff;
 524:draw.c        **** 
 525:draw.c        ****     // Radius is larger than the box, reduce the radius to fit the box.
 526:draw.c        ****     if (radius2 > diff)
 1817               		.loc 1 526 0
 1818 0894 5317      		cp r21,r19
 1819 0896 00F4      		brsh .L82
 527:draw.c        ****     {
 528:draw.c        ****         radius = diff >> 1;
 1820               		.loc 1 528 0
 1821 0898 952F      		mov r25,r21
 1822 089a 9695      		lsr r25
 1823               	.LVL221:
 1824 089c 352F      		mov r19,r21
 1825               	.LVL222:
 1826               	.L82:
 529:draw.c        ****         radius2 = diff;
 530:draw.c        ****     }
 531:draw.c        **** 
 532:draw.c        ****     // Invoke the _draw_circle function
 533:draw.c        ****     _draw_circle (x1 + radius, y1 + radius,
 1827               		.loc 1 533 0
 1828 089e 231B      		sub r18,r19
 1829               	.LVL223:
 1830 08a0 431B      		sub r20,r19
 1831               	.LVL224:
 1832 08a2 690F      		add r22,r25
 1833               	.LVL225:
 1834 08a4 092F      		mov r16,r25
 1835 08a6 890F      		add r24,r25
 1836               	.LVL226:
 1837 08a8 0E94 0000 		call _draw_circle
 1838               	.LVL227:
 1839               	/* epilogue start */
 534:draw.c        ****                   xdiff - radius2, ydiff - radius2,
 535:draw.c        ****                   radius, s_r);
 536:draw.c        **** }
 1840               		.loc 1 536 0
 1841 08ac 0F91      		pop r16
 1842               	.LVL228:
 1843 08ae EF90      		pop r14
 1844               	.LVL229:
 1845 08b0 0895      		ret
 1846               		.cfi_endproc
 1847               	.LFE19:
 1849               	.global	draw_polygon
 1851               	draw_polygon:
 1852               	.LFB21:
 537:draw.c        **** 
 538:draw.c        **** ///
 539:draw.c        **** /// Fill a convex polygons defined in a clockwise direction. The algorithm
 540:draw.c        **** /// will cope with concave shapes in the y-direction but does not cope with
 541:draw.c        **** /// all concave shapes in the x direction.
 542:draw.c        **** ///
 543:draw.c        **** /// The algorithm uses besenham's line drawing algorithm and creates vertical
 544:draw.c        **** /// scal lines between the top and bottom of the polygone. Provided that the
 545:draw.c        **** /// vertical scan line is contained within the vertical scan line then the
 546:draw.c        **** /// shape will fill correctly. What this means is:
 547:draw.c        **** ///
 548:draw.c        **** /// @    +--+  +--+
 549:draw.c        **** /// @    |  |  |  |
 550:draw.c        **** /// @ +--+  +--+  +--+
 551:draw.c        **** /// @ |              |    OK all vertical scan lines connected.
 552:draw.c        **** /// @ +--+  +--+  +--+
 553:draw.c        **** /// @    |  |  |  |
 554:draw.c        **** /// @    +--+  +--+
 555:draw.c        **** /// @
 556:draw.c        **** /// @ +----------+
 557:draw.c        **** /// @ |  +-------+
 558:draw.c        **** /// @ |  |
 559:draw.c        **** /// @ |  +-----+         OK because of clockwise scan.
 560:draw.c        **** /// @ |  +-----+
 561:draw.c        **** /// @ |  |
 562:draw.c        **** /// @ |  +-------+
 563:draw.c        **** /// @ +----------+
 564:draw.c        **** /// @
 565:draw.c        **** /// @ $---------+
 566:draw.c        **** /// @ +-------@ |        FAILS starting at '$' because cannot resolve convex.
 567:draw.c        **** /// @         | |        OK starting at '@' because can resolve convex
 568:draw.c        **** /// @ +-------+ |
 569:draw.c        **** /// @ +---------+
 570:draw.c        **** ///
 571:draw.c        **** /// The algorithm works by determining the direction of the line and operates
 572:draw.c        **** /// in clockwise direction. A line is drawn between each successive point and
 573:draw.c        **** /// the y-value is saved in the buffer[x] if it is already empty (0xff). If
 574:draw.c        **** /// the buffer[x] has a value then a vertical line is rendered between the
 575:draw.c        **** /// x,y position of the current line and the x,buffer[x] stored position.
 576:draw.c        **** ///
 577:draw.c        **** /// The libne drawing renders the whole line EXCEPT the last point of the
 578:draw.c        **** /// line to ensiure that points are not duplicated. Special handling is
 579:draw.c        **** /// required at the points where the line changes direction from forward
 580:draw.c        **** /// moving to backward moving. At forward/backward transition (because only 1
 581:draw.c        **** /// point is processed) then an extra plot is introduced this means that if
 582:draw.c        **** /// the buffer[x] is empty the y-position is saved or when set to a valid
 583:draw.c        **** /// y-value then a line is drawn.
 584:draw.c        **** ///
 585:draw.c        **** /// A line moves in the forward direction if (x>x1) or ((x==x1) & (y<y1)). A
 586:draw.c        **** /// line moves in a backward direction if (x<x1) or ((x==x1) & (y>y1)).
 587:draw.c        **** ///
 588:draw.c        **** /// At the end of the polygon fill we check to ensure that there is not a
 589:draw.c        **** /// residual draw in the buffer which has not been consumed, if there is then
 590:draw.c        **** /// we need a pixel at this location.
 591:draw.c        **** ///
 592:draw.c        **** /// @param [in] s_r The fill colour
 593:draw.c        **** /// @param [in] x The first and last x-coordinate
 594:draw.c        **** /// @param [in] y The first and last y-coordinate
 595:draw.c        **** ///
 596:draw.c        **** static void
 597:draw.c        **** _fill_polygon (uint8_t s_r, uint8_t x, uint8_t y)
 598:draw.c        **** {
 599:draw.c        ****     // Cached y coordinates.
 600:draw.c        ****     uint8_t write_ystart;               // The writing start y-coordinate
 601:draw.c        ****     uint8_t write_yend;                 // The writing end y-coordinate
 602:draw.c        **** 
 603:draw.c        ****     // Working variables.
 604:draw.c        ****     uint8_t last_coord = 0;             // The last coordinate.
 605:draw.c        ****     uint8_t xfirst, yfirst;             // Working x,y coordinates
 606:draw.c        ****     int8_t direction = -1;              // Current Direction
 607:draw.c        ****     int8_t direction_changed = 0;       // Direction has changed.
 608:draw.c        **** 
 609:draw.c        ****     // Initialise our line buffer
 610:draw.c        ****     write_ystart = y;
 611:draw.c        ****     write_yend = y;
 612:draw.c        ****     if (y_valid(y))
 613:draw.c        ****         draw_buffer[y] = 0xff;
 614:draw.c        ****     xfirst = x;
 615:draw.c        ****     yfirst = y;
 616:draw.c        **** 
 617:draw.c        ****     do
 618:draw.c        ****     {
 619:draw.c        ****         uint8_t x1, y1;                 // Working x,y coordinates
 620:draw.c        ****         int16_t deltax;                 // Difference in x;
 621:draw.c        ****         int16_t deltay;                 // Difference in y;
 622:draw.c        ****         int8_t xinc;                    // X-coordinate increment.
 623:draw.c        ****         int8_t yinc;                    // X-coordinate increment.
 624:draw.c        **** 
 625:draw.c        ****         // Get the end marker out of the last coordinate and normalise
 626:draw.c        ****         if (last_coord == 0)
 627:draw.c        ****         {
 628:draw.c        ****             // Read data from serial.
 629:draw.c        ****             x1 = serial_getc();
 630:draw.c        ****             y1 = serial_getc();
 631:draw.c        **** 
 632:draw.c        ****             // Handle the end of the polygon and strip out the signalling.
 633:draw.c        ****             last_coord = y1 & 0x80;
 634:draw.c        ****             y1 &= ~0x80;
 635:draw.c        ****         }
 636:draw.c        ****         else
 637:draw.c        ****         {
 638:draw.c        ****             // We have processed the last coordinate. Draw a line from the
 639:draw.c        ****             // last coordinate to the first coordinate.
 640:draw.c        ****             x1 = xfirst;
 641:draw.c        ****             y1 = yfirst;
 642:draw.c        ****             yfirst |= 0x80;             // mark as end the loop
 643:draw.c        ****         }
 644:draw.c        **** 
 645:draw.c        ****         // Horizontal lines cause a problem for concave shapes when filling
 646:draw.c        ****         // with XOR as we have to be very careful that we do not over-draw
 647:draw.c        ****         // any line as this causes an anomaly in the fill. Process the line
 648:draw.c        ****         // segment immediately and effectivelly reduce the line to a point.
 649:draw.c        ****         // We skip the direction processing and will effectively carry the
 650:draw.c        ****         // direction change to any next line segment.
 651:draw.c        ****         //
 652:draw.c        ****         // Ignore all horizontal lines as the x coordinates will be repeated
 653:draw.c        ****         // on another coordinate. Sort out the y values.
 654:draw.c        ****         if (y == y1)
 655:draw.c        ****         {
 656:draw.c        ****             uint8_t xstart;
 657:draw.c        ****             uint8_t xend;
 658:draw.c        ****             uint8_t buffer = draw_buffer[y];
 659:draw.c        **** 
 660:draw.c        ****             // Throw out a coincidental point.
 661:draw.c        ****             if (x == x1)
 662:draw.c        ****                 continue;               // This is the same point, discard.
 663:draw.c        **** 
 664:draw.c        ****             // Determine the direction of the line from x
 665:draw.c        ****             if (x > x1)
 666:draw.c        ****             {
 667:draw.c        ****                 // Going left, this is backwards i.e. (x1,y) <--- (x,y)
 668:draw.c        **** 
 669:draw.c        ****                 // If the direction is reverse then do not do anything as the
 670:draw.c        ****                 // next line segment will process the start of line.
 671:draw.c        ****                 if (direction <= 0)
 672:draw.c        ****                     goto skip_line;
 673:draw.c        **** 
 674:draw.c        ****                 // Otherwise draw the line. If the draw_buffer is defined
 675:draw.c        ****                 // then advance the draw buffer position to the end point.
 676:draw.c        ****                 if ((buffer != 0xff) && (buffer >= x))
 677:draw.c        ****                 {
 678:draw.c        ****                     xstart = buffer;
 679:draw.c        ****                     draw_buffer[y] = 0xff /* x1*/;
 680:draw.c        ****                 }
 681:draw.c        ****                 else
 682:draw.c        ****                     xstart = x;
 683:draw.c        ****                 xend = x1 + 1;
 684:draw.c        ****             }
 685:draw.c        ****             else
 686:draw.c        ****             {
 687:draw.c        ****                 // Going right, this is forwards. i.e. (x,y) ---> (x1,y)
 688:draw.c        **** 
 689:draw.c        ****                 // If the direction is currently forward then do not do
 690:draw.c        ****                 // anything as the next line segment will process the line.
 691:draw.c        ****                 if (direction != 0)
 692:draw.c        ****                     goto skip_line;
 693:draw.c        **** 
 694:draw.c        ****                 // Otherwise draw the line. If the draw_buffer is defined
 695:draw.c        ****                 // then advance the draw buffer position to the end point.
 696:draw.c        ****                 if ((buffer != 0xff) && (buffer <= x))
 697:draw.c        ****                 {
 698:draw.c        ****                     xstart = buffer;
 699:draw.c        ****                     draw_buffer[y] = 0xff /* x1*/;
 700:draw.c        ****                 }
 701:draw.c        ****                 else
 702:draw.c        ****                     xstart = x;
 703:draw.c        ****                 xend = x1 - 1;
 704:draw.c        ****             }
 705:draw.c        ****             draw_hline (xstart, y, xend, s_r);
 706:draw.c        **** 
 707:draw.c        ****             // Advance the point.
 708:draw.c        **** skip_line:  x = x1;                     // Move the x to the next point.
 709:draw.c        ****             continue;                   // Skip any drawing, not processed.
 710:draw.c        ****         }
 711:draw.c        ****         else if (y1 > y)                // The y-values are increasing
 712:draw.c        ****         {
 713:draw.c        ****             yinc = 1;
 714:draw.c        ****             deltay = y1 - y;            // The difference between the y's
 715:draw.c        ****             // If y is increasing downwards then grow the buffer.
 716:draw.c        ****             while ((y1 > write_yend) && (write_yend < y_dim - 1))
 717:draw.c        ****                 draw_buffer [++write_yend] = 0xff;
 718:draw.c        **** 
 719:draw.c        ****             // Going down, this is forwards
 720:draw.c        ****             if (direction >= 0)
 721:draw.c        ****                 direction_changed = direction ^ 1;
 722:draw.c        ****             direction = 1;
 723:draw.c        ****         }
 724:draw.c        ****         else                            // The y-values are decreasing
 725:draw.c        ****         {
 726:draw.c        ****             yinc = -1;
 727:draw.c        ****             deltay = y - y1;
 728:draw.c        ****             // If the y is decreasing upwards then grow the buffer
 729:draw.c        ****             while ((y1 < write_ystart) && (write_ystart > 0))
 730:draw.c        ****                 draw_buffer [--write_ystart] = 0xff;
 731:draw.c        **** 
 732:draw.c        ****             // Going up, this is backwards
 733:draw.c        ****             if (direction >= 0)
 734:draw.c        ****                 direction_changed = direction ^ 0;
 735:draw.c        ****             direction = 0;
 736:draw.c        ****         }
 737:draw.c        **** 
 738:draw.c        ****         // Sort out the x values
 739:draw.c        ****         if (x1 >= x)                       // The x-values are increasing
 740:draw.c        ****         {
 741:draw.c        ****             if (x1 == x)
 742:draw.c        ****                 xinc = 0;
 743:draw.c        ****             else
 744:draw.c        ****                 xinc = 1;
 745:draw.c        ****             deltax = x1 - x;
 746:draw.c        ****         }
 747:draw.c        ****         else                                // The y-values are decreasing
 748:draw.c        ****         {
 749:draw.c        ****             xinc = -1;
 750:draw.c        ****             deltax = x - x1;
 751:draw.c        ****         }
 752:draw.c        **** 
 753:draw.c        ****         /* If the direction has changed then process the last pixel we did
 754:draw.c        ****          * not plot. We need some special handling because we only visit this
 755:draw.c        ****          * pixel once. If draw_the buffer[y] is not initialised then write
 756:draw.c        ****          * our current y value, this is the end of the last line. if the
 757:draw.c        ****          * buffer[y] is valid then we need to draw a line to the x position
 758:draw.c        ****          * in the buffer. */
 759:draw.c        ****         if (direction_changed)
 760:draw.c        ****         {
 761:draw.c        ****             uint8_t buffer = draw_buffer[y];
 762:draw.c        **** 
 763:draw.c        ****             // Handle the special case of internal and corners with care, we
 764:draw.c        ****             // do not want to promote drawing for an internal corner.
 765:draw.c        ****             // On internal corners then do not process.
 766:draw.c        **** 
 767:draw.c        ****             // Going forwards
 768:draw.c        ****             if (direction == 1)
 769:draw.c        ****             {
 770:draw.c        ****                 if (buffer == 0xff)
 771:draw.c        ****                     draw_buffer[y] = x;
 772:draw.c        ****                 else if (buffer > x)
 773:draw.c        ****                 {
 774:draw.c        ****                     draw_hline (x+1, y, buffer, s_r);
 775:draw.c        ****                     draw_buffer[y] = 0xff;
 776:draw.c        ****                 }
 777:draw.c        ****             }
 778:draw.c        ****             // Going backwards
 779:draw.c        ****             else
 780:draw.c        ****             {
 781:draw.c        ****                 if (buffer == 0xff)
 782:draw.c        ****                     draw_buffer[y] = x;
 783:draw.c        ****                 else if (buffer < x)
 784:draw.c        ****                 {
 785:draw.c        ****                     draw_hline (x-1, y, buffer, s_r);
 786:draw.c        ****                     draw_buffer[y] = 0xff;
 787:draw.c        ****                 }
 788:draw.c        ****             }
 789:draw.c        ****         }
 790:draw.c        **** 
 791:draw.c        ****         // There is at least one x-value for every y-value. Handle the incrementing
 792:draw.c        ****         // and decremening separately.
 793:draw.c        ****         if (deltax >= deltay)
 794:draw.c        ****         {
 795:draw.c        ****             int16_t denominator;             // Denominator
 796:draw.c        ****             int16_t numerator;               // Numerator
 797:draw.c        ****             int16_t numadd;                  // Numerator to add.
 798:draw.c        ****             int16_t numpixels;               // Number of pixels to write.
 799:draw.c        ****             uint8_t xstart;             // X start point
 800:draw.c        **** 
 801:draw.c        ****             // Calculate the Bresenham parameters
 802:draw.c        ****             denominator = deltax;           // The denominator
 803:draw.c        ****             numerator = deltax / 2;         // The numerator
 804:draw.c        ****             numadd = deltay;                // Increment of the numerator
 805:draw.c        ****             numpixels = deltax;             // There are more x-values than y-values -1
 806:draw.c        ****             xstart = x;                 // Save the start point
 807:draw.c        **** 
 808:draw.c        ****             // Write all of the pixels EXCLUDING the last pixel of the line.
 809:draw.c        ****             while (--numpixels >= 0)
 810:draw.c        ****             {
 811:draw.c        ****                 numerator += numadd;          // Increase the numerator by the top of the fraction
 812:draw.c        ****                 if (numerator >= denominator) // Check if numerator >= denominator
 813:draw.c        ****                 {
 814:draw.c        ****                     uint8_t buffer;
 815:draw.c        **** 
 816:draw.c        ****                     // If we are going backwards with a positive increment or
 817:draw.c        ****                     // going forwards with a negative increment then save the
 818:draw.c        ****                     // start x position for plotting.
 819:draw.c        ****                     if (((direction == 1) && (xinc > 0)) ||
 820:draw.c        ****                         ((direction == 0) && (xinc < 0)))
 821:draw.c        ****                         xstart = x;
 822:draw.c        **** 
 823:draw.c        ****                     // This is the only position where y changes. Flush out
 824:draw.c        ****                     // the last y change before we increment it.
 825:draw.c        ****                     buffer = draw_buffer[y];
 826:draw.c        ****                     if (buffer != 0xff)
 827:draw.c        ****                     {
 828:draw.c        ****                         // Draw the horizontal line to fill the column and
 829:draw.c        ****                         // clear the y buffer
 830:draw.c        ****                         draw_hline (xstart, y, buffer, s_r);
 831:draw.c        ****                         xstart = 0xff;
 832:draw.c        ****                     }
 833:draw.c        ****                     draw_buffer[y] = xstart;
 834:draw.c        **** 
 835:draw.c        ****                     numerator -= denominator; // Calculate the new numerator value
 836:draw.c        ****                     y += yinc;                // Change the y as appropriate
 837:draw.c        ****                     x += xinc;                // Change the x for the nxt loop
 838:draw.c        ****                     xstart = x;               // Save the start position.
 839:draw.c        ****                 }
 840:draw.c        ****                 else
 841:draw.c        ****                 {
 842:draw.c        ****                     // Advance the x-coordinate
 843:draw.c        ****                     x += xinc;
 844:draw.c        ****                 }
 845:draw.c        ****             }
 846:draw.c        **** 
 847:draw.c        ****             // Catch any residue horizontal transition that has not been
 848:draw.c        ****             // recorded. This occurs for convex shapes where x is advanced
 849:draw.c        ****             // without y.
 850:draw.c        ****             if (xstart != x)
 851:draw.c        ****             {
 852:draw.c        ****                 uint8_t buffer = draw_buffer[y];
 853:draw.c        **** 
 854:draw.c        ****                 // This is the only position where y changes. Flush out
 855:draw.c        ****                 // the last y change before we increment it.
 856:draw.c        ****                 if (buffer != 0xff)
 857:draw.c        ****                 {
 858:draw.c        ****                     // Draw the vertical line to fill the column and
 859:draw.c        ****                     // clear the y buffer
 860:draw.c        ****                     draw_hline (xstart, y, buffer, s_r);
 861:draw.c        ****                     xstart = 0xff;
 862:draw.c        ****                 }
 863:draw.c        ****                 draw_buffer[y] = xstart;
 864:draw.c        ****             }
 865:draw.c        ****         }
 866:draw.c        ****         // There is at least one y-value for every x-value
 867:draw.c        ****         else
 868:draw.c        ****         {
 869:draw.c        ****             int16_t denominator;             // Denominator
 870:draw.c        ****             int16_t numerator;               // Numerator
 871:draw.c        ****             int16_t numadd;                  // Numerator to add.
 872:draw.c        ****             int16_t numpixels;               // Number of pixels to write.
 873:draw.c        **** 
 874:draw.c        ****             // Calculate the Bresenham parameters
 875:draw.c        ****             denominator = deltay;
 876:draw.c        ****             numerator = deltay / 2;
 877:draw.c        ****             numadd = deltax;
 878:draw.c        ****             numpixels = deltay;             // There are more y-values than x-values
 879:draw.c        **** 
 880:draw.c        ****             // Write all of the pixels EXCLUDING the last pixel.
 881:draw.c        ****             while (--numpixels >= 0)
 882:draw.c        ****             {
 883:draw.c        ****                 uint8_t buffer = draw_buffer[y];
 884:draw.c        **** 
 885:draw.c        ****                 // We are about to increment y and move to the next column.
 886:draw.c        ****                 // Either save the point or draw the point.
 887:draw.c        ****                 if (buffer != 0xff)
 888:draw.c        ****                 {
 889:draw.c        ****                     draw_hline (x, y, buffer, s_r);
 890:draw.c        ****                     buffer = 0xff;
 891:draw.c        ****                 }
 892:draw.c        ****                 else
 893:draw.c        ****                 {
 894:draw.c        ****                     buffer = x;
 895:draw.c        ****                 }
 896:draw.c        ****                 draw_buffer[y] = buffer;
 897:draw.c        **** 
 898:draw.c        ****                 // Increment x if necessary.
 899:draw.c        ****                 numerator += numadd;          // Increase the numerator by the top of the fraction
 900:draw.c        ****                 if (numerator >= denominator) // Check if numerator >= denominator
 901:draw.c        ****                 {
 902:draw.c        ****                     numerator -= denominator; // Calculate the new numerator value
 903:draw.c        ****                     x += xinc;                // Change the x as appropriate
 904:draw.c        ****                 }
 905:draw.c        **** 
 906:draw.c        ****                 // Increment y.
 907:draw.c        ****                 y += yinc;
 908:draw.c        ****             }
 909:draw.c        ****         }
 910:draw.c        **** 
 911:draw.c        ****         x = x1;
 912:draw.c        ****         y = y1;
 913:draw.c        ****     }
 914:draw.c        ****     while ((yfirst & 0x80) == 0);
 915:draw.c        ****     yfirst &= ~0x80;
 916:draw.c        **** 
 917:draw.c        ****     // Flush out any first pixel
 918:draw.c        ****     if (draw_buffer[yfirst] != 0xff)
 919:draw.c        ****     {
 920:draw.c        ****         draw_hline (xfirst, yfirst, draw_buffer[yfirst], s_r);
 921:draw.c        ****     }
 922:draw.c        **** }
 923:draw.c        **** 
 924:draw.c        **** //////////////////////////////////////////////////////////////////////////////
 925:draw.c        **** /// Draw Polygon.
 926:draw.c        **** ///
 927:draw.c        **** /// This draws a polygon which commences from x, y and draws a line to the next
 928:draw.c        **** /// point defined by the next (x, y) pair received from the data. The last
 929:draw.c        **** /// point of the line is defined by setting the last top bit of the <x>
 930:draw.c        **** /// coordinate to 0x80. The last coordinate is connected to the first
 931:draw.c        **** /// coordinate. This is essentially the same as draw multi-line which does not
 932:draw.c        **** /// close the polygon
 933:draw.c        **** ///
 934:draw.c        **** /// The line colour is defined by the s_r argument.
 935:draw.c        **** ///
 936:draw.c        **** /// @param [in] mode The drawing mode.
 937:draw.c        **** /// @param [in] data The list of x,y coordinates. The last y coordinate is
 938:draw.c        **** ///                  marked with the top bit set to 0x80.
 939:draw.c        **** void
 940:draw.c        **** draw_polygon (uint8_t s_r, uint8_t x, uint8_t y, uint8_t *data)
 941:draw.c        **** {
 1853               		.loc 1 941 0
 1854               		.cfi_startproc
 1855               	.LVL230:
 1856 08b2 2F92      		push r2
 1857               	.LCFI49:
 1858               		.cfi_def_cfa_offset 3
 1859               		.cfi_offset 2, -2
 1860 08b4 3F92      		push r3
 1861               	.LCFI50:
 1862               		.cfi_def_cfa_offset 4
 1863               		.cfi_offset 3, -3
 1864 08b6 4F92      		push r4
 1865               	.LCFI51:
 1866               		.cfi_def_cfa_offset 5
 1867               		.cfi_offset 4, -4
 1868 08b8 5F92      		push r5
 1869               	.LCFI52:
 1870               		.cfi_def_cfa_offset 6
 1871               		.cfi_offset 5, -5
 1872 08ba 6F92      		push r6
 1873               	.LCFI53:
 1874               		.cfi_def_cfa_offset 7
 1875               		.cfi_offset 6, -6
 1876 08bc 7F92      		push r7
 1877               	.LCFI54:
 1878               		.cfi_def_cfa_offset 8
 1879               		.cfi_offset 7, -7
 1880 08be 8F92      		push r8
 1881               	.LCFI55:
 1882               		.cfi_def_cfa_offset 9
 1883               		.cfi_offset 8, -8
 1884 08c0 9F92      		push r9
 1885               	.LCFI56:
 1886               		.cfi_def_cfa_offset 10
 1887               		.cfi_offset 9, -9
 1888 08c2 AF92      		push r10
 1889               	.LCFI57:
 1890               		.cfi_def_cfa_offset 11
 1891               		.cfi_offset 10, -10
 1892 08c4 BF92      		push r11
 1893               	.LCFI58:
 1894               		.cfi_def_cfa_offset 12
 1895               		.cfi_offset 11, -11
 1896 08c6 CF92      		push r12
 1897               	.LCFI59:
 1898               		.cfi_def_cfa_offset 13
 1899               		.cfi_offset 12, -12
 1900 08c8 DF92      		push r13
 1901               	.LCFI60:
 1902               		.cfi_def_cfa_offset 14
 1903               		.cfi_offset 13, -13
 1904 08ca EF92      		push r14
 1905               	.LCFI61:
 1906               		.cfi_def_cfa_offset 15
 1907               		.cfi_offset 14, -14
 1908 08cc FF92      		push r15
 1909               	.LCFI62:
 1910               		.cfi_def_cfa_offset 16
 1911               		.cfi_offset 15, -15
 1912 08ce 0F93      		push r16
 1913               	.LCFI63:
 1914               		.cfi_def_cfa_offset 17
 1915               		.cfi_offset 16, -16
 1916 08d0 1F93      		push r17
 1917               	.LCFI64:
 1918               		.cfi_def_cfa_offset 18
 1919               		.cfi_offset 17, -17
 1920 08d2 CF93      		push r28
 1921               	.LCFI65:
 1922               		.cfi_def_cfa_offset 19
 1923               		.cfi_offset 28, -18
 1924 08d4 DF93      		push r29
 1925               	.LCFI66:
 1926               		.cfi_def_cfa_offset 20
 1927               		.cfi_offset 29, -19
 1928 08d6 CDB7      		in r28,__SP_L__
 1929 08d8 DEB7      		in r29,__SP_H__
 1930               	.LCFI67:
 1931               		.cfi_def_cfa_register 28
 1932 08da 2997      		sbiw r28,9
 1933               	.LCFI68:
 1934               		.cfi_def_cfa_offset 29
 1935 08dc 0FB6      		in __tmp_reg__,__SREG__
 1936 08de F894      		cli
 1937 08e0 DEBF      		out __SP_H__,r29
 1938 08e2 0FBE      		out __SREG__,__tmp_reg__
 1939 08e4 CDBF      		out __SP_L__,r28
 1940               	/* prologue: function */
 1941               	/* frame size = 9 */
 1942               	/* stack size = 27 */
 1943               	.L__stack_usage = 27
 1944 08e6 6C83      		std Y+4,r22
 1945 08e8 B42E      		mov r11,r20
 1946 08ea 3901      		movw r6,r18
 942:draw.c        ****     if (s_r & MODE_FILL)
 1947               		.loc 1 942 0
 1948 08ec 83FF      		sbrs r24,3
 1949 08ee 00C0      		rjmp .L84
 943:draw.c        ****     {
 944:draw.c        ****         // Correct the reverse flag
 945:draw.c        ****         s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~MODE_NORMAL_MASK);
 1950               		.loc 1 945 0
 1951 08f0 982F      		mov r25,r24
 1952 08f2 9095      		com r25
 1953 08f4 2091 0000 		lds r18,prefs+4
 1954               	.LVL231:
 1955 08f8 9227      		eor r25,r18
 1956 08fa 982E      		mov r9,r24
 1957 08fc 90FB      		bst r25,0
 1958 08fe 90F8      		bld r9,0
 1959               	.LVL232:
 1960               	.LBB51:
 1961               	.LBB52:
 612:draw.c        ****     if (y_valid(y))
 1962               		.loc 1 612 0
 1963 0900 242F      		mov r18,r20
 1964 0902 30E0      		ldi r19,0
 1965 0904 8091 0000 		lds r24,y_dim
 1966 0908 90E0      		ldi r25,0
 1967 090a 9195      		neg r25
 1968 090c 8195      		neg r24
 1969 090e 9109      		sbc r25,__zero_reg__
 1970 0910 8223      		and r24,r18
 1971 0912 9323      		and r25,r19
 1972 0914 892B      		or r24,r25
 1973 0916 01F4      		brne .L85
 613:draw.c        ****         draw_buffer[y] = 0xff;
 1974               		.loc 1 613 0
 1975 0918 F901      		movw r30,r18
 1976 091a E050      		subi r30,lo8(-(draw_buffer))
 1977 091c F040      		sbci r31,hi8(-(draw_buffer))
 1978 091e 8FEF      		ldi r24,lo8(-1)
 1979 0920 8083      		st Z,r24
 1980               	.L85:
 1981               	.LBE52:
 1982               	.LBE51:
 941:draw.c        **** {
 1983               		.loc 1 941 0
 1984 0922 BB82      		std Y+3,r11
 1985 0924 BA82      		std Y+2,r11
 1986 0926 3B2C      		mov r3,r11
 1987 0928 DC80      		ldd r13,Y+4
 1988 092a 1D82      		std Y+5,__zero_reg__
 1989 092c CC24      		clr r12
 1990 092e CA94      		dec r12
 1991 0930 1E82      		std Y+6,__zero_reg__
 1992               	.LBB73:
 1993               	.LBB71:
 1994               	.LBB53:
 1995               	.LBB54:
 1996               	.LBB55:
 890:draw.c        ****                     buffer = 0xff;
 1997               		.loc 1 890 0
 1998 0932 8824      		clr r8
 1999 0934 8A94      		dec r8
 2000               	.LVL233:
 2001               	.L127:
 2002               	.LBE55:
 2003               	.LBE54:
 626:draw.c        ****         if (last_coord == 0)
 2004               		.loc 1 626 0
 2005 0936 3E81      		ldd r19,Y+6
 2006 0938 3111      		cpse r19,__zero_reg__
 2007 093a 00C0      		rjmp .L86
 2008               	.LVL234:
 629:draw.c        ****             x1 = serial_getc();
 2009               		.loc 1 629 0
 2010 093c 0E94 0000 		call serial_getc
 2011               	.LVL235:
 2012 0940 A82E      		mov r10,r24
 2013               	.LVL236:
 630:draw.c        ****             y1 = serial_getc();
 2014               		.loc 1 630 0
 2015 0942 0E94 0000 		call serial_getc
 2016               	.LVL237:
 633:draw.c        ****             last_coord = y1 & 0x80;
 2017               		.loc 1 633 0
 2018 0946 582F      		mov r21,r24
 2019 0948 5078      		andi r21,lo8(-128)
 2020 094a 5E83      		std Y+6,r21
 2021               	.LVL238:
 634:draw.c        ****             y1 &= ~0x80;
 2022               		.loc 1 634 0
 2023 094c 8F77      		andi r24,lo8(127)
 2024               	.LVL239:
 2025 094e 282E      		mov r2,r24
 2026               	.LVL240:
 2027 0950 00C0      		rjmp .L87
 2028               	.LVL241:
 2029               	.L86:
 641:draw.c        ****             y1 = yfirst;
 2030               		.loc 1 641 0
 2031 0952 2B2C      		mov r2,r11
 640:draw.c        ****             x1 = xfirst;
 2032               		.loc 1 640 0
 2033 0954 AC80      		ldd r10,Y+4
 642:draw.c        ****             yfirst |= 0x80;             // mark as end the loop
 2034               		.loc 1 642 0
 2035 0956 8B2D      		mov r24,r11
 2036 0958 8068      		ori r24,lo8(-128)
 2037               	.LVL242:
 2038 095a B82E      		mov r11,r24
 2039               	.LVL243:
 2040               	.L87:
 2041 095c 032D      		mov r16,r3
 2042 095e 10E0      		ldi r17,0
 654:draw.c        ****         if (y == y1)
 2043               		.loc 1 654 0
 2044 0960 3210      		cpse r3,r2
 2045 0962 00C0      		rjmp .L88
 2046               	.LBB58:
 658:draw.c        ****             uint8_t buffer = draw_buffer[y];
 2047               		.loc 1 658 0
 2048 0964 F801      		movw r30,r16
 2049 0966 E050      		subi r30,lo8(-(draw_buffer))
 2050 0968 F040      		sbci r31,hi8(-(draw_buffer))
 2051 096a 8081      		ld r24,Z
 2052               	.LVL244:
 661:draw.c        ****             if (x == x1)
 2053               		.loc 1 661 0
 2054 096c DA14      		cp r13,r10
 2055 096e 01F4      		brne .+2
 2056 0970 00C0      		rjmp .L89
 665:draw.c        ****             if (x > x1)
 2057               		.loc 1 665 0
 2058 0972 AD14      		cp r10,r13
 2059 0974 00F4      		brsh .L90
 671:draw.c        ****                 if (direction <= 0)
 2060               		.loc 1 671 0
 2061 0976 1C14      		cp __zero_reg__,r12
 2062 0978 04F0      		brlt .+2
 2063 097a 00C0      		rjmp .L89
 676:draw.c        ****                 if ((buffer != 0xff) && (buffer >= x))
 2064               		.loc 1 676 0
 2065 097c 8F3F      		cpi r24,lo8(-1)
 2066 097e 01F0      		breq .L91
 2067 0980 8D15      		cp r24,r13
 2068 0982 00F0      		brlo .L91
 2069               	.LVL245:
 679:draw.c        ****                     draw_buffer[y] = 0xff /* x1*/;
 2070               		.loc 1 679 0
 2071 0984 8082      		st Z,r8
 2072 0986 D82E      		mov r13,r24
 2073               	.LVL246:
 2074               	.L91:
 683:draw.c        ****                 xend = x1 + 1;
 2075               		.loc 1 683 0
 2076 0988 41E0      		ldi r20,lo8(1)
 2077 098a 00C0      		rjmp .L157
 2078               	.LVL247:
 2079               	.L90:
 691:draw.c        ****                 if (direction != 0)
 2080               		.loc 1 691 0
 2081 098c C110      		cpse r12,__zero_reg__
 2082 098e 00C0      		rjmp .L89
 696:draw.c        ****                 if ((buffer != 0xff) && (buffer <= x))
 2083               		.loc 1 696 0
 2084 0990 8F3F      		cpi r24,lo8(-1)
 2085 0992 01F0      		breq .L93
 2086 0994 D816      		cp r13,r24
 2087 0996 00F0      		brlo .L93
 2088               	.LVL248:
 699:draw.c        ****                     draw_buffer[y] = 0xff /* x1*/;
 2089               		.loc 1 699 0
 2090 0998 8082      		st Z,r8
 2091 099a D82E      		mov r13,r24
 2092               	.LVL249:
 2093               	.L93:
 703:draw.c        ****                 xend = x1 - 1;
 2094               		.loc 1 703 0
 2095 099c 4FEF      		ldi r20,lo8(-1)
 2096               	.L157:
 2097 099e 4A0D      		add r20,r10
 2098               	.LVL250:
 2099               	.LBB59:
 705:draw.c        ****             draw_hline (xstart, y, xend, s_r);
 2100               		.loc 1 705 0
 2101 09a0 E091 0000 		lds r30,functabP
 2102 09a4 F091 0000 		lds r31,functabP+1
 2103               	.LVL251:
 2104               	/* #APP */
 2105               	 ;  705 "draw.c" 1
 2106 09a8 A591      		lpm r26, Z+
 2107 09aa B491      		lpm r27, Z
 2108               		
 2109               	 ;  0 "" 2
 2110               	.LVL252:
 2111               	/* #NOAPP */
 2112               	.LBE59:
 2113 09ac 292D      		mov r18,r9
 2114 09ae 632D      		mov r22,r3
 2115 09b0 8D2D      		mov r24,r13
 2116               	.LVL253:
 2117 09b2 FD01      		movw r30,r26
 2118 09b4 0995      		icall
 2119               	.LVL254:
 2120 09b6 00C0      		rjmp .L89
 2121               	.LVL255:
 2122               	.L88:
 2123 09b8 822D      		mov r24,r2
 2124 09ba 90E0      		ldi r25,0
 2125               	.LBE58:
 711:draw.c        ****         else if (y1 > y)                // The y-values are increasing
 2126               		.loc 1 711 0
 2127 09bc 3214      		cp r3,r2
 2128 09be 00F4      		brsh .L94
 2129               	.LVL256:
 714:draw.c        ****             deltay = y1 - y;            // The difference between the y's
 2130               		.loc 1 714 0
 2131 09c0 2C01      		movw r4,r24
 2132 09c2 401A      		sub r4,r16
 2133 09c4 510A      		sbc r5,r17
 2134               	.LVL257:
 716:draw.c        ****             while ((y1 > write_yend) && (write_yend < y_dim - 1))
 2135               		.loc 1 716 0
 2136 09c6 8091 0000 		lds r24,y_dim
 2137 09ca 90E0      		ldi r25,0
 2138 09cc 0197      		sbiw r24,1
 2139               	.L95:
 2140 09ce 5B81      		ldd r21,Y+3
 2141 09d0 5215      		cp r21,r2
 2142 09d2 00F0      		brlo .L96
 2143               	.L100:
 720:draw.c        ****             if (direction >= 0)
 2144               		.loc 1 720 0
 2145 09d4 8FEF      		ldi r24,lo8(-1)
 721:draw.c        ****                 direction_changed = direction ^ 1;
 2146               		.loc 1 721 0
 2147 09d6 91E0      		ldi r25,lo8(1)
 720:draw.c        ****             if (direction >= 0)
 2148               		.loc 1 720 0
 2149 09d8 C812      		cpse r12,r24
 2150 09da 00C0      		rjmp .L97
 713:draw.c        ****             yinc = 1;
 2151               		.loc 1 713 0
 2152 09dc 9983      		std Y+1,r25
 2153 09de 00C0      		rjmp .L158
 2154               	.LVL258:
 2155               	.L96:
 716:draw.c        ****             while ((y1 > write_yend) && (write_yend < y_dim - 1))
 2156               		.loc 1 716 0
 2157 09e0 5B81      		ldd r21,Y+3
 2158               	.LVL259:
 2159 09e2 252F      		mov r18,r21
 2160 09e4 30E0      		ldi r19,0
 2161 09e6 2817      		cp r18,r24
 2162 09e8 3907      		cpc r19,r25
 2163 09ea 04F4      		brge .L100
 717:draw.c        ****                 draw_buffer [++write_yend] = 0xff;
 2164               		.loc 1 717 0
 2165 09ec 3B81      		ldd r19,Y+3
 2166 09ee 3F5F      		subi r19,lo8(-(1))
 2167 09f0 3B83      		std Y+3,r19
 2168               	.LVL260:
 2169 09f2 E32F      		mov r30,r19
 2170 09f4 F0E0      		ldi r31,0
 2171 09f6 E050      		subi r30,lo8(-(draw_buffer))
 2172 09f8 F040      		sbci r31,hi8(-(draw_buffer))
 2173 09fa 8082      		st Z,r8
 2174 09fc 00C0      		rjmp .L95
 2175               	.LVL261:
 2176               	.L97:
 721:draw.c        ****                 direction_changed = direction ^ 1;
 2177               		.loc 1 721 0
 2178 09fe 9C25      		eor r25,r12
 2179 0a00 9D83      		std Y+5,r25
 2180               	.LVL262:
 713:draw.c        ****             yinc = 1;
 2181               		.loc 1 713 0
 2182 0a02 31E0      		ldi r19,lo8(1)
 2183 0a04 3983      		std Y+1,r19
 2184               	.LVL263:
 2185               	.L158:
 722:draw.c        ****             direction = 1;
 2186               		.loc 1 722 0
 2187 0a06 CC24      		clr r12
 2188 0a08 C394      		inc r12
 2189               	.LVL264:
 2190 0a0a 00C0      		rjmp .L98
 2191               	.LVL265:
 2192               	.L94:
 727:draw.c        ****             deltay = y - y1;
 2193               		.loc 1 727 0
 2194 0a0c 2801      		movw r4,r16
 2195 0a0e 481A      		sub r4,r24
 2196 0a10 590A      		sbc r5,r25
 2197               	.LVL266:
 2198               	.L101:
 729:draw.c        ****             while ((y1 < write_ystart) && (write_ystart > 0))
 2199               		.loc 1 729 0
 2200 0a12 9A81      		ldd r25,Y+2
 2201 0a14 2916      		cp r2,r25
 2202 0a16 00F4      		brsh .L102
 2203 0a18 9923      		tst r25
 2204 0a1a 01F0      		breq .L102
 730:draw.c        ****                 draw_buffer [--write_ystart] = 0xff;
 2205               		.loc 1 730 0
 2206 0a1c 5A81      		ldd r21,Y+2
 2207 0a1e 5150      		subi r21,lo8(-(-1))
 2208 0a20 5A83      		std Y+2,r21
 2209               	.LVL267:
 2210 0a22 E52F      		mov r30,r21
 2211 0a24 F0E0      		ldi r31,0
 2212 0a26 E050      		subi r30,lo8(-(draw_buffer))
 2213 0a28 F040      		sbci r31,hi8(-(draw_buffer))
 2214 0a2a 8082      		st Z,r8
 2215 0a2c 00C0      		rjmp .L101
 2216               	.LVL268:
 2217               	.L102:
 733:draw.c        ****             if (direction >= 0)
 2218               		.loc 1 733 0
 2219 0a2e AFEF      		ldi r26,lo8(-1)
 2220 0a30 CA12      		cpse r12,r26
 2221 0a32 00C0      		rjmp .L134
 726:draw.c        ****             yinc = -1;
 2222               		.loc 1 726 0
 2223 0a34 3FEF      		ldi r19,lo8(-1)
 2224 0a36 3983      		std Y+1,r19
 2225 0a38 00C0      		rjmp .L159
 2226               	.L134:
 733:draw.c        ****             if (direction >= 0)
 2227               		.loc 1 733 0
 2228 0a3a CD82      		std Y+5,r12
 2229               	.LVL269:
 726:draw.c        ****             yinc = -1;
 2230               		.loc 1 726 0
 2231 0a3c 5FEF      		ldi r21,lo8(-1)
 2232 0a3e 5983      		std Y+1,r21
 2233               	.L159:
 735:draw.c        ****             direction = 0;
 2234               		.loc 1 735 0
 2235 0a40 C12C      		mov r12,__zero_reg__
 2236               	.LVL270:
 2237               	.L98:
 2238 0a42 2A2D      		mov r18,r10
 2239 0a44 30E0      		ldi r19,0
 2240 0a46 4D2D      		mov r20,r13
 2241 0a48 50E0      		ldi r21,0
 739:draw.c        ****         if (x1 >= x)                       // The x-values are increasing
 2242               		.loc 1 739 0
 2243 0a4a AD14      		cp r10,r13
 2244 0a4c 00F0      		brlo .L104
 741:draw.c        ****             if (x1 == x)
 2245               		.loc 1 741 0
 2246 0a4e 91E0      		ldi r25,lo8(1)
 2247 0a50 AD10      		cpse r10,r13
 2248 0a52 00C0      		rjmp .L105
 2249 0a54 90E0      		ldi r25,0
 2250               	.L105:
 2251               	.LVL271:
 745:draw.c        ****             deltax = x1 - x;
 2252               		.loc 1 745 0
 2253 0a56 3901      		movw r6,r18
 2254 0a58 641A      		sub r6,r20
 2255 0a5a 750A      		sbc r7,r21
 2256               	.LVL272:
 2257 0a5c 00C0      		rjmp .L106
 2258               	.LVL273:
 2259               	.L104:
 750:draw.c        ****             deltax = x - x1;
 2260               		.loc 1 750 0
 2261 0a5e 3A01      		movw r6,r20
 2262 0a60 621A      		sub r6,r18
 2263 0a62 730A      		sbc r7,r19
 2264               	.LVL274:
 749:draw.c        ****             xinc = -1;
 2265               		.loc 1 749 0
 2266 0a64 9FEF      		ldi r25,lo8(-1)
 2267               	.LVL275:
 2268               	.L106:
 759:draw.c        ****         if (direction_changed)
 2269               		.loc 1 759 0
 2270 0a66 3D81      		ldd r19,Y+5
 2271 0a68 3323      		tst r19
 2272 0a6a 01F0      		breq .L107
 2273               	.LBB60:
 761:draw.c        ****             uint8_t buffer = draw_buffer[y];
 2274               		.loc 1 761 0
 2275 0a6c 0050      		subi r16,lo8(-(draw_buffer))
 2276 0a6e 1040      		sbci r17,hi8(-(draw_buffer))
 2277 0a70 D801      		movw r26,r16
 2278 0a72 4C91      		ld r20,X
 2279               	.LVL276:
 768:draw.c        ****             if (direction == 1)
 2280               		.loc 1 768 0
 2281 0a74 B1E0      		ldi r27,lo8(1)
 2282 0a76 CB12      		cpse r12,r27
 2283 0a78 00C0      		rjmp .L108
 770:draw.c        ****                 if (buffer == 0xff)
 2284               		.loc 1 770 0
 2285 0a7a 4F3F      		cpi r20,lo8(-1)
 2286 0a7c 01F0      		breq .L160
 772:draw.c        ****                 else if (buffer > x)
 2287               		.loc 1 772 0
 2288 0a7e D416      		cp r13,r20
 2289 0a80 00F4      		brsh .L107
 2290               	.LBB61:
 774:draw.c        ****                     draw_hline (x+1, y, buffer, s_r);
 2291               		.loc 1 774 0
 2292 0a82 E091 0000 		lds r30,functabP
 2293 0a86 F091 0000 		lds r31,functabP+1
 2294               	.LVL277:
 2295               	/* #APP */
 2296               	 ;  774 "draw.c" 1
 2297 0a8a A591      		lpm r26, Z+
 2298 0a8c B491      		lpm r27, Z
 2299               		
 2300               	 ;  0 "" 2
 2301               	.LVL278:
 2302               	/* #NOAPP */
 2303               	.LBE61:
 2304 0a8e 292D      		mov r18,r9
 2305 0a90 632D      		mov r22,r3
 2306 0a92 81E0      		ldi r24,lo8(1)
 2307 0a94 00C0      		rjmp .L161
 2308               	.LVL279:
 2309               	.L108:
 781:draw.c        ****                 if (buffer == 0xff)
 2310               		.loc 1 781 0
 2311 0a96 4F3F      		cpi r20,lo8(-1)
 2312 0a98 01F4      		brne .L110
 2313               	.L160:
 782:draw.c        ****                     draw_buffer[y] = x;
 2314               		.loc 1 782 0
 2315 0a9a F801      		movw r30,r16
 2316 0a9c D082      		st Z,r13
 2317 0a9e 00C0      		rjmp .L107
 2318               	.L110:
 783:draw.c        ****                 else if (buffer < x)
 2319               		.loc 1 783 0
 2320 0aa0 4D15      		cp r20,r13
 2321 0aa2 00F4      		brsh .L107
 2322               	.LBB62:
 785:draw.c        ****                     draw_hline (x-1, y, buffer, s_r);
 2323               		.loc 1 785 0
 2324 0aa4 E091 0000 		lds r30,functabP
 2325 0aa8 F091 0000 		lds r31,functabP+1
 2326               	.LVL280:
 2327               	/* #APP */
 2328               	 ;  785 "draw.c" 1
 2329 0aac A591      		lpm r26, Z+
 2330 0aae B491      		lpm r27, Z
 2331               		
 2332               	 ;  0 "" 2
 2333               	.LVL281:
 2334               	/* #NOAPP */
 2335               	.LBE62:
 2336 0ab0 292D      		mov r18,r9
 2337 0ab2 632D      		mov r22,r3
 2338 0ab4 8FEF      		ldi r24,lo8(-1)
 2339               	.LVL282:
 2340               	.L161:
 2341 0ab6 8D0D      		add r24,r13
 2342 0ab8 9F83      		std Y+7,r25
 2343 0aba FD01      		movw r30,r26
 2344 0abc 0995      		icall
 2345               	.LVL283:
 786:draw.c        ****                     draw_buffer[y] = 0xff;
 2346               		.loc 1 786 0
 2347 0abe D801      		movw r26,r16
 2348 0ac0 8C92      		st X,r8
 2349 0ac2 9F81      		ldd r25,Y+7
 2350               	.L107:
 2351               	.LBE60:
 793:draw.c        ****         if (deltax >= deltay)
 2352               		.loc 1 793 0
 2353 0ac4 6414      		cp r6,r4
 2354 0ac6 7504      		cpc r7,r5
 2355 0ac8 04F4      		brge .+2
 2356 0aca 00C0      		rjmp .L111
 2357               	.LVL284:
 2358               	.LBB63:
 803:draw.c        ****             numerator = deltax / 2;         // The numerator
 2359               		.loc 1 803 0
 2360 0acc 9301      		movw r18,r6
 2361 0ace 77FE      		sbrs r7,7
 2362 0ad0 00C0      		rjmp .L112
 2363 0ad2 2F5F      		subi r18,-1
 2364 0ad4 3F4F      		sbci r19,-1
 2365               	.L112:
 2366 0ad6 F901      		movw r30,r18
 2367 0ad8 F595      		asr r31
 2368 0ada E795      		ror r30
 2369 0adc F987      		std Y+9,r31
 2370 0ade E887      		std Y+8,r30
 2371               	.LVL285:
 2372 0ae0 8D2D      		mov r24,r13
 2373 0ae2 7301      		movw r14,r6
 2374               	.LVL286:
 2375               	.L113:
 809:draw.c        ****             while (--numpixels >= 0)
 2376               		.loc 1 809 0
 2377 0ae4 41E0      		ldi r20,1
 2378 0ae6 E41A      		sub r14,r20
 2379 0ae8 F108      		sbc r15,__zero_reg__
 2380               	.LVL287:
 2381 0aea F7FC      		sbrc r15,7
 2382 0aec 00C0      		rjmp .L162
 811:draw.c        ****                 numerator += numadd;          // Increase the numerator by the top of the fraction
 2383               		.loc 1 811 0
 2384 0aee 2885      		ldd r18,Y+8
 2385 0af0 3985      		ldd r19,Y+9
 2386 0af2 240D      		add r18,r4
 2387 0af4 351D      		adc r19,r5
 2388 0af6 3987      		std Y+9,r19
 2389 0af8 2887      		std Y+8,r18
 2390               	.LVL288:
 812:draw.c        ****                 if (numerator >= denominator) // Check if numerator >= denominator
 2391               		.loc 1 812 0
 2392 0afa 2615      		cp r18,r6
 2393 0afc 3705      		cpc r19,r7
 2394 0afe 04F0      		brlt .L114
 2395               	.LBB64:
 819:draw.c        ****                     if (((direction == 1) && (xinc > 0)) ||
 2396               		.loc 1 819 0
 2397 0b00 31E0      		ldi r19,lo8(1)
 2398 0b02 C312      		cpse r12,r19
 2399 0b04 00C0      		rjmp .L115
 2400 0b06 9130      		cpi r25,lo8(1)
 2401 0b08 01F0      		breq .L136
 2402 0b0a 00C0      		rjmp .L116
 2403               	.L115:
 820:draw.c        ****                         ((direction == 0) && (xinc < 0)))
 2404               		.loc 1 820 0
 2405 0b0c 9F3F      		cpi r25,lo8(-1)
 2406 0b0e 01F4      		brne .L116
 2407               	.L136:
 2408 0b10 8D2D      		mov r24,r13
 2409               	.LVL289:
 2410               	.L116:
 825:draw.c        ****                     buffer = draw_buffer[y];
 2411               		.loc 1 825 0
 2412 0b12 032D      		mov r16,r3
 2413 0b14 10E0      		ldi r17,0
 2414 0b16 0050      		subi r16,lo8(-(draw_buffer))
 2415 0b18 1040      		sbci r17,hi8(-(draw_buffer))
 2416 0b1a D801      		movw r26,r16
 2417 0b1c 4C91      		ld r20,X
 2418               	.LVL290:
 826:draw.c        ****                     if (buffer != 0xff)
 2419               		.loc 1 826 0
 2420 0b1e 4F3F      		cpi r20,lo8(-1)
 2421 0b20 01F0      		breq .L117
 2422               	.LBB65:
 830:draw.c        ****                         draw_hline (xstart, y, buffer, s_r);
 2423               		.loc 1 830 0
 2424 0b22 E091 0000 		lds r30,functabP
 2425 0b26 F091 0000 		lds r31,functabP+1
 2426               	.LVL291:
 2427               	/* #APP */
 2428               	 ;  830 "draw.c" 1
 2429 0b2a A591      		lpm r26, Z+
 2430 0b2c B491      		lpm r27, Z
 2431               		
 2432               	 ;  0 "" 2
 2433               	.LVL292:
 2434               	/* #NOAPP */
 2435               	.LBE65:
 2436 0b2e 292D      		mov r18,r9
 2437               	.LVL293:
 2438 0b30 632D      		mov r22,r3
 2439 0b32 9F83      		std Y+7,r25
 2440 0b34 FD01      		movw r30,r26
 2441 0b36 0995      		icall
 2442               	.LVL294:
 831:draw.c        ****                         xstart = 0xff;
 2443               		.loc 1 831 0
 2444 0b38 8FEF      		ldi r24,lo8(-1)
 2445 0b3a 9F81      		ldd r25,Y+7
 2446               	.LVL295:
 2447               	.L117:
 833:draw.c        ****                     draw_buffer[y] = xstart;
 2448               		.loc 1 833 0
 2449 0b3c D801      		movw r26,r16
 2450 0b3e 8C93      		st X,r24
 835:draw.c        ****                     numerator -= denominator; // Calculate the new numerator value
 2451               		.loc 1 835 0
 2452 0b40 E885      		ldd r30,Y+8
 2453 0b42 F985      		ldd r31,Y+9
 2454 0b44 E619      		sub r30,r6
 2455 0b46 F709      		sbc r31,r7
 2456 0b48 F987      		std Y+9,r31
 2457 0b4a E887      		std Y+8,r30
 2458               	.LVL296:
 836:draw.c        ****                     y += yinc;                // Change the y as appropriate
 2459               		.loc 1 836 0
 2460 0b4c 3981      		ldd r19,Y+1
 2461 0b4e 330E      		add r3,r19
 2462               	.LVL297:
 837:draw.c        ****                     x += xinc;                // Change the x for the nxt loop
 2463               		.loc 1 837 0
 2464 0b50 8D2D      		mov r24,r13
 2465               	.LVL298:
 2466 0b52 890F      		add r24,r25
 2467               	.LVL299:
 2468 0b54 D82E      		mov r13,r24
 2469 0b56 00C0      		rjmp .L113
 2470               	.LVL300:
 2471               	.L114:
 2472               	.LBE64:
 843:draw.c        ****                     x += xinc;
 2473               		.loc 1 843 0
 2474 0b58 D90E      		add r13,r25
 2475               	.LVL301:
 2476 0b5a 00C0      		rjmp .L113
 2477               	.LVL302:
 2478               	.L162:
 850:draw.c        ****             if (xstart != x)
 2479               		.loc 1 850 0
 2480 0b5c 8D15      		cp r24,r13
 2481 0b5e 01F4      		brne .+2
 2482 0b60 00C0      		rjmp .L137
 2483               	.LBB66:
 852:draw.c        ****                 uint8_t buffer = draw_buffer[y];
 2484               		.loc 1 852 0
 2485 0b62 032D      		mov r16,r3
 2486 0b64 10E0      		ldi r17,0
 2487 0b66 0050      		subi r16,lo8(-(draw_buffer))
 2488 0b68 1040      		sbci r17,hi8(-(draw_buffer))
 2489 0b6a D801      		movw r26,r16
 2490 0b6c 4C91      		ld r20,X
 2491               	.LVL303:
 856:draw.c        ****                 if (buffer != 0xff)
 2492               		.loc 1 856 0
 2493 0b6e 4F3F      		cpi r20,lo8(-1)
 2494 0b70 01F0      		breq .L120
 2495               	.LBB67:
 860:draw.c        ****                     draw_hline (xstart, y, buffer, s_r);
 2496               		.loc 1 860 0
 2497 0b72 E091 0000 		lds r30,functabP
 2498 0b76 F091 0000 		lds r31,functabP+1
 2499               	.LVL304:
 2500               	/* #APP */
 2501               	 ;  860 "draw.c" 1
 2502 0b7a A591      		lpm r26, Z+
 2503 0b7c B491      		lpm r27, Z
 2504               		
 2505               	 ;  0 "" 2
 2506               	.LVL305:
 2507               	/* #NOAPP */
 2508               	.LBE67:
 2509 0b7e 292D      		mov r18,r9
 2510 0b80 632D      		mov r22,r3
 2511 0b82 FD01      		movw r30,r26
 2512 0b84 0995      		icall
 2513               	.LVL306:
 861:draw.c        ****                     xstart = 0xff;
 2514               		.loc 1 861 0
 2515 0b86 8FEF      		ldi r24,lo8(-1)
 2516               	.LVL307:
 2517               	.L120:
 863:draw.c        ****                 draw_buffer[y] = xstart;
 2518               		.loc 1 863 0
 2519 0b88 D801      		movw r26,r16
 2520 0b8a 8C93      		st X,r24
 2521 0b8c 00C0      		rjmp .L137
 2522               	.LVL308:
 2523               	.L111:
 2524               	.LBE66:
 2525               	.LBE63:
 2526               	.LBB68:
 876:draw.c        ****             numerator = deltay / 2;
 2527               		.loc 1 876 0
 2528 0b8e 9201      		movw r18,r4
 2529 0b90 57FE      		sbrs r5,7
 2530 0b92 00C0      		rjmp .L121
 2531 0b94 2F5F      		subi r18,-1
 2532 0b96 3F4F      		sbci r19,-1
 2533               	.L121:
 2534 0b98 F901      		movw r30,r18
 2535 0b9a F595      		asr r31
 2536 0b9c E795      		ror r30
 2537 0b9e F987      		std Y+9,r31
 2538 0ba0 E887      		std Y+8,r30
 2539               	.LVL309:
 2540 0ba2 7201      		movw r14,r4
 2541               	.LVL310:
 2542               	.L122:
 881:draw.c        ****             while (--numpixels >= 0)
 2543               		.loc 1 881 0
 2544 0ba4 41E0      		ldi r20,1
 2545 0ba6 E41A      		sub r14,r20
 2546 0ba8 F108      		sbc r15,__zero_reg__
 2547               	.LVL311:
 2548 0baa F7FC      		sbrc r15,7
 2549 0bac 00C0      		rjmp .L137
 2550               	.LBB57:
 883:draw.c        ****                 uint8_t buffer = draw_buffer[y];
 2551               		.loc 1 883 0
 2552 0bae 032D      		mov r16,r3
 2553 0bb0 10E0      		ldi r17,0
 2554 0bb2 0050      		subi r16,lo8(-(draw_buffer))
 2555 0bb4 1040      		sbci r17,hi8(-(draw_buffer))
 2556 0bb6 D801      		movw r26,r16
 2557 0bb8 4C91      		ld r20,X
 2558               	.LVL312:
 887:draw.c        ****                 if (buffer != 0xff)
 2559               		.loc 1 887 0
 2560 0bba 4F3F      		cpi r20,lo8(-1)
 2561 0bbc 01F0      		breq .L138
 2562               	.LBB56:
 889:draw.c        ****                     draw_hline (x, y, buffer, s_r);
 2563               		.loc 1 889 0
 2564 0bbe E091 0000 		lds r30,functabP
 2565 0bc2 F091 0000 		lds r31,functabP+1
 2566               	.LVL313:
 2567               	/* #APP */
 2568               	 ;  889 "draw.c" 1
 2569 0bc6 A591      		lpm r26, Z+
 2570 0bc8 B491      		lpm r27, Z
 2571               		
 2572               	 ;  0 "" 2
 2573               	.LVL314:
 2574               	/* #NOAPP */
 2575               	.LBE56:
 2576 0bca 292D      		mov r18,r9
 2577 0bcc 632D      		mov r22,r3
 2578 0bce 8D2D      		mov r24,r13
 2579 0bd0 9F83      		std Y+7,r25
 2580 0bd2 FD01      		movw r30,r26
 2581 0bd4 0995      		icall
 2582               	.LVL315:
 890:draw.c        ****                     buffer = 0xff;
 2583               		.loc 1 890 0
 2584 0bd6 8FEF      		ldi r24,lo8(-1)
 2585 0bd8 9F81      		ldd r25,Y+7
 2586 0bda 00C0      		rjmp .L123
 2587               	.LVL316:
 2588               	.L138:
 894:draw.c        ****                     buffer = x;
 2589               		.loc 1 894 0
 2590 0bdc 8D2D      		mov r24,r13
 2591               	.LVL317:
 2592               	.L123:
 896:draw.c        ****                 draw_buffer[y] = buffer;
 2593               		.loc 1 896 0
 2594 0bde D801      		movw r26,r16
 2595 0be0 8C93      		st X,r24
 899:draw.c        ****                 numerator += numadd;          // Increase the numerator by the top of the fraction
 2596               		.loc 1 899 0
 2597 0be2 E885      		ldd r30,Y+8
 2598 0be4 F985      		ldd r31,Y+9
 2599 0be6 E60D      		add r30,r6
 2600 0be8 F71D      		adc r31,r7
 2601 0bea F987      		std Y+9,r31
 2602 0bec E887      		std Y+8,r30
 2603               	.LVL318:
 900:draw.c        ****                 if (numerator >= denominator) // Check if numerator >= denominator
 2604               		.loc 1 900 0
 2605 0bee E415      		cp r30,r4
 2606 0bf0 F505      		cpc r31,r5
 2607 0bf2 04F0      		brlt .L124
 902:draw.c        ****                     numerator -= denominator; // Calculate the new numerator value
 2608               		.loc 1 902 0
 2609 0bf4 E419      		sub r30,r4
 2610 0bf6 F509      		sbc r31,r5
 2611               	.LVL319:
 2612 0bf8 F987      		std Y+9,r31
 2613 0bfa E887      		std Y+8,r30
 2614               	.LVL320:
 903:draw.c        ****                     x += xinc;                // Change the x as appropriate
 2615               		.loc 1 903 0
 2616 0bfc D90E      		add r13,r25
 2617               	.LVL321:
 2618               	.L124:
 907:draw.c        ****                 y += yinc;
 2619               		.loc 1 907 0
 2620 0bfe 3981      		ldd r19,Y+1
 2621 0c00 330E      		add r3,r19
 2622               	.LVL322:
 2623 0c02 00C0      		rjmp .L122
 2624               	.LVL323:
 2625               	.L137:
 2626               	.LBE57:
 2627               	.LBE68:
 2628               	.LBB69:
 850:draw.c        ****             if (xstart != x)
 2629               		.loc 1 850 0
 2630 0c04 322C      		mov r3,r2
 2631               	.LVL324:
 2632               	.L89:
 2633               	.LBE69:
 2634               	.LBE53:
 914:draw.c        ****     while ((yfirst & 0x80) == 0);
 2635               		.loc 1 914 0
 2636 0c06 B7FC      		sbrc r11,7
 2637 0c08 00C0      		rjmp .L126
 2638 0c0a DA2C      		mov r13,r10
 2639 0c0c 00C0      		rjmp .L127
 2640               	.L126:
 915:draw.c        ****     yfirst &= ~0x80;
 2641               		.loc 1 915 0
 2642 0c0e 6B2D      		mov r22,r11
 2643 0c10 6F77      		andi r22,lo8(127)
 2644               	.LVL325:
 918:draw.c        ****     if (draw_buffer[yfirst] != 0xff)
 2645               		.loc 1 918 0
 2646 0c12 E62F      		mov r30,r22
 2647 0c14 F0E0      		ldi r31,0
 2648 0c16 E050      		subi r30,lo8(-(draw_buffer))
 2649 0c18 F040      		sbci r31,hi8(-(draw_buffer))
 2650 0c1a 4081      		ld r20,Z
 2651 0c1c 4F3F      		cpi r20,lo8(-1)
 2652 0c1e 01F4      		brne .+2
 2653 0c20 00C0      		rjmp .L83
 2654               	.LBB70:
 920:draw.c        ****         draw_hline (xfirst, yfirst, draw_buffer[yfirst], s_r);
 2655               		.loc 1 920 0
 2656 0c22 E091 0000 		lds r30,functabP
 2657 0c26 F091 0000 		lds r31,functabP+1
 2658               	.LVL326:
 2659               	/* #APP */
 2660               	 ;  920 "draw.c" 1
 2661 0c2a A591      		lpm r26, Z+
 2662 0c2c B491      		lpm r27, Z
 2663               		
 2664               	 ;  0 "" 2
 2665               	.LVL327:
 2666               	/* #NOAPP */
 2667               	.LBE70:
 2668 0c2e 292D      		mov r18,r9
 2669 0c30 8C81      		ldd r24,Y+4
 2670 0c32 FD01      		movw r30,r26
 2671               	/* epilogue start */
 2672               	.LBE71:
 2673               	.LBE73:
 946:draw.c        ****         // Invoke the fill
 947:draw.c        ****         _fill_polygon (s_r, x, y);
 948:draw.c        ****     }
 949:draw.c        ****     else
 950:draw.c        ****     {
 951:draw.c        ****         uint8_t x1, y1;
 952:draw.c        **** 
 953:draw.c        ****         // Cache line and do not draw endpoint
 954:draw.c        ****         s_r |= MODE_LINE_SKIP_LAST;
 955:draw.c        **** 
 956:draw.c        ****         // Prepare x and y for the loop
 957:draw.c        ****         x1 = x;
 958:draw.c        ****         y1 = y;
 959:draw.c        **** 
 960:draw.c        ****         // Iterate over the rest of the coordinate until we have finished.
 961:draw.c        ****         do
 962:draw.c        ****         {
 963:draw.c        ****             uint8_t x2, y2;
 964:draw.c        **** 
 965:draw.c        ****             if (data != NULL)
 966:draw.c        ****             {
 967:draw.c        ****                 x2 = *data++;
 968:draw.c        ****                 y2 = *data++;
 969:draw.c        ****             }
 970:draw.c        ****             else
 971:draw.c        ****             {
 972:draw.c        ****                 x2 = serial_getc (); // Save x
 973:draw.c        ****                 y2 = serial_getc (); // Save y
 974:draw.c        ****             }
 975:draw.c        **** 
 976:draw.c        ****             // Draw the line
 977:draw.c        ****             draw_line (x1, y1, x2, y2 & 0x7f, s_r);
 978:draw.c        ****             x1 = x2;
 979:draw.c        ****             y1 = y2;
 980:draw.c        ****         }
 981:draw.c        ****         while ((y1 & 0x80) == 0);
 982:draw.c        **** 
 983:draw.c        ****         // Join up to the start position.
 984:draw.c        ****         draw_line (x1, y1 & 0x7f, x, y, s_r);
 985:draw.c        ****     }
 986:draw.c        **** }
 2674               		.loc 1 986 0
 2675 0c34 2996      		adiw r28,9
 2676 0c36 0FB6      		in __tmp_reg__,__SREG__
 2677 0c38 F894      		cli
 2678 0c3a DEBF      		out __SP_H__,r29
 2679 0c3c 0FBE      		out __SREG__,__tmp_reg__
 2680 0c3e CDBF      		out __SP_L__,r28
 2681 0c40 DF91      		pop r29
 2682 0c42 CF91      		pop r28
 2683 0c44 1F91      		pop r17
 2684 0c46 0F91      		pop r16
 2685 0c48 FF90      		pop r15
 2686 0c4a EF90      		pop r14
 2687 0c4c DF90      		pop r13
 2688 0c4e CF90      		pop r12
 2689               	.LVL328:
 2690 0c50 BF90      		pop r11
 2691 0c52 AF90      		pop r10
 2692               	.LVL329:
 2693 0c54 9F90      		pop r9
 2694               	.LVL330:
 2695 0c56 8F90      		pop r8
 2696 0c58 7F90      		pop r7
 2697 0c5a 6F90      		pop r6
 2698 0c5c 5F90      		pop r5
 2699 0c5e 4F90      		pop r4
 2700 0c60 3F90      		pop r3
 2701               	.LVL331:
 2702 0c62 2F90      		pop r2
 2703               	.LVL332:
 2704               	.LBB74:
 2705               	.LBB72:
 920:draw.c        ****         draw_hline (xfirst, yfirst, draw_buffer[yfirst], s_r);
 2706               		.loc 1 920 0
 2707 0c64 0994      		ijmp
 2708               	.LVL333:
 2709               	.L84:
 2710               	.LBE72:
 2711               	.LBE74:
 2712               	.LBB75:
 954:draw.c        ****         s_r |= MODE_LINE_SKIP_LAST;
 2713               		.loc 1 954 0
 2714 0c66 8068      		ori r24,lo8(-128)
 2715               	.LVL334:
 2716 0c68 982E      		mov r9,r24
 2717               	.LVL335:
 2718 0c6a 642F      		mov r22,r20
 2719               	.LVL336:
 957:draw.c        ****         x1 = x;
 2720               		.loc 1 957 0
 2721 0c6c DC80      		ldd r13,Y+4
 2722               	.LVL337:
 2723               	.L132:
 2724               	.LBB76:
 965:draw.c        ****             if (data != NULL)
 2725               		.loc 1 965 0
 2726 0c6e 6114      		cp r6,__zero_reg__
 2727 0c70 7104      		cpc r7,__zero_reg__
 2728 0c72 01F0      		breq .L129
 2729               	.LVL338:
 967:draw.c        ****                 x2 = *data++;
 2730               		.loc 1 967 0
 2731 0c74 D301      		movw r26,r6
 2732 0c76 1C91      		ld r17,X
 2733               	.LVL339:
 968:draw.c        ****                 y2 = *data++;
 2734               		.loc 1 968 0
 2735 0c78 1196      		adiw r26,1
 2736 0c7a FC90      		ld r15,X
 2737               	.LVL340:
 2738 0c7c F301      		movw r30,r6
 2739 0c7e 3296      		adiw r30,2
 2740               	.LVL341:
 2741 0c80 3F01      		movw r6,r30
 2742 0c82 00C0      		rjmp .L130
 2743               	.LVL342:
 2744               	.L129:
 972:draw.c        ****                 x2 = serial_getc (); // Save x
 2745               		.loc 1 972 0
 2746 0c84 6F83      		std Y+7,r22
 2747 0c86 0E94 0000 		call serial_getc
 2748               	.LVL343:
 2749 0c8a 182F      		mov r17,r24
 2750               	.LVL344:
 973:draw.c        ****                 y2 = serial_getc (); // Save y
 2751               		.loc 1 973 0
 2752 0c8c 0E94 0000 		call serial_getc
 2753               	.LVL345:
 2754 0c90 F82E      		mov r15,r24
 2755               	.LVL346:
 2756 0c92 6F81      		ldd r22,Y+7
 2757               	.L130:
 977:draw.c        ****             draw_line (x1, y1, x2, y2 & 0x7f, s_r);
 2758               		.loc 1 977 0
 2759 0c94 FF2D      		mov r31,r15
 2760 0c96 FF77      		andi r31,lo8(127)
 2761 0c98 EF2E      		mov r14,r31
 2762 0c9a 092D      		mov r16,r9
 2763 0c9c 2F2F      		mov r18,r31
 2764 0c9e 412F      		mov r20,r17
 2765 0ca0 8D2D      		mov r24,r13
 2766 0ca2 0E94 0000 		call draw_line
 2767               	.LVL347:
 2768               	.LBE76:
 981:draw.c        ****         while ((y1 & 0x80) == 0);
 2769               		.loc 1 981 0
 2770 0ca6 F7FC      		sbrc r15,7
 2771 0ca8 00C0      		rjmp .L131
 2772               	.LBB77:
 979:draw.c        ****             y1 = y2;
 2773               		.loc 1 979 0
 2774 0caa 6F2D      		mov r22,r15
 2775               	.LBE77:
 981:draw.c        ****         while ((y1 & 0x80) == 0);
 2776               		.loc 1 981 0
 2777 0cac D12E      		mov r13,r17
 2778 0cae 00C0      		rjmp .L132
 2779               	.L131:
 984:draw.c        ****         draw_line (x1, y1 & 0x7f, x, y, s_r);
 2780               		.loc 1 984 0
 2781 0cb0 092D      		mov r16,r9
 2782 0cb2 2B2D      		mov r18,r11
 2783 0cb4 4C81      		ldd r20,Y+4
 2784 0cb6 6E2D      		mov r22,r14
 2785 0cb8 812F      		mov r24,r17
 2786 0cba 0E94 0000 		call draw_line
 2787               	.LVL348:
 2788               	.L83:
 2789               	/* epilogue start */
 2790               	.LBE75:
 2791               		.loc 1 986 0
 2792 0cbe 2996      		adiw r28,9
 2793 0cc0 0FB6      		in __tmp_reg__,__SREG__
 2794 0cc2 F894      		cli
 2795 0cc4 DEBF      		out __SP_H__,r29
 2796 0cc6 0FBE      		out __SREG__,__tmp_reg__
 2797 0cc8 CDBF      		out __SP_L__,r28
 2798 0cca DF91      		pop r29
 2799 0ccc CF91      		pop r28
 2800 0cce 1F91      		pop r17
 2801 0cd0 0F91      		pop r16
 2802 0cd2 FF90      		pop r15
 2803 0cd4 EF90      		pop r14
 2804 0cd6 DF90      		pop r13
 2805 0cd8 CF90      		pop r12
 2806 0cda BF90      		pop r11
 2807 0cdc AF90      		pop r10
 2808 0cde 9F90      		pop r9
 2809               	.LVL349:
 2810 0ce0 8F90      		pop r8
 2811 0ce2 7F90      		pop r7
 2812 0ce4 6F90      		pop r6
 2813 0ce6 5F90      		pop r5
 2814 0ce8 4F90      		pop r4
 2815 0cea 3F90      		pop r3
 2816 0cec 2F90      		pop r2
 2817 0cee 0895      		ret
 2818               		.cfi_endproc
 2819               	.LFE21:
 2821               	.global	fill_vbox
 2823               	fill_vbox:
 2824               	.LFB22:
 987:draw.c        **** 
 988:draw.c        **** /////////////////////////////////////////////////////////////////////////////
 989:draw.c        **** // Draws a filled box on the screen. The box is described by a diagonal line
 990:draw.c        **** // from x, y1 to x2, y2. The block is filled with byte data (describes a
 991:draw.c        **** // vertical row of 8 pixels, use 0x00 to clear the block, 0xFF to fill it,
 992:draw.c        **** // etc.)
 993:draw.c        **** void
 994:draw.c        **** fill_vbox (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t data)
 995:draw.c        **** {
 2825               		.loc 1 995 0
 2826               		.cfi_startproc
 2827               	.LVL350:
 2828 0cf0 EF92      		push r14
 2829               	.LCFI69:
 2830               		.cfi_def_cfa_offset 3
 2831               		.cfi_offset 14, -2
 2832 0cf2 FF92      		push r15
 2833               	.LCFI70:
 2834               		.cfi_def_cfa_offset 4
 2835               		.cfi_offset 15, -3
 2836 0cf4 0F93      		push r16
 2837               	.LCFI71:
 2838               		.cfi_def_cfa_offset 5
 2839               		.cfi_offset 16, -4
 2840 0cf6 CF93      		push r28
 2841               	.LCFI72:
 2842               		.cfi_def_cfa_offset 6
 2843               		.cfi_offset 28, -5
 2844 0cf8 DF93      		push r29
 2845               	.LCFI73:
 2846               		.cfi_def_cfa_offset 7
 2847               		.cfi_offset 29, -6
 2848 0cfa 1F92      		push __zero_reg__
 2849               	.LCFI74:
 2850               		.cfi_def_cfa_offset 8
 2851 0cfc CDB7      		in r28,__SP_L__
 2852 0cfe DEB7      		in r29,__SP_H__
 2853               	.LCFI75:
 2854               		.cfi_def_cfa_register 28
 2855               	/* prologue: function */
 2856               	/* frame size = 1 */
 2857               	/* stack size = 6 */
 2858               	.L__stack_usage = 6
 2859 0d00 0983      		std Y+1,r16
 996:draw.c        ****     uint8_t width;
 997:draw.c        ****     uint8_t height;
 998:draw.c        **** 
 999:draw.c        ****     // Get the top left corner of the block in x1, y1, Get the width and
1000:draw.c        ****     // height of the block in the bitblt array.
1001:draw.c        ****     if (x1 > x2)
 2860               		.loc 1 1001 0
 2861 0d02 4817      		cp r20,r24
 2862 0d04 00F4      		brsh .L164
1002:draw.c        ****         swap_bytes (x1, x2);
 2863               		.loc 1 1002 0
 2864 0d06 8427      		eor r24,r20
 2865               	.LVL351:
 2866 0d08 4827      		eor r20,r24
 2867               	.LVL352:
 2868 0d0a 8427      		eor r24,r20
 2869               	.LVL353:
 2870               	.L164:
1003:draw.c        ****     width = 1 + x2 - x1;         // Blit Width
 2871               		.loc 1 1003 0
 2872 0d0c 4F5F      		subi r20,lo8(-(1))
 2873               	.LVL354:
 2874 0d0e 481B      		sub r20,r24
 2875               	.LVL355:
1004:draw.c        **** 
1005:draw.c        ****     if (y1 > y2)
 2876               		.loc 1 1005 0
 2877 0d10 2617      		cp r18,r22
 2878 0d12 00F4      		brsh .L165
1006:draw.c        ****         swap_bytes (y1, y2);
 2879               		.loc 1 1006 0
 2880 0d14 6227      		eor r22,r18
 2881               	.LVL356:
 2882 0d16 2627      		eor r18,r22
 2883               	.LVL357:
 2884 0d18 6227      		eor r22,r18
 2885               	.LVL358:
 2886               	.L165:
 2887               	.LBB78:
1007:draw.c        ****     height = 1 + y2 - y1;         // Blit Height
1008:draw.c        **** 
1009:draw.c        ****     // Use erase mode of bitblt to draw the block.
1010:draw.c        ****     lcd_vbitblt (x1, y1, width, height, MODE_FILL|prefs_reverse, &data);
 2888               		.loc 1 1010 0
 2889 0d1a E091 0000 		lds r30,functabP
 2890 0d1e F091 0000 		lds r31,functabP+1
 2891 0d22 3A96      		adiw r30,10
 2892               	.LVL359:
 2893               	/* #APP */
 2894               	 ;  1010 "draw.c" 1
 2895 0d24 A591      		lpm r26, Z+
 2896 0d26 B491      		lpm r27, Z
 2897               		
 2898               	 ;  0 "" 2
 2899               	.LVL360:
 2900               	/* #NOAPP */
 2901               	.LBE78:
 2902 0d28 0091 0000 		lds r16,prefs+4
 2903               	.LVL361:
 2904 0d2c 0860      		ori r16,lo8(8)
1007:draw.c        ****     height = 1 + y2 - y1;         // Blit Height
 2905               		.loc 1 1007 0
 2906 0d2e 2F5F      		subi r18,lo8(-(1))
 2907               	.LVL362:
 2908 0d30 261B      		sub r18,r22
 2909               	.LVL363:
 2910               		.loc 1 1010 0
 2911 0d32 FE01      		movw r30,r28
 2912 0d34 3196      		adiw r30,1
 2913 0d36 7F01      		movw r14,r30
 2914 0d38 FD01      		movw r30,r26
 2915 0d3a 0995      		icall
 2916               	.LVL364:
 2917               	/* epilogue start */
1011:draw.c        **** }
 2918               		.loc 1 1011 0
 2919 0d3c 0F90      		pop __tmp_reg__
 2920 0d3e DF91      		pop r29
 2921 0d40 CF91      		pop r28
 2922               	.LVL365:
 2923 0d42 0F91      		pop r16
 2924               	.LVL366:
 2925 0d44 FF90      		pop r15
 2926               	.LVL367:
 2927 0d46 EF90      		pop r14
 2928               	.LVL368:
 2929 0d48 0895      		ret
 2930               		.cfi_endproc
 2931               	.LFE22:
 2933               	.global	fill_box
 2935               	fill_box:
 2936               	.LFB23:
1012:draw.c        **** 
1013:draw.c        **** /////////////////////////////////////////////////////////////////////////////
1014:draw.c        **** // Draws a filled box on the screen. The box is described by a diagonal line
1015:draw.c        **** // from x, y1 to x2, y2. The block is filled according to the mode.
1016:draw.c        **** void
1017:draw.c        **** fill_box (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t s_r)
1018:draw.c        **** {
 2937               		.loc 1 1018 0
 2938               		.cfi_startproc
 2939               	.LVL369:
 2940 0d4a EF92      		push r14
 2941               	.LCFI76:
 2942               		.cfi_def_cfa_offset 3
 2943               		.cfi_offset 14, -2
 2944 0d4c FF92      		push r15
 2945               	.LCFI77:
 2946               		.cfi_def_cfa_offset 4
 2947               		.cfi_offset 15, -3
 2948 0d4e 0F93      		push r16
 2949               	.LCFI78:
 2950               		.cfi_def_cfa_offset 5
 2951               		.cfi_offset 16, -4
 2952 0d50 CF93      		push r28
 2953               	.LCFI79:
 2954               		.cfi_def_cfa_offset 6
 2955               		.cfi_offset 28, -5
 2956 0d52 DF93      		push r29
 2957               	.LCFI80:
 2958               		.cfi_def_cfa_offset 7
 2959               		.cfi_offset 29, -6
 2960 0d54 1F92      		push __zero_reg__
 2961               	.LCFI81:
 2962               		.cfi_def_cfa_offset 8
 2963 0d56 CDB7      		in r28,__SP_L__
 2964 0d58 DEB7      		in r29,__SP_H__
 2965               	.LCFI82:
 2966               		.cfi_def_cfa_register 28
 2967               	/* prologue: function */
 2968               	/* frame size = 1 */
 2969               	/* stack size = 6 */
 2970               	.L__stack_usage = 6
1019:draw.c        ****     uint8_t width;
1020:draw.c        ****     uint8_t height;
1021:draw.c        ****     uint8_t data = 0xff;
 2971               		.loc 1 1021 0
 2972 0d5a 9FEF      		ldi r25,lo8(-1)
 2973 0d5c 9983      		std Y+1,r25
1022:draw.c        **** 
1023:draw.c        ****     // Correct the reverse flag
1024:draw.c        ****     s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~MODE_NORMAL_MASK);
 2974               		.loc 1 1024 0
 2975 0d5e 902F      		mov r25,r16
 2976 0d60 9095      		com r25
 2977 0d62 3091 0000 		lds r19,prefs+4
 2978 0d66 9327      		eor r25,r19
 2979 0d68 90FB      		bst r25,0
 2980 0d6a 00F9      		bld r16,0
 2981               	.LVL370:
1025:draw.c        **** 
1026:draw.c        ****     // Get the top left corner of the block in x1, y1, Get the width and
1027:draw.c        ****     // height of the block in the bitblt array.
1028:draw.c        ****     if (x1 > x2)
 2982               		.loc 1 1028 0
 2983 0d6c 4817      		cp r20,r24
 2984 0d6e 00F4      		brsh .L167
1029:draw.c        ****         swap_bytes (x1, x2);
 2985               		.loc 1 1029 0
 2986 0d70 8427      		eor r24,r20
 2987               	.LVL371:
 2988 0d72 4827      		eor r20,r24
 2989               	.LVL372:
 2990 0d74 8427      		eor r24,r20
 2991               	.LVL373:
 2992               	.L167:
1030:draw.c        ****     width = 1 + x2 - x1;                // Blit Width
 2993               		.loc 1 1030 0
 2994 0d76 4F5F      		subi r20,lo8(-(1))
 2995               	.LVL374:
 2996 0d78 481B      		sub r20,r24
 2997               	.LVL375:
1031:draw.c        **** 
1032:draw.c        ****     if (y1 > y2)
 2998               		.loc 1 1032 0
 2999 0d7a 2617      		cp r18,r22
 3000 0d7c 00F4      		brsh .L168
1033:draw.c        ****         swap_bytes (y1, y2);
 3001               		.loc 1 1033 0
 3002 0d7e 6227      		eor r22,r18
 3003               	.LVL376:
 3004 0d80 2627      		eor r18,r22
 3005               	.LVL377:
 3006 0d82 6227      		eor r22,r18
 3007               	.LVL378:
 3008               	.L168:
 3009               	.LBB79:
1034:draw.c        ****     height = 1 + y2 - y1;               // Blit Height
1035:draw.c        **** 
1036:draw.c        ****     // Use erase mode of bitblt to draw the block.
1037:draw.c        ****     lcd_vbitblt (x1, y1, width, height, s_r | MODE_FILL, &data);
 3010               		.loc 1 1037 0
 3011 0d84 E091 0000 		lds r30,functabP
 3012 0d88 F091 0000 		lds r31,functabP+1
 3013 0d8c 3A96      		adiw r30,10
 3014               	.LVL379:
 3015               	/* #APP */
 3016               	 ;  1037 "draw.c" 1
 3017 0d8e A591      		lpm r26, Z+
 3018 0d90 B491      		lpm r27, Z
 3019               		
 3020               	 ;  0 "" 2
 3021               	.LVL380:
 3022               	/* #NOAPP */
 3023               	.LBE79:
 3024 0d92 0860      		ori r16,lo8(8)
 3025               	.LVL381:
1034:draw.c        ****     height = 1 + y2 - y1;               // Blit Height
 3026               		.loc 1 1034 0
 3027 0d94 2F5F      		subi r18,lo8(-(1))
 3028               	.LVL382:
 3029 0d96 261B      		sub r18,r22
 3030               	.LVL383:
 3031               		.loc 1 1037 0
 3032 0d98 FE01      		movw r30,r28
 3033 0d9a 3196      		adiw r30,1
 3034 0d9c 7F01      		movw r14,r30
 3035 0d9e FD01      		movw r30,r26
 3036 0da0 0995      		icall
 3037               	.LVL384:
 3038               	/* epilogue start */
1038:draw.c        **** }
 3039               		.loc 1 1038 0
 3040 0da2 0F90      		pop __tmp_reg__
 3041 0da4 DF91      		pop r29
 3042 0da6 CF91      		pop r28
 3043 0da8 0F91      		pop r16
 3044 0daa FF90      		pop r15
 3045 0dac EF90      		pop r14
 3046 0dae 0895      		ret
 3047               		.cfi_endproc
 3048               	.LFE23:
 3050               	.global	draw_box
 3052               	draw_box:
 3053               	.LFB24:
1039:draw.c        **** 
1040:draw.c        **** /**
1041:draw.c        ****  * Draws a box. The box is described by a diagonal line from x, y1 to x2, y2
1042:draw.c        ****  *
1043:draw.c        ****  * @param x1 The upper left x-coordinate.
1044:draw.c        ****  * @param y1 The upper left y-coordingate.
1045:draw.c        ****  * @param x2 The lower right x-coordinate.
1046:draw.c        ****  * @param y2 The lower right y-coordinate
1047:draw.c        ****  * @param s_r The mode to draw the line
1048:draw.c        ****  */
1049:draw.c        **** void
1050:draw.c        **** draw_box (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t s_r)
1051:draw.c        **** {
 3054               		.loc 1 1051 0
 3055               		.cfi_startproc
 3056               	.LVL385:
 3057 0db0 EF92      		push r14
 3058               	.LCFI83:
 3059               		.cfi_def_cfa_offset 3
 3060               		.cfi_offset 14, -2
 3061 0db2 FF92      		push r15
 3062               	.LCFI84:
 3063               		.cfi_def_cfa_offset 4
 3064               		.cfi_offset 15, -3
 3065 0db4 0F93      		push r16
 3066               	.LCFI85:
 3067               		.cfi_def_cfa_offset 5
 3068               		.cfi_offset 16, -4
 3069 0db6 1F93      		push r17
 3070               	.LCFI86:
 3071               		.cfi_def_cfa_offset 6
 3072               		.cfi_offset 17, -5
 3073 0db8 CF93      		push r28
 3074               	.LCFI87:
 3075               		.cfi_def_cfa_offset 7
 3076               		.cfi_offset 28, -6
 3077 0dba DF93      		push r29
 3078               	.LCFI88:
 3079               		.cfi_def_cfa_offset 8
 3080               		.cfi_offset 29, -7
 3081               	/* prologue: function */
 3082               	/* frame size = 0 */
 3083               	/* stack size = 6 */
 3084               	.L__stack_usage = 6
 3085 0dbc D82F      		mov r29,r24
 3086 0dbe 162F      		mov r17,r22
 3087 0dc0 E42E      		mov r14,r20
 3088 0dc2 C22F      		mov r28,r18
1052:draw.c        ****     if (s_r & MODE_FILL)
 3089               		.loc 1 1052 0
 3090 0dc4 03FF      		sbrs r16,3
 3091 0dc6 00C0      		rjmp .L170
1053:draw.c        ****     {
1054:draw.c        ****         // Invoke the fill
1055:draw.c        ****         fill_box (x1, y1, x2, y2, s_r);
 3092               		.loc 1 1055 0
 3093 0dc8 0E94 0000 		call fill_box
 3094               	.LVL386:
 3095               	/* epilogue start */
1056:draw.c        ****     }
1057:draw.c        ****     else
1058:draw.c        ****     {
1059:draw.c        ****         // Correct the reverse flag and clear any line modes that have been set.
1060:draw.c        ****         s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~(MODE_LINE_MASK|MODE_NORMAL_MAS
1061:draw.c        **** 
1062:draw.c        ****         // Do not over-write the corner pixels multiple times. Detect a box
1063:draw.c        ****         // of width of 2 which requires 2 lines not 4.
1064:draw.c        **** 
1065:draw.c        ****         // Swap the x coordinate if necessary
1066:draw.c        ****         if (x1 > x2)
1067:draw.c        ****             swap_bytes (x1, x2);
1068:draw.c        ****         // Swap the y coordinate if necessary
1069:draw.c        ****         if (y1 > y2)
1070:draw.c        ****             swap_bytes (y1, y2);
1071:draw.c        **** 
1072:draw.c        ****         // Draw a box in a clockwise direction and chain the lines.
1073:draw.c        ****         draw_hline (x1, y1, x2-1, s_r);     // Top horizontal.
1074:draw.c        ****         draw_vline (x2, y1, y2-1, s_r);     // Right vertical.
1075:draw.c        ****         draw_hline (x2, y2, x1+1, s_r);     // Bottom horizontal.
1076:draw.c        ****         draw_vline (x1, y2, y1+1, s_r);     // Left vertical.
1077:draw.c        ****     }
1078:draw.c        **** }
 3096               		.loc 1 1078 0
 3097 0dcc DF91      		pop r29
 3098               	.LVL387:
 3099 0dce CF91      		pop r28
 3100               	.LVL388:
 3101 0dd0 1F91      		pop r17
 3102               	.LVL389:
 3103 0dd2 0F91      		pop r16
 3104               	.LVL390:
 3105 0dd4 FF90      		pop r15
 3106 0dd6 EF90      		pop r14
 3107               	.LVL391:
 3108 0dd8 0895      		ret
 3109               	.LVL392:
 3110               	.L170:
1060:draw.c        ****         s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~(MODE_LINE_MASK|MODE_NORMAL_MAS
 3111               		.loc 1 1060 0
 3112 0dda F02E      		mov r15,r16
 3113 0ddc F094      		com r15
 3114 0dde 8091 0000 		lds r24,prefs+4
 3115               	.LVL393:
 3116 0de2 F826      		eor r15,r24
 3117 0de4 8F2D      		mov r24,r15
 3118 0de6 8170      		andi r24,lo8(1)
 3119 0de8 F82E      		mov r15,r24
 3120 0dea 0E77      		andi r16,lo8(126)
 3121               	.LVL394:
 3122 0dec F02A      		or r15,r16
 3123               	.LVL395:
1066:draw.c        ****         if (x1 > x2)
 3124               		.loc 1 1066 0
 3125 0dee 4D17      		cp r20,r29
 3126 0df0 00F4      		brsh .L172
1067:draw.c        ****             swap_bytes (x1, x2);
 3127               		.loc 1 1067 0
 3128 0df2 D427      		eor r29,r20
 3129               	.LVL396:
 3130 0df4 ED26      		eor r14,r29
 3131               	.LVL397:
 3132 0df6 DE25      		eor r29,r14
 3133               	.LVL398:
 3134               	.L172:
1069:draw.c        ****         if (y1 > y2)
 3135               		.loc 1 1069 0
 3136 0df8 C117      		cp r28,r17
 3137 0dfa 00F4      		brsh .L173
1070:draw.c        ****             swap_bytes (y1, y2);
 3138               		.loc 1 1070 0
 3139 0dfc 1C27      		eor r17,r28
 3140               	.LVL399:
 3141 0dfe C127      		eor r28,r17
 3142               	.LVL400:
 3143 0e00 1C27      		eor r17,r28
 3144               	.LVL401:
 3145               	.L173:
 3146               	.LBB80:
1073:draw.c        ****         draw_hline (x1, y1, x2-1, s_r);     // Top horizontal.
 3147               		.loc 1 1073 0
 3148 0e02 E091 0000 		lds r30,functabP
 3149 0e06 F091 0000 		lds r31,functabP+1
 3150               	.LVL402:
 3151               	/* #APP */
 3152               	 ;  1073 "draw.c" 1
 3153 0e0a A591      		lpm r26, Z+
 3154 0e0c B491      		lpm r27, Z
 3155               		
 3156               	 ;  0 "" 2
 3157               	.LVL403:
 3158               	/* #NOAPP */
 3159               	.LBE80:
 3160 0e0e 4FEF      		ldi r20,lo8(-1)
 3161 0e10 4E0D      		add r20,r14
 3162 0e12 2F2D      		mov r18,r15
 3163 0e14 612F      		mov r22,r17
 3164 0e16 8D2F      		mov r24,r29
 3165 0e18 FD01      		movw r30,r26
 3166 0e1a 0995      		icall
 3167               	.LVL404:
 3168               	.LBB81:
1074:draw.c        ****         draw_vline (x2, y1, y2-1, s_r);     // Right vertical.
 3169               		.loc 1 1074 0
 3170 0e1c E091 0000 		lds r30,functabP
 3171 0e20 F091 0000 		lds r31,functabP+1
 3172 0e24 3C96      		adiw r30,12
 3173               	.LVL405:
 3174               	/* #APP */
 3175               	 ;  1074 "draw.c" 1
 3176 0e26 A591      		lpm r26, Z+
 3177 0e28 B491      		lpm r27, Z
 3178               		
 3179               	 ;  0 "" 2
 3180               	.LVL406:
 3181               	/* #NOAPP */
 3182               	.LBE81:
 3183 0e2a 4FEF      		ldi r20,lo8(-1)
 3184 0e2c 4C0F      		add r20,r28
 3185 0e2e 2F2D      		mov r18,r15
 3186 0e30 612F      		mov r22,r17
 3187 0e32 8E2D      		mov r24,r14
 3188 0e34 FD01      		movw r30,r26
 3189 0e36 0995      		icall
 3190               	.LVL407:
 3191               	.LBB82:
1075:draw.c        ****         draw_hline (x2, y2, x1+1, s_r);     // Bottom horizontal.
 3192               		.loc 1 1075 0
 3193 0e38 E091 0000 		lds r30,functabP
 3194 0e3c F091 0000 		lds r31,functabP+1
 3195               	.LVL408:
 3196               	/* #APP */
 3197               	 ;  1075 "draw.c" 1
 3198 0e40 A591      		lpm r26, Z+
 3199 0e42 B491      		lpm r27, Z
 3200               		
 3201               	 ;  0 "" 2
 3202               	.LVL409:
 3203               	/* #NOAPP */
 3204               	.LBE82:
 3205 0e44 41E0      		ldi r20,lo8(1)
 3206 0e46 4D0F      		add r20,r29
 3207 0e48 2F2D      		mov r18,r15
 3208 0e4a 6C2F      		mov r22,r28
 3209 0e4c 8E2D      		mov r24,r14
 3210 0e4e FD01      		movw r30,r26
 3211 0e50 0995      		icall
 3212               	.LVL410:
 3213               	.LBB83:
1076:draw.c        ****         draw_vline (x1, y2, y1+1, s_r);     // Left vertical.
 3214               		.loc 1 1076 0
 3215 0e52 E091 0000 		lds r30,functabP
 3216 0e56 F091 0000 		lds r31,functabP+1
 3217 0e5a 3C96      		adiw r30,12
 3218               	.LVL411:
 3219               	/* #APP */
 3220               	 ;  1076 "draw.c" 1
 3221 0e5c A591      		lpm r26, Z+
 3222 0e5e B491      		lpm r27, Z
 3223               		
 3224               	 ;  0 "" 2
 3225               	.LVL412:
 3226               	/* #NOAPP */
 3227               	.LBE83:
 3228 0e60 41E0      		ldi r20,lo8(1)
 3229 0e62 410F      		add r20,r17
 3230 0e64 2F2D      		mov r18,r15
 3231 0e66 6C2F      		mov r22,r28
 3232 0e68 8D2F      		mov r24,r29
 3233 0e6a FD01      		movw r30,r26
 3234               	/* epilogue start */
 3235               		.loc 1 1078 0
 3236 0e6c DF91      		pop r29
 3237               	.LVL413:
 3238 0e6e CF91      		pop r28
 3239               	.LVL414:
 3240 0e70 1F91      		pop r17
 3241               	.LVL415:
 3242 0e72 0F91      		pop r16
 3243 0e74 FF90      		pop r15
 3244               	.LVL416:
 3245 0e76 EF90      		pop r14
 3246               	.LVL417:
1076:draw.c        ****         draw_vline (x1, y2, y1+1, s_r);     // Left vertical.
 3247               		.loc 1 1076 0
 3248 0e78 0994      		ijmp
 3249               	.LVL418:
 3250               		.cfi_endproc
 3251               	.LFE24:
 3253               	.global	erase_box
 3255               	erase_box:
 3256               	.LFB25:
1079:draw.c        **** 
1080:draw.c        **** /////////////////////////////////////////////////////////////////////////////
1081:draw.c        **** // Erases a block from the screen. The box is described by a diagonal line
1082:draw.c        **** // from x, y1 to x2, y2. The block is filled according to the mode.
1083:draw.c        **** void
1084:draw.c        **** erase_box (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2)
1085:draw.c        **** {
 3257               		.loc 1 1085 0
 3258               		.cfi_startproc
 3259               	.LVL419:
 3260 0e7a 0F93      		push r16
 3261               	.LCFI89:
 3262               		.cfi_def_cfa_offset 3
 3263               		.cfi_offset 16, -2
 3264               	/* prologue: function */
 3265               	/* frame size = 0 */
 3266               	/* stack size = 1 */
 3267               	.L__stack_usage = 1
1086:draw.c        ****     fill_box (x1, y1, x2, y2, ~prefs_reverse & MODE_NORMAL_MASK);
 3268               		.loc 1 1086 0
 3269 0e7c 0091 0000 		lds r16,prefs+4
 3270 0e80 0095      		com r16
 3271 0e82 0170      		andi r16,lo8(1)
 3272 0e84 0E94 0000 		call fill_box
 3273               	.LVL420:
 3274               	/* epilogue start */
1087:draw.c        **** }
 3275               		.loc 1 1087 0
 3276 0e88 0F91      		pop r16
 3277 0e8a 0895      		ret
 3278               		.cfi_endproc
 3279               	.LFE25:
 3281               	.global	draw_vbitblt
 3283               	draw_vbitblt:
 3284               	.LFB26:
1088:draw.c        **** 
1089:draw.c        **** //////////////////////////////////////////////////////////////////////////////
1090:draw.c        **** /// Vertical bitblt does a bit transfer from data to display memory. If NULL
1091:draw.c        **** /// is passed as data, bitblt assumes the data is to come from the serial
1092:draw.c        **** /// port, and will take it from there. Bitblt will not return until it gets
1093:draw.c        **** /// all the bytes it wants.
1094:draw.c        **** ///
1095:draw.c        **** /// @param [in] x,y is upper left corner of image in pixels. Bitblt counts
1096:draw.c        **** ///             coordinates in the standard fashion. ie (0,0) is upper left,
1097:draw.c        **** ///             +x it to the right +y is down width is width in pixels.
1098:draw.c        **** ///
1099:draw.c        **** /// @param [in] mode determines how the bits in the image combine with the
1100:draw.c        **** ///             bits already present on the display.
1101:draw.c        **** ///
1102:draw.c        **** ///             0x00 - MODE_REVERSE
1103:draw.c        **** ///                    No merge required, reverse the data.
1104:draw.c        **** ///                    buffer[x] = ~read_data
1105:draw.c        **** ///                    Reverse is applied irrespective of the
1106:draw.c        **** ///                    combinational modes (OR, XOR, NAND).
1107:draw.c        **** ///                    So the data is returned un-reversed.
1108:draw.c        **** ///
1109:draw.c        **** ///             0x01 - MODE_COPY
1110:draw.c        **** ///                    No merge required.
1111:draw.c        **** ///                    buffer[x] = read_data
1112:draw.c        **** ///
1113:draw.c        **** ///             0x02 - MODE_OR
1114:draw.c        **** ///                    Merge - OR bits set in buffer
1115:draw.c        **** ///                    buffer[x] = buffer[x] | read_data
1116:draw.c        **** ///
1117:draw.c        **** ///             0x04 - MODE_XOR
1118:draw.c        **** ///                    Merge - XOR bits set in buffer
1119:draw.c        **** ///                    buffer[x] = buffer[x] ^ read_data
1120:draw.c        **** ///
1121:draw.c        **** ///             0x08 - MODE_NAND
1122:draw.c        **** ///                    Merge required - NAND bits cleared in buffer
1123:draw.c        **** ///                    buffer[x] = ~buffer[x] & read_data
1124:draw.c        **** ///
1125:draw.c        **** ///             0x10 - MODE_FILL
1126:draw.c        **** ///                    Interpret the data as a mask and fill.
1127:draw.c        **** void
1128:draw.c        **** draw_vbitblt (uint8_t x, uint8_t y, uint8_t s_r, uint8_t *data)
1129:draw.c        **** {
 3285               		.loc 1 1129 0
 3286               		.cfi_startproc
 3287               	.LVL421:
 3288 0e8c AF92      		push r10
 3289               	.LCFI90:
 3290               		.cfi_def_cfa_offset 3
 3291               		.cfi_offset 10, -2
 3292 0e8e BF92      		push r11
 3293               	.LCFI91:
 3294               		.cfi_def_cfa_offset 4
 3295               		.cfi_offset 11, -3
 3296 0e90 DF92      		push r13
 3297               	.LCFI92:
 3298               		.cfi_def_cfa_offset 5
 3299               		.cfi_offset 13, -4
 3300 0e92 EF92      		push r14
 3301               	.LCFI93:
 3302               		.cfi_def_cfa_offset 6
 3303               		.cfi_offset 14, -5
 3304 0e94 FF92      		push r15
 3305               	.LCFI94:
 3306               		.cfi_def_cfa_offset 7
 3307               		.cfi_offset 15, -6
 3308 0e96 0F93      		push r16
 3309               	.LCFI95:
 3310               		.cfi_def_cfa_offset 8
 3311               		.cfi_offset 16, -7
 3312 0e98 1F93      		push r17
 3313               	.LCFI96:
 3314               		.cfi_def_cfa_offset 9
 3315               		.cfi_offset 17, -8
 3316 0e9a CF93      		push r28
 3317               	.LCFI97:
 3318               		.cfi_def_cfa_offset 10
 3319               		.cfi_offset 28, -9
 3320 0e9c DF93      		push r29
 3321               	.LCFI98:
 3322               		.cfi_def_cfa_offset 11
 3323               		.cfi_offset 29, -10
 3324 0e9e 00D0      		rcall .
 3325               	.LCFI99:
 3326               		.cfi_def_cfa_offset 13
 3327 0ea0 CDB7      		in r28,__SP_L__
 3328 0ea2 DEB7      		in r29,__SP_H__
 3329               	.LCFI100:
 3330               		.cfi_def_cfa_register 28
 3331               	/* prologue: function */
 3332               	/* frame size = 2 */
 3333               	/* stack size = 11 */
 3334               	.L__stack_usage = 11
 3335 0ea4 D82E      		mov r13,r24
 3336 0ea6 5901      		movw r10,r18
1130:draw.c        ****     uint8_t width;                      // Width of the bitmap
1131:draw.c        ****     uint8_t height;                     // Height of the bitmap
1132:draw.c        **** 
1133:draw.c        ****     s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~(MODE_LINE_MASK|MODE_NORMAL_MASK));
 3337               		.loc 1 1133 0
 3338 0ea8 F090 0000 		lds r15,prefs+4
 3339               	.LVL422:
1134:draw.c        **** 
1135:draw.c        ****     // Get the width and the height from the data stream.
1136:draw.c        ****     if (data == NULL)
 3340               		.loc 1 1136 0
 3341 0eac 2115      		cp r18,__zero_reg__
 3342 0eae 3105      		cpc r19,__zero_reg__
 3343 0eb0 01F4      		brne .L177
1137:draw.c        ****     {
1138:draw.c        ****         width = serial_getc();
 3344               		.loc 1 1138 0
 3345 0eb2 4A83      		std Y+2,r20
 3346 0eb4 6983      		std Y+1,r22
 3347 0eb6 0E94 0000 		call serial_getc
 3348               	.LVL423:
 3349 0eba 182F      		mov r17,r24
 3350               	.LVL424:
1139:draw.c        ****         height = serial_getc();
 3351               		.loc 1 1139 0
 3352 0ebc 0E94 0000 		call serial_getc
 3353               	.LVL425:
 3354 0ec0 282F      		mov r18,r24
 3355               	.LVL426:
 3356 0ec2 4A81      		ldd r20,Y+2
 3357 0ec4 6981      		ldd r22,Y+1
 3358 0ec6 00C0      		rjmp .L178
 3359               	.LVL427:
 3360               	.L177:
1140:draw.c        ****     }
1141:draw.c        ****     else
1142:draw.c        ****     {
1143:draw.c        ****         width = *data++;
 3361               		.loc 1 1143 0
 3362 0ec8 F901      		movw r30,r18
 3363 0eca 1081      		ld r17,Z
 3364               	.LVL428:
1144:draw.c        ****         height = *data++;
 3365               		.loc 1 1144 0
 3366 0ecc 2181      		ldd r18,Z+1
 3367               	.LVL429:
 3368 0ece C501      		movw r24,r10
 3369 0ed0 0296      		adiw r24,2
 3370               	.LVL430:
 3371 0ed2 5C01      		movw r10,r24
 3372               	.LVL431:
 3373               	.L178:
1145:draw.c        ****     }
1146:draw.c        **** 
1147:draw.c        ****     // Make sure we have legal dimensions otherwise discard the data.
1148:draw.c        ****     if ((height < 1) || (height > y_dim) ||
 3374               		.loc 1 1148 0
 3375 0ed4 2223      		tst r18
 3376 0ed6 01F0      		breq .L179
 3377               		.loc 1 1148 0 is_stmt 0 discriminator 1
 3378 0ed8 8091 0000 		lds r24,y_dim
 3379 0edc 8217      		cp r24,r18
 3380 0ede 00F0      		brlo .L179
 3381 0ee0 1123      		tst r17
 3382 0ee2 01F0      		breq .L179
1149:draw.c        ****         (width < 1) || (width > x_dim))
 3383               		.loc 1 1149 0 is_stmt 1
 3384 0ee4 8091 0000 		lds r24,x_dim
 3385 0ee8 8117      		cp r24,r17
 3386 0eea 00F4      		brsh .L180
 3387               	.L179:
1150:draw.c        ****     {
1151:draw.c        ****         // If we are reading from serial then consume all of the content from
1152:draw.c        ****         // the serial input.
1153:draw.c        ****         if (data == NULL)
 3388               		.loc 1 1153 0
 3389 0eec AB28      		or r10,r11
 3390 0eee 01F4      		brne .L176
 3391 0ef0 F12C      		mov r15,__zero_reg__
 3392               	.LVL432:
 3393               	.L183:
 3394               	.LBB84:
1154:draw.c        ****         {
1155:draw.c        ****             uint8_t row, col;
1156:draw.c        **** 
1157:draw.c        ****             // Iterate over all of the data that's coming in.
1158:draw.c        ****             for (row = 0; row < height; row++)
 3395               		.loc 1 1158 0 discriminator 1
 3396 0ef2 F216      		cp r15,r18
 3397 0ef4 01F0      		breq .L176
 3398               		.loc 1 1158 0 is_stmt 0
 3399 0ef6 00E0      		ldi r16,0
 3400               	.L186:
 3401               	.LVL433:
1159:draw.c        ****                 for (col = 0; col < width; col++)
 3402               		.loc 1 1159 0 is_stmt 1 discriminator 1
 3403 0ef8 0117      		cp r16,r17
 3404 0efa 01F0      		breq .L193
1160:draw.c        ****                     serial_getc ();
 3405               		.loc 1 1160 0 discriminator 2
 3406 0efc 2983      		std Y+1,r18
 3407 0efe 0E94 0000 		call serial_getc
 3408               	.LVL434:
1159:draw.c        ****                 for (col = 0; col < width; col++)
 3409               		.loc 1 1159 0 discriminator 2
 3410 0f02 0F5F      		subi r16,lo8(-(1))
 3411               	.LVL435:
 3412 0f04 2981      		ldd r18,Y+1
 3413 0f06 00C0      		rjmp .L186
 3414               	.L193:
1158:draw.c        ****             for (row = 0; row < height; row++)
 3415               		.loc 1 1158 0
 3416 0f08 F394      		inc r15
 3417               	.LVL436:
 3418 0f0a 00C0      		rjmp .L183
 3419               	.LVL437:
 3420               	.L180:
 3421               	.LBE84:
 3422               	.LBB85:
1161:draw.c        ****         }
1162:draw.c        **** 
1163:draw.c        ****         // Quit the command there is an error.
1164:draw.c        ****         return;
1165:draw.c        ****     }
1166:draw.c        **** 
1167:draw.c        ****     // Invoke the screen driver to perform the bitblt operation.
1168:draw.c        ****     ((vfunc_iiiiip_t)(pgm_read_word(&functabP [F_DRV_VBITBLT])))(x, y, width, height, s_r, data);
 3423               		.loc 1 1168 0
 3424 0f0c E091 0000 		lds r30,functabP
 3425 0f10 F091 0000 		lds r31,functabP+1
 3426 0f14 3A96      		adiw r30,10
 3427               	.LVL438:
 3428               	/* #APP */
 3429               	 ;  1168 "draw.c" 1
 3430 0f16 A591      		lpm r26, Z+
 3431 0f18 B491      		lpm r27, Z
 3432               		
 3433               	 ;  0 "" 2
 3434               	.LVL439:
 3435               	/* #NOAPP */
 3436               	.LBE85:
1133:draw.c        ****     s_r = ((~s_r ^ prefs_reverse) & MODE_NORMAL_MASK) | (s_r & ~(MODE_LINE_MASK|MODE_NORMAL_MASK));
 3437               		.loc 1 1133 0
 3438 0f1a 042F      		mov r16,r20
 3439 0f1c 0095      		com r16
 3440 0f1e 0F25      		eor r16,r15
 3441 0f20 0170      		andi r16,lo8(1)
 3442 0f22 4E77      		andi r20,lo8(126)
 3443 0f24 042B      		or r16,r20
 3444               		.loc 1 1168 0
 3445 0f26 7501      		movw r14,r10
 3446 0f28 412F      		mov r20,r17
 3447 0f2a 8D2D      		mov r24,r13
 3448 0f2c FD01      		movw r30,r26
 3449 0f2e 0995      		icall
 3450               	.LVL440:
 3451               	.L176:
 3452               	/* epilogue start */
1169:draw.c        **** }
 3453               		.loc 1 1169 0
 3454 0f30 0F90      		pop __tmp_reg__
 3455 0f32 0F90      		pop __tmp_reg__
 3456 0f34 DF91      		pop r29
 3457 0f36 CF91      		pop r28
 3458 0f38 1F91      		pop r17
 3459               	.LVL441:
 3460 0f3a 0F91      		pop r16
 3461 0f3c FF90      		pop r15
 3462 0f3e EF90      		pop r14
 3463 0f40 DF90      		pop r13
 3464               	.LVL442:
 3465 0f42 BF90      		pop r11
 3466 0f44 AF90      		pop r10
 3467               	.LVL443:
 3468 0f46 0895      		ret
 3469               		.cfi_endproc
 3470               	.LFE26:
 3472               		.comm	drawing_mode,1,1
 3473               		.comm	draw_buffer,160,1
 3474               		.comm	line_buffer,16,1
 3475               	.Letext0:
 3476               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 3477               		.file 3 "glcd.h"
DEFINED SYMBOLS
                            *ABS*:00000000 draw.c
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:2      *ABS*:0000003e __SP_H__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:3      *ABS*:0000003d __SP_L__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:4      *ABS*:0000003f __SREG__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:6      *ABS*:00000001 __zero_reg__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:11     .text:00000000 clip_hline
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:98     .text:0000005a clip_vline
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:184    .text:000000b2 _draw_circle
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1048   .text:000005d4 draw_mode
                            *COM*:00000001 drawing_mode
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1065   .text:000005da draw_line
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1515   .text:00000794 draw_lines
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1663   .text:00000812 draw_pixel
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1723   .text:00000854 draw_circle
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1761   .text:0000086a draw_rbox
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:1851   .text:000008b2 draw_polygon
                            *COM*:000000a0 draw_buffer
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:2823   .text:00000cf0 fill_vbox
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:2935   .text:00000d4a fill_box
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:3052   .text:00000db0 draw_box
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:3255   .text:00000e7a erase_box
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccQATt3n.s:3283   .text:00000e8c draw_vbitblt
                            *COM*:00000010 line_buffer

UNDEFINED SYMBOLS
y_dim
x_dim
functabP
prefs
serial_getc
__do_clear_bss
