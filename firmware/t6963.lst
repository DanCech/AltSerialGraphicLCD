   1               		.file	"t6963.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	status_check:
  12               	.LFB11:
  13               		.file 1 "t6963.c"
   1:t6963.c       **** /* -*- c++ -*- **************************************************************
   2:t6963.c       ****  *
   3:t6963.c       ****  *  System        : SerialGLCD
   4:t6963.c       ****  *  Module        : T6963 driver
   5:t6963.c       ****  *  Object Name   : $RCSfile: t6963.c,v $
   6:t6963.c       ****  *  Revision      : $Revision: 1.23 $
   7:t6963.c       ****  *  Date          : $Date: 2015/06/08 20:40:33 $
   8:t6963.c       ****  *  Author        : $Author: jon $
   9:t6963.c       ****  *  Created By    : Jon Green
  10:t6963.c       ****  *  Created       : Thu Apr 16 21:24:20 2015
  11:t6963.c       ****  *  Last Modified : <150608.2140>
  12:t6963.c       ****  *
  13:t6963.c       ****  *  Description   : Toshiba T6963 LCD screen driver.
  14:t6963.c       ****  *
  15:t6963.c       ****  *  Notes         : Ground up implementation of the T6963 driver with some
  16:t6963.c       ****  *                  ispiration from:
  17:t6963.c       ****  *
  18:t6963.c       ****  *                  Code by Mike Hord, SparkFun Electronics.
  19:t6963.c       ****  *
  20:t6963.c       ****  *                  Code by Jennifer Holt
  21:t6963.c       ****  *
  22:t6963.c       ****  *  History       :
  23:t6963.c       ****  *
  24:t6963.c       ****  ****************************************************************************/
  25:t6963.c       **** /****************************************************************************
  26:t6963.c       ****  * t6963.c
  27:t6963.c       ****  *
  28:t6963.c       ****  * t6963 controller driver file. Handles the hardware-level interfacing for
  29:t6963.c       ****  * the t6963 LCD controller.
  30:t6963.c       ****  *
  31:t6963.c       ****  * 02 May 2013 - Mike Hord, SparkFun Electronics
  32:t6963.c       ****  *
  33:t6963.c       ****  * This code is released under the Creative Commons Attribution Share-Alike
  34:t6963.c       ****  * 3.0 license. You are free to reuse, remix, or redistribute it as you see
  35:t6963.c       ****  * fit, so long as you provide attribution to SparkFun Electronics.
  36:t6963.c       ****  ***************************************************************************/
  37:t6963.c       **** /****************************************************************************
  38:t6963.c       ****  * Copyright (c) 2010 Jennifer Holt
  39:t6963.c       ****  * Copyright (c) 2015 Jon Green
  40:t6963.c       ****  *
  41:t6963.c       ****  * This is a ground up implementation of the Sparkfun T6963 driver. which has
  42:t6963.c       ****  * been influenced by the original Sparkfun implementation and the Jennifier
  43:t6963.c       ****  * Holt version of the KS0108b version.
  44:t6963.c       ****  *
  45:t6963.c       ****  * Compared with the Samsung KS0108b this chipset is not so fussy on the
  46:t6963.c       ****  * control line settings and is extreamly fast. The bitblt function was
  47:t6963.c       ****  * derrived from the original implementation of Jennifer Holt and has been
  48:t6963.c       ****  * completely re-designed to deal with the pixels organised as rows rather
  49:t6963.c       ****  * than columns.
  50:t6963.c       ****  *
  51:t6963.c       ****  * Permission is hereby granted, free of charge, to any person obtaining a
  52:t6963.c       ****  * copy of this software and associated documentation files (the "Software"),
  53:t6963.c       ****  * to deal in the Software without restriction, including without limitation
  54:t6963.c       ****  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  55:t6963.c       ****  * and/or sell copies of the Software, and to permit persons to whom the
  56:t6963.c       ****  * Software is furnished to do so, subject to the following conditions:
  57:t6963.c       ****  *
  58:t6963.c       ****  * The above copyright notice and this permission notice shall be included in
  59:t6963.c       ****  * all copies or substantial portions of the Software.
  60:t6963.c       ****  *
  61:t6963.c       ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  62:t6963.c       ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  63:t6963.c       ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  64:t6963.c       ****  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  65:t6963.c       ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  66:t6963.c       ****  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  67:t6963.c       ****  * DEALINGS IN THE SOFTWARE.
  68:t6963.c       ****  ***************************************************************************/
  69:t6963.c       **** 
  70:t6963.c       **** #include <stdlib.h>
  71:t6963.c       **** #include <string.h>
  72:t6963.c       **** 
  73:t6963.c       **** #include <avr/pgmspace.h>
  74:t6963.c       **** #include <avr/io.h>
  75:t6963.c       **** #include <avr/interrupt.h>
  76:t6963.c       **** #include <avr/boot.h>
  77:t6963.c       **** #include "glcd.h"
  78:t6963.c       **** 
  79:t6963.c       **** /* Define the number of columns */
  80:t6963.c       **** #define SCREEN_WIDTH   160               /* Screen width */
  81:t6963.c       **** #define SCREEN_HEIGHT  128               /* Screen height */
  82:t6963.c       **** #define SCREEN_COLUMNS (SCREEN_WIDTH/8)  /* Screen columns */
  83:t6963.c       **** 
  84:t6963.c       **** // Pins for the t6963 (160x128) display
  85:t6963.c       **** #define WR      0       /* PC0 */
  86:t6963.c       **** #define RD      1       /* PC1 */
  87:t6963.c       **** #define CE      2       /* PC2 */
  88:t6963.c       **** #define CD      3       /* PC3 */
  89:t6963.c       **** #define HALT    4       /* PC4 */
  90:t6963.c       **** #define RST     5       /* PC5 */
  91:t6963.c       **** 
  92:t6963.c       **** /* Define the status bits */
  93:t6963.c       **** #define STA0  0x01
  94:t6963.c       **** #define STA1  0x02
  95:t6963.c       **** #define STA01 (STA0|STA1)
  96:t6963.c       **** #define STA2  0x04
  97:t6963.c       **** #define STA3  0x08
  98:t6963.c       **** #define STA5  0x20
  99:t6963.c       **** #define STA6  0x40
 100:t6963.c       **** #define STA7  0x80
 101:t6963.c       **** 
 102:t6963.c       **** /* Macro to define the command and the next status check value */
 103:t6963.c       **** #define DEFCMD(sta,id)             (((sta) << 8) | (id))
 104:t6963.c       **** 
 105:t6963.c       **** /* Registers setting */
 106:t6963.c       **** #define CMD_SET_CURSOR_POINTER     DEFCMD(STA01, 0x21)  /* Set cursor pointer */
 107:t6963.c       **** #define CMD_SET_OFFSET_REGISTER    DEFCMD(STA01, 0x22)  /* Set offset register */
 108:t6963.c       **** #define CMD_SET_ADDR_POINTER       DEFCMD(STA01, 0x24)  /* Set address pointer */
 109:t6963.c       **** /* Set Control Word */
 110:t6963.c       **** #define CMD_SET_TEXT_HOME_ADDR     DEFCMD(STA01, 0x40)  /* Set text home address */
 111:t6963.c       **** #define CMD_SET_TEXT_AREA          DEFCMD(STA01, 0x41)  /* Set text area */
 112:t6963.c       **** #define CMD_SET_GRAPIC_HOME_ADDR   DEFCMD(STA01, 0x42)  /* Set graphic home address */
 113:t6963.c       **** #define CMD_SET_GRAPHIC_AREA       DEFCMD(STA01, 0x43)  /* Set graphic area */
 114:t6963.c       **** /* Mode set */
 115:t6963.c       **** #define CMD_MODE_SET               DEFCMD(STA01, 0x80)  /* Mode Set */
 116:t6963.c       **** #define CMD_MODE_OR                DEFCMD(STA01, 0x80)  /* OR mode */
 117:t6963.c       **** #define CMD_MODE_EXOR              DEFCMD(STA01, 0x81)  /* EXOR mode */
 118:t6963.c       **** #define CMD_MODE_AND               DEFCMD(STA01, 0x83)  /* AND mode */
 119:t6963.c       **** #define CMD_TEXT_ATTRIBUTE_MODE    DEFCMD(STA01, 0x84)  /* Text Attribute mode */
 120:t6963.c       **** #define CMD_INTERNAL_CG_ROM_MODE   DEFCMD(STA01, 0x80)  /* Internal CG ROM mode */
 121:t6963.c       **** #define CMD_EXTERNAL_CG_ROM_MODE   DEFCMD(STA01, 0x88)  /* External CG ROM mode */
 122:t6963.c       **** /* Display mode */
 123:t6963.c       **** #define CMD_DISPLAY_OFF            DEFCMD(STA01, 0x90)  /* Display off */
 124:t6963.c       **** #define CMD_DISPLAY_CURSOR_BLINK   DEFCMD(STA01, 0x92)  /* Cursor on, blink on/off */
 125:t6963.c       **** #define CMD_DISPLAY_TEXT           DEFCMD(STA01, 0x94)  /* Text on, graphic off */
 126:t6963.c       **** #define CMD_DISPLAY_GRAPHIC        DEFCMD(STA01, 0x98)  /* Text off, graphic on */
 127:t6963.c       **** #define CMD_TEXT_GRAPHIC           DEFCMD(STA01, 0x9c)  /* Text on, graphic on */
 128:t6963.c       **** /* Cursor pattern */
 129:t6963.c       **** #define CMD_CURSOR_PATTERN_SELECT  DEFCMD(STA01, 0xa0)  /* Cursor pattern selection */
 130:t6963.c       **** /* Data auto read/write */
 131:t6963.c       **** #define CMD_DATA_AUTO_WRITE        DEFCMD(STA3,  0xb0)  /* Set data auto write */
 132:t6963.c       **** #define CMD_DATA_AUTO_READ         DEFCMD(STA2,  0xb1)  /* Set data auto read */
 133:t6963.c       **** #define CMD_DATA_AUTO_RESET        DEFCMD(STA01, 0xb2)  /* Auto reset */
 134:t6963.c       **** /* Data read/write */
 135:t6963.c       **** #define CMD_DATA_WRITE_INC         DEFCMD(STA01, 0xc0)  /* Data write and increment ADP */
 136:t6963.c       **** #define CMD_DATA_READ_INC          DEFCMD(STA01, 0xc1)  /* Data read abd decrement ADP */
 137:t6963.c       **** #define CMD_DATA_WRITE_DEC         DEFCMD(STA01, 0xc2)  /* Data write and decrement ADP */
 138:t6963.c       **** #define CMD_DATA_READ_DEC          DEFCMD(STA01, 0xc3)  /* Data read and decrement ADP */
 139:t6963.c       **** #define CMD_DATA_WRITE             DEFCMD(STA01, 0xc4)  /* Data write and ADP same */
 140:t6963.c       **** #define CMD_DATA_READ              DEFCMD(STA01, 0xc5)  /* Data read and ADP same */
 141:t6963.c       **** /* Miscellaneous */
 142:t6963.c       **** #define CMD_SCREEN_PEEK            DEFCMD(STA01, 0xe0)  /* Screen peek */
 143:t6963.c       **** #define CMD_SCREEN_COPY            DEFCMD(STA01, 0xe8)  /* Screen copy */
 144:t6963.c       **** #define CMD_BIT_SET_RESET          DEFCMD(STA01, 0xf0)  /* Bit set/reset */
 145:t6963.c       **** 
 146:t6963.c       **** // The next status check value
 147:t6963.c       **** static uint8_t status_value = STA01;
 148:t6963.c       **** 
 149:t6963.c       **** //////////////////////////////////////////////////////////////////////////////
 150:t6963.c       **** /// Perform a STA1 status check. This blocks until the status is set by the
 151:t6963.c       **** /// controller.
 152:t6963.c       **** ///
 153:t6963.c       **** static void
 154:t6963.c       **** status_check (void)
 155:t6963.c       **** {
  14               		.loc 1 155 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
 156:t6963.c       ****     uint8_t expected_status = status_value;   // Let compiler know it is read once!
  20               		.loc 1 156 0
  21 0000 2091 0000 		lds r18,status_value
  22               	.LVL0:
  23               	.L3:
 157:t6963.c       ****     uint8_t bus_status;                       // Status on the bus
 158:t6963.c       **** 
 159:t6963.c       ****     // Status check: Wait for the controller to be ready.
 160:t6963.c       ****     do
 161:t6963.c       ****     {
 162:t6963.c       ****         PORTC &= ~((1 << CE) | (1 << RD));  // Chip enable + read
  24               		.loc 1 162 0 discriminator 1
  25 0004 88B1      		in r24,0x8
  26 0006 897F      		andi r24,lo8(-7)
  27 0008 88B9      		out 0x8,r24
 163:t6963.c       **** 
 164:t6963.c       ****         // We need a minimum 150ns delay here.
 165:t6963.c       ****         DDRB &= ~0x03;                  // Alternative to NOPs
  28               		.loc 1 165 0 discriminator 1
  29 000a 84B1      		in r24,0x4
  30 000c 8C7F      		andi r24,lo8(-4)
  31 000e 84B9      		out 0x4,r24
 166:t6963.c       ****         DDRD &= ~0xfc;
  32               		.loc 1 166 0 discriminator 1
  33 0010 8AB1      		in r24,0xa
  34 0012 8370      		andi r24,lo8(3)
  35 0014 8AB9      		out 0xa,r24
 167:t6963.c       **** 
 168:t6963.c       ****         // Pull the data in.
 169:t6963.c       ****         bus_status = PINB & 0x03;
  36               		.loc 1 169 0 discriminator 1
  37 0016 93B1      		in r25,0x3
  38               	.LVL1:
 170:t6963.c       ****         bus_status |= PIND & 0xfc;
  39               		.loc 1 170 0 discriminator 1
  40 0018 89B1      		in r24,0x9
  41 001a 8C7F      		andi r24,lo8(-4)
 169:t6963.c       ****         bus_status = PINB & 0x03;
  42               		.loc 1 169 0 discriminator 1
  43 001c 9370      		andi r25,lo8(3)
  44               	.LVL2:
  45               		.loc 1 170 0 discriminator 1
  46 001e 892B      		or r24,r25
  47               	.LVL3:
 171:t6963.c       **** 
 172:t6963.c       ****         PORTC |= (1 << CE) | (1 << RD); // Deselect the chip.
  48               		.loc 1 172 0 discriminator 1
  49 0020 98B1      		in r25,0x8
  50 0022 9660      		ori r25,lo8(6)
  51 0024 98B9      		out 0x8,r25
 173:t6963.c       ****     }
 174:t6963.c       ****     while ((bus_status & expected_status) != expected_status);
  52               		.loc 1 174 0 discriminator 1
  53 0026 8223      		and r24,r18
  54               	.LVL4:
  55 0028 8213      		cpse r24,r18
  56 002a 00C0      		rjmp .L3
  57               	/* epilogue start */
 175:t6963.c       **** }
  58               		.loc 1 175 0
  59 002c 0895      		ret
  60               		.cfi_endproc
  61               	.LFE11:
  64               	data_write:
  65               	.LFB12:
 176:t6963.c       **** 
 177:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 178:t6963.c       **** /// Write a data byte to the controller.
 179:t6963.c       **** ///
 180:t6963.c       **** /// @param [in] data The data to write.
 181:t6963.c       **** ///
 182:t6963.c       **** static void
 183:t6963.c       **** data_write (uint8_t data)
 184:t6963.c       **** {
  66               		.loc 1 184 0
  67               		.cfi_startproc
  68               	.LVL5:
  69 002e CF93      		push r28
  70               	.LCFI0:
  71               		.cfi_def_cfa_offset 3
  72               		.cfi_offset 28, -2
  73 0030 DF93      		push r29
  74               	.LCFI1:
  75               		.cfi_def_cfa_offset 4
  76               		.cfi_offset 29, -3
  77 0032 1F92      		push __zero_reg__
  78               	.LCFI2:
  79               		.cfi_def_cfa_offset 5
  80 0034 CDB7      		in r28,__SP_L__
  81 0036 DEB7      		in r29,__SP_H__
  82               	.LCFI3:
  83               		.cfi_def_cfa_register 28
  84               	/* prologue: function */
  85               	/* frame size = 1 */
  86               	/* stack size = 3 */
  87               	.L__stack_usage = 3
 185:t6963.c       ****     // Status check 1: Wait for the controller to be ready.
 186:t6963.c       ****     status_check ();
  88               		.loc 1 186 0
  89 0038 8983      		std Y+1,r24
  90 003a 0E94 0000 		call status_check
  91               	.LVL6:
 187:t6963.c       **** 
 188:t6963.c       ****     // Set the port direction registers to make data pins outputs.
 189:t6963.c       ****     DDRB |= 0x03;
  92               		.loc 1 189 0
  93 003e 94B1      		in r25,0x4
  94 0040 9360      		ori r25,lo8(3)
  95 0042 94B9      		out 0x4,r25
 190:t6963.c       ****     DDRD |= 0xfc;
  96               		.loc 1 190 0
  97 0044 9AB1      		in r25,0xa
  98 0046 9C6F      		ori r25,lo8(-4)
  99 0048 9AB9      		out 0xa,r25
 191:t6963.c       **** 
 192:t6963.c       ****     // Clear PB7:2 and PD1:0 in preparation for data.
 193:t6963.c       ****     PORTD &= 0x03;
 100               		.loc 1 193 0
 101 004a 9BB1      		in r25,0xb
 102 004c 9370      		andi r25,lo8(3)
 103 004e 9BB9      		out 0xb,r25
 194:t6963.c       ****     PORTB &= 0xfc;
 104               		.loc 1 194 0
 105 0050 95B1      		in r25,0x5
 106 0052 9C7F      		andi r25,lo8(-4)
 107 0054 95B9      		out 0x5,r25
 195:t6963.c       **** 
 196:t6963.c       ****     // Set up the data onto the lines.
 197:t6963.c       ****     // Mask off PB1:0 and PD7:2 so we don't change them and then write the
 198:t6963.c       ****     // bits.
 199:t6963.c       ****     PORTB |= data & 0x03;
 108               		.loc 1 199 0
 109 0056 25B1      		in r18,0x5
 110 0058 8981      		ldd r24,Y+1
 111 005a 982F      		mov r25,r24
 112 005c 9370      		andi r25,lo8(3)
 113 005e 922B      		or r25,r18
 114 0060 95B9      		out 0x5,r25
 200:t6963.c       ****     PORTD |= data & 0xfc;
 115               		.loc 1 200 0
 116 0062 9BB1      		in r25,0xb
 117 0064 8C7F      		andi r24,lo8(-4)
 118 0066 892B      		or r24,r25
 119 0068 8BB9      		out 0xb,r24
 201:t6963.c       ****     PORTC &= ~((1 << CD) |              // Data command
 120               		.loc 1 201 0
 121 006a 88B1      		in r24,0x8
 122 006c 827F      		andi r24,lo8(-14)
 123 006e 88B9      		out 0x8,r24
 202:t6963.c       ****                (1 << WR) | (1 << CE));  // Write + Chip enable
 203:t6963.c       **** 
 204:t6963.c       ****     // We need a minimum 80ns delay here.
 205:t6963.c       ****     asm volatile ("nop");
 124               		.loc 1 205 0
 125               	/* #APP */
 126               	 ;  205 "t6963.c" 1
 127 0070 0000      		nop
 128               	 ;  0 "" 2
 206:t6963.c       ****     asm volatile ("nop");
 129               		.loc 1 206 0
 130               	 ;  206 "t6963.c" 1
 131 0072 0000      		nop
 132               	 ;  0 "" 2
 207:t6963.c       **** 
 208:t6963.c       ****     PORTC |= ((1 << WR) | (1 << CE) |   // Deselect the chip
 133               		.loc 1 208 0
 134               	/* #NOAPP */
 135 0074 88B1      		in r24,0x8
 136 0076 8D60      		ori r24,lo8(13)
 137 0078 88B9      		out 0x8,r24
 138               	/* epilogue start */
 209:t6963.c       ****               (1 << CD));               // Set default state.
 210:t6963.c       **** }
 139               		.loc 1 210 0
 140 007a 0F90      		pop __tmp_reg__
 141 007c DF91      		pop r29
 142 007e CF91      		pop r28
 143 0080 0895      		ret
 144               		.cfi_endproc
 145               	.LFE12:
 148               	data_read:
 149               	.LFB13:
 211:t6963.c       **** 
 212:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 213:t6963.c       **** /// Read a data byte from the controller.
 214:t6963.c       **** ///
 215:t6963.c       **** /// @return the byte read from the controller
 216:t6963.c       **** ///
 217:t6963.c       **** static uint8_t
 218:t6963.c       **** data_read (void)
 219:t6963.c       **** {
 150               		.loc 1 219 0
 151               		.cfi_startproc
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
 220:t6963.c       ****     uint8_t data;
 221:t6963.c       **** 
 222:t6963.c       ****     // Status check 1: Wait for the controller to be ready.
 223:t6963.c       ****     status_check ();
 156               		.loc 1 223 0
 157 0082 0E94 0000 		call status_check
 158               	.LVL7:
 224:t6963.c       **** 
 225:t6963.c       ****     // Perform the read
 226:t6963.c       ****     PORTC &= ~((1 << CD) |              // Data transaction
 159               		.loc 1 226 0
 160 0086 88B1      		in r24,0x8
 161 0088 817F      		andi r24,lo8(-15)
 162 008a 88B9      		out 0x8,r24
 227:t6963.c       ****                (1 << CE) | (1 << RD));  // Chip enable + read
 228:t6963.c       **** 
 229:t6963.c       ****     // We need a minimum 150ns delay here.
 230:t6963.c       ****     DDRB &= ~0x03;                      // +62.5ns
 163               		.loc 1 230 0
 164 008c 84B1      		in r24,0x4
 165 008e 8C7F      		andi r24,lo8(-4)
 166 0090 84B9      		out 0x4,r24
 231:t6963.c       ****     DDRD &= ~0xfc;                      // +125.0ns
 167               		.loc 1 231 0
 168 0092 8AB1      		in r24,0xa
 169 0094 8370      		andi r24,lo8(3)
 170 0096 8AB9      		out 0xa,r24
 232:t6963.c       **** 
 233:t6963.c       ****     // Pull the data in.
 234:t6963.c       ****     data = PINB & 0x03;
 171               		.loc 1 234 0
 172 0098 83B1      		in r24,0x3
 173               	.LVL8:
 235:t6963.c       ****     data |= PIND & 0xfc;
 174               		.loc 1 235 0
 175 009a 99B1      		in r25,0x9
 176 009c 9C7F      		andi r25,lo8(-4)
 234:t6963.c       ****     data = PINB & 0x03;
 177               		.loc 1 234 0
 178 009e 8370      		andi r24,lo8(3)
 179               	.LVL9:
 236:t6963.c       **** 
 237:t6963.c       ****     // CD delay 10ns - not required.
 238:t6963.c       ****     // Go back to our known state for the signal lines.
 239:t6963.c       ****     PORTC |= ((1 << CE) | (1 << RD) |   // Deselect the chip.
 180               		.loc 1 239 0
 181 00a0 28B1      		in r18,0x8
 182 00a2 2E60      		ori r18,lo8(14)
 183 00a4 28B9      		out 0x8,r18
 240:t6963.c       ****               (1 << CD));
 241:t6963.c       **** 
 242:t6963.c       ****     // Return the data to the caller.
 243:t6963.c       ****     return data;
 244:t6963.c       **** }
 184               		.loc 1 244 0
 185 00a6 892B      		or r24,r25
 186               	.LVL10:
 187 00a8 0895      		ret
 188               		.cfi_endproc
 189               	.LFE13:
 192               	cmd_write:
 193               	.LFB14:
 245:t6963.c       **** 
 246:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 247:t6963.c       **** /// Write a command to the controller. Note that "reading" a command is
 248:t6963.c       **** /// nonsensical and no cmd_read() function is provided.
 249:t6963.c       **** ///
 250:t6963.c       **** /// @param [in] command The command to write.
 251:t6963.c       **** ///                     The lower 8-bits contain the command.
 252:t6963.c       **** ///                     The upper 8-bits contain next status to be read.
 253:t6963.c       **** ///
 254:t6963.c       **** static void
 255:t6963.c       **** cmd_write (uint16_t command)
 256:t6963.c       **** {
 194               		.loc 1 256 0
 195               		.cfi_startproc
 196               	.LVL11:
 197 00aa CF93      		push r28
 198               	.LCFI4:
 199               		.cfi_def_cfa_offset 3
 200               		.cfi_offset 28, -2
 201 00ac DF93      		push r29
 202               	.LCFI5:
 203               		.cfi_def_cfa_offset 4
 204               		.cfi_offset 29, -3
 205 00ae 00D0      		rcall .
 206               	.LCFI6:
 207               		.cfi_def_cfa_offset 6
 208 00b0 CDB7      		in r28,__SP_L__
 209 00b2 DEB7      		in r29,__SP_H__
 210               	.LCFI7:
 211               		.cfi_def_cfa_register 28
 212               	/* prologue: function */
 213               	/* frame size = 2 */
 214               	/* stack size = 4 */
 215               	.L__stack_usage = 4
 257:t6963.c       ****     // Status check 1: Wait for the controller to be ready.
 258:t6963.c       ****     status_check ();
 216               		.loc 1 258 0
 217 00b4 8983      		std Y+1,r24
 218 00b6 9A83      		std Y+2,r25
 219 00b8 0E94 0000 		call status_check
 220               	.LVL12:
 259:t6963.c       **** 
 260:t6963.c       ****     // Set the port direction registers to make data pins outputs.
 261:t6963.c       ****     DDRB |= 0x03;
 221               		.loc 1 261 0
 222 00bc 24B1      		in r18,0x4
 223 00be 2360      		ori r18,lo8(3)
 224 00c0 24B9      		out 0x4,r18
 262:t6963.c       ****     DDRD |= 0xfc;
 225               		.loc 1 262 0
 226 00c2 2AB1      		in r18,0xa
 227 00c4 2C6F      		ori r18,lo8(-4)
 228 00c6 2AB9      		out 0xa,r18
 263:t6963.c       **** 
 264:t6963.c       ****     // Clear PB7:2 and PD1:0 in preparation for data.
 265:t6963.c       ****     PORTD &= 0x03;
 229               		.loc 1 265 0
 230 00c8 2BB1      		in r18,0xb
 231 00ca 2370      		andi r18,lo8(3)
 232 00cc 2BB9      		out 0xb,r18
 266:t6963.c       ****     PORTB &= 0xfc;
 233               		.loc 1 266 0
 234 00ce 25B1      		in r18,0x5
 235 00d0 2C7F      		andi r18,lo8(-4)
 236 00d2 25B9      		out 0x5,r18
 267:t6963.c       **** 
 268:t6963.c       ****     // Set up the data onto the lines.
 269:t6963.c       ****     // Mask off PB1:0 and PD7:2 so we don't change them and then write the
 270:t6963.c       ****     // bits.
 271:t6963.c       ****     PORTB |= (uint8_t)(command) & 0x03;
 237               		.loc 1 271 0
 238 00d4 35B1      		in r19,0x5
 239 00d6 8981      		ldd r24,Y+1
 240 00d8 282F      		mov r18,r24
 241 00da 2370      		andi r18,lo8(3)
 242 00dc 232B      		or r18,r19
 243 00de 25B9      		out 0x5,r18
 272:t6963.c       ****     PORTD |= (uint8_t)(command) & 0xfc;
 244               		.loc 1 272 0
 245 00e0 2BB1      		in r18,0xb
 246 00e2 8C7F      		andi r24,lo8(-4)
 247 00e4 822B      		or r24,r18
 248 00e6 8BB9      		out 0xb,r24
 273:t6963.c       **** 
 274:t6963.c       ****     // Note we are expecting CD to be set
 275:t6963.c       ****     PORTC &= ~((1 << WR)|(1 << CE));    // Chip enable + write
 249               		.loc 1 275 0
 250 00e8 88B1      		in r24,0x8
 251 00ea 8A7F      		andi r24,lo8(-6)
 252 00ec 88B9      		out 0x8,r24
 276:t6963.c       **** 
 277:t6963.c       ****     // We need a minimum 80ns delay here so we do something useful with our
 278:t6963.c       ****     // time time which is only 2 instructions. Set up the status value for
 279:t6963.c       ****     // this command to be checked next time.
 280:t6963.c       ****     status_value = (command >> 8) & 0xff;
 253               		.loc 1 280 0
 254 00ee 9A81      		ldd r25,Y+2
 255 00f0 9093 0000 		sts status_value,r25
 281:t6963.c       **** 
 282:t6963.c       ****     // Deselect the chip.
 283:t6963.c       ****     PORTC |= ((1 << WR) | (1 << CE));
 256               		.loc 1 283 0
 257 00f4 88B1      		in r24,0x8
 258 00f6 8560      		ori r24,lo8(5)
 259 00f8 88B9      		out 0x8,r24
 260               	/* epilogue start */
 284:t6963.c       ****     // CD delay 10ns - not required.
 285:t6963.c       **** }
 261               		.loc 1 285 0
 262 00fa 0F90      		pop __tmp_reg__
 263 00fc 0F90      		pop __tmp_reg__
 264 00fe DF91      		pop r29
 265 0100 CF91      		pop r28
 266 0102 0895      		ret
 267               		.cfi_endproc
 268               	.LFE14:
 271               	set_pointer:
 272               	.LFB15:
 286:t6963.c       **** 
 287:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 288:t6963.c       **** /// Set the pointer to the byte which contains an arbirary x, y point. For
 289:t6963.c       **** /// our 160 x 128 pixel display, there are 20*128 memory address, so we need
 290:t6963.c       **** /// a 16-bit value address to refer to the whole graphics area array.
 291:t6963.c       **** static void
 292:t6963.c       **** set_pointer (uint8_t x, uint8_t y)
 293:t6963.c       **** {
 273               		.loc 1 293 0
 274               		.cfi_startproc
 275               	.LVL13:
 276 0104 CF93      		push r28
 277               	.LCFI8:
 278               		.cfi_def_cfa_offset 3
 279               		.cfi_offset 28, -2
 280 0106 DF93      		push r29
 281               	.LCFI9:
 282               		.cfi_def_cfa_offset 4
 283               		.cfi_offset 29, -3
 284               	/* prologue: function */
 285               	/* frame size = 0 */
 286               	/* stack size = 2 */
 287               	.L__stack_usage = 2
 294:t6963.c       ****     uint16_t address;
 295:t6963.c       **** 
 296:t6963.c       ****     // Calculate which address in our memory space contains the pixel. For
 297:t6963.c       ****     // each increase in y, we increase by 20 locations. For each 8 pixels in
 298:t6963.c       ****     // x, we increase by one location. Using a 3-right-shift is a cheap way
 299:t6963.c       ****     // of doing divide by 8 in a processor without a divide operation. Maybe
 300:t6963.c       ****     // the compiler knows that, maybe not.
 301:t6963.c       ****     address = (y * SCREEN_COLUMNS) + (x >> 3);
 288               		.loc 1 301 0
 289 0108 8695      		lsr r24
 290 010a 8695      		lsr r24
 291 010c 8695      		lsr r24
 292               	.LVL14:
 293 010e C82F      		mov r28,r24
 294 0110 D0E0      		ldi r29,0
 295 0112 84E1      		ldi r24,lo8(20)
 296 0114 689F      		mul r22,r24
 297 0116 C00D      		add r28,r0
 298 0118 D11D      		adc r29,r1
 299 011a 1124      		clr __zero_reg__
 300               	.LVL15:
 302:t6963.c       **** 
 303:t6963.c       ****     // Now that we have our address, we can write our data out. This is the
 304:t6963.c       ****     // low byte of the address
 305:t6963.c       ****     data_write ((uint8_t)(address & 0xff));
 301               		.loc 1 305 0
 302 011c 8C2F      		mov r24,r28
 303 011e 0E94 0000 		call data_write
 304               	.LVL16:
 306:t6963.c       **** 
 307:t6963.c       ****     // This is the high byte of the address
 308:t6963.c       ****     data_write ((uint8_t)(address >> 8));
 305               		.loc 1 308 0
 306 0122 8D2F      		mov r24,r29
 307 0124 0E94 0000 		call data_write
 308               	.LVL17:
 309:t6963.c       **** 
 310:t6963.c       ****     // This is the command for "set pointer address".
 311:t6963.c       ****     cmd_write (CMD_SET_ADDR_POINTER);
 309               		.loc 1 311 0
 310 0128 84E2      		ldi r24,lo8(36)
 311 012a 93E0      		ldi r25,lo8(3)
 312               	/* epilogue start */
 312:t6963.c       **** }
 313               		.loc 1 312 0
 314 012c DF91      		pop r29
 315 012e CF91      		pop r28
 316               	.LVL18:
 311:t6963.c       ****     cmd_write (CMD_SET_ADDR_POINTER);
 317               		.loc 1 311 0
 318 0130 0C94 0000 		jmp cmd_write
 319               	.LVL19:
 320               		.cfi_endproc
 321               	.LFE15:
 324               	set_column_pointer:
 325               	.LFB16:
 313:t6963.c       **** 
 314:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 315:t6963.c       **** /// Set the pointer to the byte which contains an arbirary x_column, y point.
 316:t6963.c       **** /// For our 160 x 128 pixel display, there are 20*128 memory address, so we
 317:t6963.c       **** /// need a 16-bit value address to refer to the whole graphics area array.
 318:t6963.c       **** static void
 319:t6963.c       **** set_column_pointer (uint8_t x_column, uint8_t y)
 320:t6963.c       **** {
 326               		.loc 1 320 0
 327               		.cfi_startproc
 328               	.LVL20:
 329 0134 CF93      		push r28
 330               	.LCFI10:
 331               		.cfi_def_cfa_offset 3
 332               		.cfi_offset 28, -2
 333 0136 DF93      		push r29
 334               	.LCFI11:
 335               		.cfi_def_cfa_offset 4
 336               		.cfi_offset 29, -3
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 2 */
 340               	.L__stack_usage = 2
 321:t6963.c       ****     uint16_t address;
 322:t6963.c       **** 
 323:t6963.c       ****     // Calculate which address in our memory space contains the pixel. For
 324:t6963.c       ****     // each increase in y, we increase by 20 locations. For each 8 pixels in
 325:t6963.c       ****     // x, we increase by one location. Using a 3-right-shift is a cheap way
 326:t6963.c       ****     // of doing divide by 8 in a processor without a divide operation. Maybe
 327:t6963.c       ****     // the compiler knows that, maybe not.
 328:t6963.c       ****     address = (y * SCREEN_COLUMNS) + x_column;
 341               		.loc 1 328 0
 342 0138 C82F      		mov r28,r24
 343 013a D0E0      		ldi r29,0
 344 013c 84E1      		ldi r24,lo8(20)
 345               	.LVL21:
 346 013e 689F      		mul r22,r24
 347 0140 C00D      		add r28,r0
 348 0142 D11D      		adc r29,r1
 349 0144 1124      		clr __zero_reg__
 350               	.LVL22:
 329:t6963.c       **** 
 330:t6963.c       ****     // Now that we have our address, we can write our data out. This is the
 331:t6963.c       ****     // low byte of the address
 332:t6963.c       ****     data_write ((uint8_t)(address & 0xff));
 351               		.loc 1 332 0
 352 0146 8C2F      		mov r24,r28
 353 0148 0E94 0000 		call data_write
 354               	.LVL23:
 333:t6963.c       **** 
 334:t6963.c       ****     // This is the high byte of the address
 335:t6963.c       ****     data_write ((uint8_t)(address >> 8));
 355               		.loc 1 335 0
 356 014c 8D2F      		mov r24,r29
 357 014e 0E94 0000 		call data_write
 358               	.LVL24:
 336:t6963.c       **** 
 337:t6963.c       ****     // This is the command for "set pointer address".
 338:t6963.c       ****     cmd_write (CMD_SET_ADDR_POINTER);
 359               		.loc 1 338 0
 360 0152 84E2      		ldi r24,lo8(36)
 361 0154 93E0      		ldi r25,lo8(3)
 362               	/* epilogue start */
 339:t6963.c       **** }
 363               		.loc 1 339 0
 364 0156 DF91      		pop r29
 365 0158 CF91      		pop r28
 366               	.LVL25:
 338:t6963.c       ****     cmd_write (CMD_SET_ADDR_POINTER);
 367               		.loc 1 338 0
 368 015a 0C94 0000 		jmp cmd_write
 369               	.LVL26:
 370               		.cfi_endproc
 371               	.LFE16:
 374               	merge_row:
 375               	.LFB22:
 340:t6963.c       **** 
 341:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 342:t6963.c       **** /// Clearing the display. All we're *really* doing is writing a one or zero
 343:t6963.c       **** /// to all the memory locations for the display.
 344:t6963.c       **** ///
 345:t6963.c       **** /// @param [in] mode The mode to clear the screen
 346:t6963.c       **** ///                  0x00 MODE_REVERSE - clears with 1's
 347:t6963.c       **** ///                  0x01 MODE_NORMAL  - clears with 0's
 348:t6963.c       **** void
 349:t6963.c       **** t6963_screen_clear (uint8_t mode)
 350:t6963.c       **** {
 351:t6963.c       ****     uint16_t ii;                        // Local loop counter.
 352:t6963.c       ****     uint8_t data;                       // The data to write to screen.
 353:t6963.c       **** 
 354:t6963.c       ****     // Determine if the screen is reversed or not. In normal mode we write
 355:t6963.c       ****     // 0x00 when reversed we write 0xff. Note: 0x00-0x01 = 0xff !!
 356:t6963.c       ****     data = (mode & MODE_NORMAL_MASK) - 1;
 357:t6963.c       **** 
 358:t6963.c       ****     // Start from the top of memory.
 359:t6963.c       ****     set_pointer (0,0);
 360:t6963.c       **** 
 361:t6963.c       ****     // Clear the whole memory using auto write.
 362:t6963.c       ****     cmd_write (CMD_DATA_AUTO_WRITE);
 363:t6963.c       **** 
 364:t6963.c       ****     // Iterate over all of the data
 365:t6963.c       ****     for (ii = 0; ii < (SCREEN_COLUMNS * SCREEN_HEIGHT); ii++)
 366:t6963.c       ****         data_write (data);
 367:t6963.c       ****     cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 368:t6963.c       **** }
 369:t6963.c       **** 
 370:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 371:t6963.c       **** /// Scroll the display up by 1 character line.
 372:t6963.c       **** ///
 373:t6963.c       **** /// @param [in] buf The buffer to use for reading and writing
 374:t6963.c       **** /// @param [in] pixels The number of pixels to scroll where -ve is up
 375:t6963.c       **** /// @param [in] mode The current mode.
 376:t6963.c       **** ///
 377:t6963.c       **** void
 378:t6963.c       **** t6963_vscroll (uint8_t *buf, int8_t pixels, uint8_t mode)
 379:t6963.c       **** {
 380:t6963.c       ****     uint8_t yy;                         // The y coordinate.
 381:t6963.c       ****     
 382:t6963.c       ****     // TODO: Currently we ignore pixels and simple do -8.
 383:t6963.c       ****     
 384:t6963.c       ****     // Determine if the screen is reversed or not. In normal mode we write
 385:t6963.c       ****     // 0x00 when reversed we write 0xff. Note: 0x00-0x01 = 0xff !!
 386:t6963.c       ****     mode = (mode & MODE_NORMAL_MASK) - 1;
 387:t6963.c       ****     
 388:t6963.c       ****     // Iterate over the whole screen.
 389:t6963.c       ****     for (yy = 0; yy < SCREEN_HEIGHT; yy += 8)
 390:t6963.c       ****     {
 391:t6963.c       ****         uint8_t xx;
 392:t6963.c       ****         
 393:t6963.c       ****         // If we are at the last line then fill with the background colour 
 394:t6963.c       ****         if (yy == (SCREEN_HEIGHT - 8))
 395:t6963.c       ****         {
 396:t6963.c       ****             memset (buf, mode, SCREEN_WIDTH);
 397:t6963.c       ****         }
 398:t6963.c       ****         else
 399:t6963.c       ****         {
 400:t6963.c       ****             // Reset our position to the start of the row.
 401:t6963.c       ****             set_pointer (0, yy + 8);
 402:t6963.c       **** 
 403:t6963.c       ****             // Read in the existing lines.
 404:t6963.c       ****             
 405:t6963.c       ****             // Iterate over a block of data
 406:t6963.c       ****             cmd_write (CMD_DATA_AUTO_READ);
 407:t6963.c       ****             for (xx = 0; xx < SCREEN_WIDTH; xx++)
 408:t6963.c       ****                 buf[xx] = data_read ();
 409:t6963.c       ****             cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 410:t6963.c       ****         }
 411:t6963.c       ****         
 412:t6963.c       ****         // Reset our position to the start of the row.
 413:t6963.c       ****         set_pointer (0, yy);
 414:t6963.c       **** 
 415:t6963.c       ****         // Write the reversed lines.
 416:t6963.c       ****         cmd_write (CMD_DATA_AUTO_WRITE);
 417:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 418:t6963.c       ****             data_write (buf[xx]);
 419:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET); // End of auto mode.
 420:t6963.c       ****     }
 421:t6963.c       **** }
 422:t6963.c       **** 
 423:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 424:t6963.c       **** /// Reverse the display. We read all of the screen values, invert them and
 425:t6963.c       **** /// then write them back.
 426:t6963.c       **** ///
 427:t6963.c       **** /// @param [in] buffer A buffer to use for 8 lines of screen data.
 428:t6963.c       **** ///
 429:t6963.c       **** void
 430:t6963.c       **** t6963_screen_reverse (uint8_t *buf)
 431:t6963.c       **** {
 432:t6963.c       ****     uint16_t yy;                        // Local loop counter.
 433:t6963.c       **** 
 434:t6963.c       ****     // Iterate over the whole screen.
 435:t6963.c       ****     for (yy = 0; yy < SCREEN_HEIGHT; yy += 8)
 436:t6963.c       ****     {
 437:t6963.c       ****         uint8_t xx;
 438:t6963.c       **** 
 439:t6963.c       ****         // Reset our position to the start of the row.
 440:t6963.c       ****         set_pointer (0, yy);
 441:t6963.c       **** 
 442:t6963.c       ****         // Read in the existing lines.
 443:t6963.c       **** 
 444:t6963.c       ****         // Iterate over a block of data
 445:t6963.c       ****         cmd_write (CMD_DATA_AUTO_READ);
 446:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 447:t6963.c       ****             buf[xx] = data_read ();
 448:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 449:t6963.c       **** 
 450:t6963.c       ****         // Reset our position to the start of the row.
 451:t6963.c       ****         set_pointer (0, yy);
 452:t6963.c       **** 
 453:t6963.c       ****         // Write the reversed lines.
 454:t6963.c       ****         cmd_write (CMD_DATA_AUTO_WRITE);
 455:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 456:t6963.c       ****             data_write (~buf[xx]);
 457:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET); // End of auto mode.
 458:t6963.c       ****     }
 459:t6963.c       **** }
 460:t6963.c       **** 
 461:t6963.c       **** ////////////////////////////////////////////////////////////////////////////////////
 462:t6963.c       **** /// First unitialisation of the device. Set up the display hardware.
 463:t6963.c       **** ///
 464:t6963.c       **** void
 465:t6963.c       **** t6963_init (void)
 466:t6963.c       **** {
 467:t6963.c       ****     // Port C is the control
 468:t6963.c       ****     PORTC = ((1<<WR) | (1<<RD) | (1<<CE) | (1<<CD) | (1<<HALT) | (1<<RST));
 469:t6963.c       ****     DDRC =  ((1<<WR) | (1<<RD) | (1<<CE) | (1<<CD) | (1<<HALT) | (1<<RST));
 470:t6963.c       **** 
 471:t6963.c       ****     // Set up the screen size.
 472:t6963.c       ****     x_dim = SCREEN_WIDTH;
 473:t6963.c       ****     y_dim = SCREEN_HEIGHT;
 474:t6963.c       **** 
 475:t6963.c       ****     // The first part of display initialization is to set the start location
 476:t6963.c       ****     // of the graphics in memory. We'll set it to 0x0000.
 477:t6963.c       **** 
 478:t6963.c       ****     // Write the low byte of the graphics home address.
 479:t6963.c       ****     data_write (0x00);
 480:t6963.c       ****     // Write the high byte of the graphics home address.
 481:t6963.c       ****     data_write (0x00);
 482:t6963.c       ****     // "Write graphics home address" command.
 483:t6963.c       ****     cmd_write (CMD_SET_GRAPIC_HOME_ADDR);
 484:t6963.c       **** 
 485:t6963.c       ****     // Next, we need to set the graphics area. This is the length of each
 486:t6963.c       ****     // line before the line wraps to the next one. Note that it does not have
 487:t6963.c       ****     // to equal the actual number of pixels in the display- just equal to or
 488:t6963.c       ****     // greater than.
 489:t6963.c       **** 
 490:t6963.c       ****     // Number of bytes per line (160 pixels/8 bits per byte)
 491:t6963.c       ****     data_write (SCREEN_COLUMNS);
 492:t6963.c       ****     // Always zero.
 493:t6963.c       ****     data_write (0);
 494:t6963.c       ****     // "Write graphics area" command.
 495:t6963.c       ****     cmd_write (CMD_SET_GRAPHIC_AREA);
 496:t6963.c       **** 
 497:t6963.c       ****     // Now we need to write the mode set command; most likely, this is not
 498:t6963.c       ****     //  needed, because the defaults should work, but never trust the defaults.
 499:t6963.c       ****     //  Also, I *think* this only really affects the way text is rendered, and
 500:t6963.c       ****     //  since we're only doing graphics rendering, it probably doesn't matter.
 501:t6963.c       ****     //  Register takes the form
 502:t6963.c       ****     //    1  0  0  0  CG  MD2  MD1  MD0
 503:t6963.c       ****     //  CG -    0   = internal ROM character generation
 504:t6963.c       ****     //          1   = RAM character generation
 505:t6963.c       ****     //  MD2-0 - 000 = OR mode
 506:t6963.c       ****     //          001 = XOR mode
 507:t6963.c       ****     //          010 = AND mode
 508:t6963.c       ****     //          100 = TEXT ATTRIBUTE mode
 509:t6963.c       ****     cmd_write (CMD_MODE_SET);
 510:t6963.c       **** 
 511:t6963.c       ****     // There's a DISPLAY MODE command, too. This seems more likely to be useful
 512:t6963.c       ****     //  to us. The register takes the form
 513:t6963.c       ****     //     1  0  0  1  GRPH  TEXT  CUR  BLK
 514:t6963.c       ****     //  GRPH - 1/0 graphics on/off
 515:t6963.c       ****     //  TEXT - 1/0 text display on/off
 516:t6963.c       ****     //  CUR  - 1/0 text cursor displayed/not displayed
 517:t6963.c       ****     //  BLK  - 1/0 text cursory blink on/off
 518:t6963.c       ****    cmd_write (CMD_DISPLAY_GRAPHIC);
 519:t6963.c       **** }
 520:t6963.c       **** 
 521:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 522:t6963.c       **** /// Set a single pixel. Set assumes that the pixel is being set. This is
 523:t6963.c       **** /// important as the mode flag set to '1' means reverse which is clear a
 524:t6963.c       **** /// pixel. The logic outwardly is reverse from the user interface but it is
 525:t6963.c       **** /// up to the upper levels to resolve this at this level we do not
 526:t6963.c       **** /// interrogate the reverse flag so there is no ambiguity as to what flag is
 527:t6963.c       **** /// applied at what level.
 528:t6963.c       **** ///
 529:t6963.c       **** /// The pixels are in big endian format which is logical and the screen is
 530:t6963.c       **** /// effectivelly addressed from left to right. That means pixel 0,0 occupies
 531:t6963.c       **** /// the most significant bit (bit 7) and is set to 0x80.
 532:t6963.c       **** ///
 533:t6963.c       **** /// @param [in] x_column The column to read (x % 8)
 534:t6963.c       **** /// @param [in] y The row to re-write.
 535:t6963.c       **** /// @param [in] mode Merging modification operation to perform.
 536:t6963.c       **** ///
 537:t6963.c       **** ///             0x00 - MODE_REVERSE
 538:t6963.c       **** ///                    No merge required, reverse the data.
 539:t6963.c       **** ///                    buffer[x] = ~read_data
 540:t6963.c       **** ///                    Reverse is applied irrespective of the
 541:t6963.c       **** ///                    combinational modes (OR, XOR, NAND).
 542:t6963.c       **** ///                    So the data is returned un-reversed.
 543:t6963.c       **** ///
 544:t6963.c       **** ///             0x01 - MODE_COPY
 545:t6963.c       **** ///                    No merge required.
 546:t6963.c       **** ///                    buffer[x] = read_data
 547:t6963.c       **** ///
 548:t6963.c       **** ///             0x86 - MODE_NAND
 549:t6963.c       **** ///                    Merge required - NAND bits cleared in buffer
 550:t6963.c       **** ///                    buffer[x] = ~buffer[x] & read_data
 551:t6963.c       **** ///
 552:t6963.c       **** ///             0x80 - MODE_OR
 553:t6963.c       **** ///                    Merge - OR bits set in buffer
 554:t6963.c       **** ///                    buffer[x] = buffer[x] | read_data
 555:t6963.c       **** ///
 556:t6963.c       **** ///             0x82 - MODE_XOR
 557:t6963.c       **** ///                    Merge - XOR bits set in buffer
 558:t6963.c       **** ///                    buffer[x] = buffer[x] ^ read_data
 559:t6963.c       **** ///
 560:t6963.c       **** void
 561:t6963.c       **** t6963_set_pixel (uint8_t x, uint8_t y, uint8_t mode)
 562:t6963.c       **** {
 563:t6963.c       ****     uint8_t xbit = x & 7;               // The sub-column
 564:t6963.c       ****     
 565:t6963.c       ****     // NOTE: There are savings to be made here as we probably do not always
 566:t6963.c       ****     // need to set the address as we can write 8-pixels with 1 address set.
 567:t6963.c       **** 
 568:t6963.c       ****     // If this is a copy over then simply
 569:t6963.c       ****     if ((mode & MODE_OP_MASK) == 0)
 570:t6963.c       ****     {
 571:t6963.c       ****         uint16_t data;
 572:t6963.c       **** 
 573:t6963.c       ****         // This is a straight forward copy over operation.
 574:t6963.c       **** 
 575:t6963.c       ****         // Step one: select the byte in question.
 576:t6963.c       ****         set_pointer(x, y);
 577:t6963.c       **** 
 578:t6963.c       ****         data = CMD_BIT_SET_RESET;       // Bitset command.
 579:t6963.c       **** 
 580:t6963.c       ****         // Apply any reverse setting
 581:t6963.c       ****         if ((mode & MODE_NORMAL_MASK) != MODE_REVERSE)
 582:t6963.c       ****             data |= 0x08;
 583:t6963.c       **** 
 584:t6963.c       ****         // Figure out which bit we're interested in setting/clearing
 585:t6963.c       ****         data |= 7 - xbit;              // Add the bit index into byte
 586:t6963.c       **** 
 587:t6963.c       ****         cmd_write(data);                // Send the command.
 588:t6963.c       ****     }
 589:t6963.c       ****     else
 590:t6963.c       ****     {
 591:t6963.c       ****         // The caller has requested a modification of the bit based on the
 592:t6963.c       ****         // screen contents. Perform a read-modify-write operation to set the
 593:t6963.c       ****         // pixel to the right value.
 594:t6963.c       ****         //
 595:t6963.c       ****         // Convert x to a column value
 596:t6963.c       ****         // Set data to pixel to write by bit shifting 0 to the top bit.
 597:t6963.c       ****         // Pass the mode in the call
 598:t6963.c       ****         t6963_set_row (x >> 3, y, 0xff, 
 599:t6963.c       ****                        pgm_read_byte(&bit_shift_rev_single_maskP [xbit]), 
 600:t6963.c       ****                        mode | MODE_MERGE);
 601:t6963.c       ****     }
 602:t6963.c       **** }
 603:t6963.c       **** 
 604:t6963.c       **** static __inline__ uint8_t
 605:t6963.c       **** merge_row (uint8_t new_row, uint8_t orig_row, uint8_t mode)
 606:t6963.c       **** {
 376               		.loc 1 606 0
 377               		.cfi_startproc
 378               	.LVL27:
 379               	/* prologue: function */
 380               	/* frame size = 0 */
 381               	/* stack size = 0 */
 382               	.L__stack_usage = 0
 607:t6963.c       ****     // Normalise the mode to retrieve the operator.
 608:t6963.c       ****     mode &= MODE_OP_MASK;
 383               		.loc 1 608 0
 384 015e 942F      		mov r25,r20
 385 0160 9670      		andi r25,lo8(6)
 386               	.LVL28:
 609:t6963.c       **** 
 610:t6963.c       ****     if (mode >= MODE_XOR)
 387               		.loc 1 610 0
 388 0162 9430      		cpi r25,lo8(4)
 389 0164 00F0      		brlo .L11
 390               	.LVL29:
 391               	.LBB5:
 392               	.LBB6:
 611:t6963.c       ****     {
 612:t6963.c       ****         // This is XOR or NAND */
 613:t6963.c       ****         if ((mode & MODE_XOR) != 0)
 393               		.loc 1 613 0
 394 0166 42FF      		sbrs r20,2
 395 0168 00C0      		rjmp .L12
 614:t6963.c       ****         {
 615:t6963.c       ****             // MODE_XOR - XOR the existing buffer data with read data.
 616:t6963.c       ****             new_row ^= orig_row;
 396               		.loc 1 616 0
 397 016a 8627      		eor r24,r22
 398               	.LVL30:
 399 016c 0895      		ret
 400               	.LVL31:
 401               	.L12:
 617:t6963.c       ****         }
 618:t6963.c       ****         else
 619:t6963.c       ****         {
 620:t6963.c       ****             // MODE_NAND - Clear bits according to buffer.
 621:t6963.c       ****             new_row = ~new_row & orig_row;
 402               		.loc 1 621 0
 403 016e 8095      		com r24
 404               	.LVL32:
 405 0170 8623      		and r24,r22
 406               	.LVL33:
 407 0172 0895      		ret
 408               	.LVL34:
 409               	.L11:
 410               	.LBE6:
 411               	.LBE5:
 622:t6963.c       ****         }
 623:t6963.c       ****     }
 624:t6963.c       ****     else
 625:t6963.c       ****     {
 626:t6963.c       ****         // MODE_OR - Set bits according to buffer.
 627:t6963.c       ****         new_row |= orig_row;
 412               		.loc 1 627 0
 413 0174 862B      		or r24,r22
 414               	.LVL35:
 628:t6963.c       ****     }
 629:t6963.c       **** 
 630:t6963.c       ****     // Return the merge to the caller.
 631:t6963.c       ****     return new_row;
 632:t6963.c       **** }
 415               		.loc 1 632 0
 416 0176 0895      		ret
 417               		.cfi_endproc
 418               	.LFE22:
 420               	.global	t6963_screen_clear
 422               	t6963_screen_clear:
 423               	.LFB17:
 350:t6963.c       **** {
 424               		.loc 1 350 0
 425               		.cfi_startproc
 426               	.LVL36:
 427 0178 1F93      		push r17
 428               	.LCFI12:
 429               		.cfi_def_cfa_offset 3
 430               		.cfi_offset 17, -2
 431 017a CF93      		push r28
 432               	.LCFI13:
 433               		.cfi_def_cfa_offset 4
 434               		.cfi_offset 28, -3
 435 017c DF93      		push r29
 436               	.LCFI14:
 437               		.cfi_def_cfa_offset 5
 438               		.cfi_offset 29, -4
 439               	/* prologue: function */
 440               	/* frame size = 0 */
 441               	/* stack size = 3 */
 442               	.L__stack_usage = 3
 356:t6963.c       ****     data = (mode & MODE_NORMAL_MASK) - 1;
 443               		.loc 1 356 0
 444 017e 182F      		mov r17,r24
 445 0180 1170      		andi r17,lo8(1)
 446 0182 1150      		subi r17,lo8(-(-1))
 447               	.LVL37:
 359:t6963.c       ****     set_pointer (0,0);
 448               		.loc 1 359 0
 449 0184 60E0      		ldi r22,0
 450 0186 80E0      		ldi r24,0
 451               	.LVL38:
 452 0188 0E94 0000 		call set_pointer
 453               	.LVL39:
 362:t6963.c       ****     cmd_write (CMD_DATA_AUTO_WRITE);
 454               		.loc 1 362 0
 455 018c 80EB      		ldi r24,lo8(-80)
 456 018e 98E0      		ldi r25,lo8(8)
 457 0190 0E94 0000 		call cmd_write
 458               	.LVL40:
 459 0194 C0E0      		ldi r28,0
 460 0196 DAE0      		ldi r29,lo8(10)
 461               	.LVL41:
 462               	.L17:
 366:t6963.c       ****         data_write (data);
 463               		.loc 1 366 0 discriminator 2
 464 0198 812F      		mov r24,r17
 465 019a 0E94 0000 		call data_write
 466               	.LVL42:
 467 019e 2197      		sbiw r28,1
 468               	.LVL43:
 365:t6963.c       ****     for (ii = 0; ii < (SCREEN_COLUMNS * SCREEN_HEIGHT); ii++)
 469               		.loc 1 365 0 discriminator 2
 470 01a0 2097      		sbiw r28,0
 471 01a2 01F4      		brne .L17
 367:t6963.c       ****     cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 472               		.loc 1 367 0
 473 01a4 82EB      		ldi r24,lo8(-78)
 474 01a6 93E0      		ldi r25,lo8(3)
 475               	/* epilogue start */
 368:t6963.c       **** }
 476               		.loc 1 368 0
 477 01a8 DF91      		pop r29
 478 01aa CF91      		pop r28
 479               	.LVL44:
 480 01ac 1F91      		pop r17
 481               	.LVL45:
 367:t6963.c       ****     cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 482               		.loc 1 367 0
 483 01ae 0C94 0000 		jmp cmd_write
 484               	.LVL46:
 485               		.cfi_endproc
 486               	.LFE17:
 488               	.global	t6963_vscroll
 490               	t6963_vscroll:
 491               	.LFB18:
 379:t6963.c       **** {
 492               		.loc 1 379 0
 493               		.cfi_startproc
 494               	.LVL47:
 495 01b2 AF92      		push r10
 496               	.LCFI15:
 497               		.cfi_def_cfa_offset 3
 498               		.cfi_offset 10, -2
 499 01b4 BF92      		push r11
 500               	.LCFI16:
 501               		.cfi_def_cfa_offset 4
 502               		.cfi_offset 11, -3
 503 01b6 DF92      		push r13
 504               	.LCFI17:
 505               		.cfi_def_cfa_offset 5
 506               		.cfi_offset 13, -4
 507 01b8 EF92      		push r14
 508               	.LCFI18:
 509               		.cfi_def_cfa_offset 6
 510               		.cfi_offset 14, -5
 511 01ba 0F93      		push r16
 512               	.LCFI19:
 513               		.cfi_def_cfa_offset 7
 514               		.cfi_offset 16, -6
 515 01bc 1F93      		push r17
 516               	.LCFI20:
 517               		.cfi_def_cfa_offset 8
 518               		.cfi_offset 17, -7
 519 01be CF93      		push r28
 520               	.LCFI21:
 521               		.cfi_def_cfa_offset 9
 522               		.cfi_offset 28, -8
 523 01c0 DF93      		push r29
 524               	.LCFI22:
 525               		.cfi_def_cfa_offset 10
 526               		.cfi_offset 29, -9
 527               	/* prologue: function */
 528               	/* frame size = 0 */
 529               	/* stack size = 8 */
 530               	.L__stack_usage = 8
 531 01c2 E82E      		mov r14,r24
 532 01c4 D92E      		mov r13,r25
 386:t6963.c       ****     mode = (mode & MODE_NORMAL_MASK) - 1;
 533               		.loc 1 386 0
 534 01c6 4170      		andi r20,lo8(1)
 535               	.LVL48:
 536 01c8 4150      		subi r20,lo8(-(-1))
 537               	.LVL49:
 389:t6963.c       ****     for (yy = 0; yy < SCREEN_HEIGHT; yy += 8)
 538               		.loc 1 389 0
 539 01ca 10E0      		ldi r17,0
 540               	.LBB7:
 396:t6963.c       ****             memset (buf, mode, SCREEN_WIDTH);
 541               		.loc 1 396 0
 542 01cc A42E      		mov r10,r20
 543 01ce B12C      		mov r11,__zero_reg__
 544               	.LVL50:
 545               	.L19:
 394:t6963.c       ****         if (yy == (SCREEN_HEIGHT - 8))
 546               		.loc 1 394 0
 547 01d0 1837      		cpi r17,lo8(120)
 548 01d2 01F4      		brne .L20
 396:t6963.c       ****             memset (buf, mode, SCREEN_WIDTH);
 549               		.loc 1 396 0
 550 01d4 40EA      		ldi r20,lo8(-96)
 551 01d6 50E0      		ldi r21,0
 552 01d8 B501      		movw r22,r10
 553 01da 8E2D      		mov r24,r14
 554 01dc 9D2D      		mov r25,r13
 555 01de 0E94 0000 		call memset
 556               	.LVL51:
 557 01e2 00C0      		rjmp .L21
 558               	.L20:
 559 01e4 68E0      		ldi r22,lo8(8)
 560 01e6 610F      		add r22,r17
 401:t6963.c       ****             set_pointer (0, yy + 8);
 561               		.loc 1 401 0
 562 01e8 80E0      		ldi r24,0
 563 01ea 0E94 0000 		call set_pointer
 564               	.LVL52:
 406:t6963.c       ****             cmd_write (CMD_DATA_AUTO_READ);
 565               		.loc 1 406 0
 566 01ee 81EB      		ldi r24,lo8(-79)
 567 01f0 94E0      		ldi r25,lo8(4)
 568 01f2 0E94 0000 		call cmd_write
 569               	.LVL53:
 570 01f6 CE2D      		mov r28,r14
 571 01f8 DD2D      		mov r29,r13
 572 01fa 00EA      		ldi r16,lo8(-96)
 573               	.LVL54:
 574               	.L23:
 408:t6963.c       ****                 buf[xx] = data_read ();
 575               		.loc 1 408 0 discriminator 2
 576 01fc 0E94 0000 		call data_read
 577               	.LVL55:
 578 0200 8993      		st Y+,r24
 579               	.LVL56:
 580 0202 0150      		subi r16,lo8(-(-1))
 407:t6963.c       ****             for (xx = 0; xx < SCREEN_WIDTH; xx++)
 581               		.loc 1 407 0 discriminator 2
 582 0204 01F4      		brne .L23
 409:t6963.c       ****             cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 583               		.loc 1 409 0
 584 0206 82EB      		ldi r24,lo8(-78)
 585 0208 93E0      		ldi r25,lo8(3)
 586 020a 0E94 0000 		call cmd_write
 587               	.LVL57:
 588               	.L21:
 413:t6963.c       ****         set_pointer (0, yy);
 589               		.loc 1 413 0
 590 020e 612F      		mov r22,r17
 591 0210 80E0      		ldi r24,0
 592 0212 0E94 0000 		call set_pointer
 593               	.LVL58:
 416:t6963.c       ****         cmd_write (CMD_DATA_AUTO_WRITE);
 594               		.loc 1 416 0
 595 0216 80EB      		ldi r24,lo8(-80)
 596 0218 98E0      		ldi r25,lo8(8)
 597 021a 0E94 0000 		call cmd_write
 598               	.LVL59:
 599 021e CE2D      		mov r28,r14
 600 0220 DD2D      		mov r29,r13
 601 0222 00EA      		ldi r16,lo8(-96)
 602               	.LVL60:
 603               	.L25:
 418:t6963.c       ****             data_write (buf[xx]);
 604               		.loc 1 418 0 discriminator 2
 605 0224 8991      		ld r24,Y+
 606               	.LVL61:
 607 0226 0E94 0000 		call data_write
 608               	.LVL62:
 609 022a 0150      		subi r16,lo8(-(-1))
 417:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 610               		.loc 1 417 0 discriminator 2
 611 022c 01F4      		brne .L25
 419:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET); // End of auto mode.
 612               		.loc 1 419 0
 613 022e 82EB      		ldi r24,lo8(-78)
 614 0230 93E0      		ldi r25,lo8(3)
 615 0232 0E94 0000 		call cmd_write
 616               	.LVL63:
 617               	.LBE7:
 389:t6963.c       ****     for (yy = 0; yy < SCREEN_HEIGHT; yy += 8)
 618               		.loc 1 389 0
 619 0236 185F      		subi r17,lo8(-(8))
 620               	.LVL64:
 621 0238 1038      		cpi r17,lo8(-128)
 622 023a 01F4      		brne .L19
 623               	/* epilogue start */
 421:t6963.c       **** }
 624               		.loc 1 421 0
 625 023c DF91      		pop r29
 626 023e CF91      		pop r28
 627               	.LVL65:
 628 0240 1F91      		pop r17
 629               	.LVL66:
 630 0242 0F91      		pop r16
 631 0244 EF90      		pop r14
 632 0246 DF90      		pop r13
 633 0248 BF90      		pop r11
 634 024a AF90      		pop r10
 635               	.LVL67:
 636 024c 0895      		ret
 637               		.cfi_endproc
 638               	.LFE18:
 640               	.global	t6963_screen_reverse
 642               	t6963_screen_reverse:
 643               	.LFB19:
 431:t6963.c       **** {
 644               		.loc 1 431 0
 645               		.cfi_startproc
 646               	.LVL68:
 647 024e EF92      		push r14
 648               	.LCFI23:
 649               		.cfi_def_cfa_offset 3
 650               		.cfi_offset 14, -2
 651 0250 FF92      		push r15
 652               	.LCFI24:
 653               		.cfi_def_cfa_offset 4
 654               		.cfi_offset 15, -3
 655 0252 0F93      		push r16
 656               	.LCFI25:
 657               		.cfi_def_cfa_offset 5
 658               		.cfi_offset 16, -4
 659 0254 1F93      		push r17
 660               	.LCFI26:
 661               		.cfi_def_cfa_offset 6
 662               		.cfi_offset 17, -5
 663 0256 CF93      		push r28
 664               	.LCFI27:
 665               		.cfi_def_cfa_offset 7
 666               		.cfi_offset 28, -6
 667 0258 DF93      		push r29
 668               	.LCFI28:
 669               		.cfi_def_cfa_offset 8
 670               		.cfi_offset 29, -7
 671               	/* prologue: function */
 672               	/* frame size = 0 */
 673               	/* stack size = 6 */
 674               	.L__stack_usage = 6
 675 025a F82E      		mov r15,r24
 676 025c E92E      		mov r14,r25
 677               	.LVL69:
 431:t6963.c       **** {
 678               		.loc 1 431 0
 679 025e 10E0      		ldi r17,0
 680               	.LVL70:
 681               	.L33:
 682               	.LBB8:
 440:t6963.c       ****         set_pointer (0, yy);
 683               		.loc 1 440 0
 684 0260 612F      		mov r22,r17
 685 0262 80E0      		ldi r24,0
 686 0264 0E94 0000 		call set_pointer
 687               	.LVL71:
 445:t6963.c       ****         cmd_write (CMD_DATA_AUTO_READ);
 688               		.loc 1 445 0
 689 0268 81EB      		ldi r24,lo8(-79)
 690 026a 94E0      		ldi r25,lo8(4)
 691 026c 0E94 0000 		call cmd_write
 692               	.LVL72:
 693 0270 CF2D      		mov r28,r15
 694 0272 DE2D      		mov r29,r14
 695 0274 00EA      		ldi r16,lo8(-96)
 696               	.LVL73:
 697               	.L29:
 447:t6963.c       ****             buf[xx] = data_read ();
 698               		.loc 1 447 0 discriminator 2
 699 0276 0E94 0000 		call data_read
 700               	.LVL74:
 701 027a 8993      		st Y+,r24
 702               	.LVL75:
 703 027c 0150      		subi r16,lo8(-(-1))
 446:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 704               		.loc 1 446 0 discriminator 2
 705 027e 01F4      		brne .L29
 448:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);  // End of auto mode.
 706               		.loc 1 448 0
 707 0280 82EB      		ldi r24,lo8(-78)
 708 0282 93E0      		ldi r25,lo8(3)
 709 0284 0E94 0000 		call cmd_write
 710               	.LVL76:
 451:t6963.c       ****         set_pointer (0, yy);
 711               		.loc 1 451 0
 712 0288 612F      		mov r22,r17
 713 028a 80E0      		ldi r24,0
 714 028c 0E94 0000 		call set_pointer
 715               	.LVL77:
 454:t6963.c       ****         cmd_write (CMD_DATA_AUTO_WRITE);
 716               		.loc 1 454 0
 717 0290 80EB      		ldi r24,lo8(-80)
 718 0292 98E0      		ldi r25,lo8(8)
 719 0294 0E94 0000 		call cmd_write
 720               	.LVL78:
 721 0298 CF2D      		mov r28,r15
 722 029a DE2D      		mov r29,r14
 723 029c 00EA      		ldi r16,lo8(-96)
 724               	.LVL79:
 725               	.L31:
 456:t6963.c       ****             data_write (~buf[xx]);
 726               		.loc 1 456 0 discriminator 2
 727 029e 8991      		ld r24,Y+
 728               	.LVL80:
 729 02a0 8095      		com r24
 730 02a2 0E94 0000 		call data_write
 731               	.LVL81:
 732 02a6 0150      		subi r16,lo8(-(-1))
 455:t6963.c       ****         for (xx = 0; xx < SCREEN_WIDTH; xx++)
 733               		.loc 1 455 0 discriminator 2
 734 02a8 01F4      		brne .L31
 457:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET); // End of auto mode.
 735               		.loc 1 457 0
 736 02aa 82EB      		ldi r24,lo8(-78)
 737 02ac 93E0      		ldi r25,lo8(3)
 738 02ae 0E94 0000 		call cmd_write
 739               	.LVL82:
 740 02b2 185F      		subi r17,lo8(-(8))
 741               	.LBE8:
 435:t6963.c       ****     for (yy = 0; yy < SCREEN_HEIGHT; yy += 8)
 742               		.loc 1 435 0
 743 02b4 1038      		cpi r17,lo8(-128)
 744 02b6 01F4      		brne .L33
 745               	/* epilogue start */
 459:t6963.c       **** }
 746               		.loc 1 459 0
 747 02b8 DF91      		pop r29
 748 02ba CF91      		pop r28
 749               	.LVL83:
 750 02bc 1F91      		pop r17
 751 02be 0F91      		pop r16
 752 02c0 FF90      		pop r15
 753 02c2 EF90      		pop r14
 754 02c4 0895      		ret
 755               		.cfi_endproc
 756               	.LFE19:
 758               	.global	t6963_init
 760               	t6963_init:
 761               	.LFB20:
 466:t6963.c       **** {
 762               		.loc 1 466 0
 763               		.cfi_startproc
 764               	/* prologue: function */
 765               	/* frame size = 0 */
 766               	/* stack size = 0 */
 767               	.L__stack_usage = 0
 468:t6963.c       ****     PORTC = ((1<<WR) | (1<<RD) | (1<<CE) | (1<<CD) | (1<<HALT) | (1<<RST));
 768               		.loc 1 468 0
 769 02c6 8FE3      		ldi r24,lo8(63)
 770 02c8 88B9      		out 0x8,r24
 469:t6963.c       ****     DDRC =  ((1<<WR) | (1<<RD) | (1<<CE) | (1<<CD) | (1<<HALT) | (1<<RST));
 771               		.loc 1 469 0
 772 02ca 87B9      		out 0x7,r24
 472:t6963.c       ****     x_dim = SCREEN_WIDTH;
 773               		.loc 1 472 0
 774 02cc 80EA      		ldi r24,lo8(-96)
 775 02ce 8093 0000 		sts x_dim,r24
 473:t6963.c       ****     y_dim = SCREEN_HEIGHT;
 776               		.loc 1 473 0
 777 02d2 80E8      		ldi r24,lo8(-128)
 778 02d4 8093 0000 		sts y_dim,r24
 479:t6963.c       ****     data_write (0x00);
 779               		.loc 1 479 0
 780 02d8 80E0      		ldi r24,0
 781 02da 0E94 0000 		call data_write
 782               	.LVL84:
 481:t6963.c       ****     data_write (0x00);
 783               		.loc 1 481 0
 784 02de 80E0      		ldi r24,0
 785 02e0 0E94 0000 		call data_write
 786               	.LVL85:
 483:t6963.c       ****     cmd_write (CMD_SET_GRAPIC_HOME_ADDR);
 787               		.loc 1 483 0
 788 02e4 82E4      		ldi r24,lo8(66)
 789 02e6 93E0      		ldi r25,lo8(3)
 790 02e8 0E94 0000 		call cmd_write
 791               	.LVL86:
 491:t6963.c       ****     data_write (SCREEN_COLUMNS);
 792               		.loc 1 491 0
 793 02ec 84E1      		ldi r24,lo8(20)
 794 02ee 0E94 0000 		call data_write
 795               	.LVL87:
 493:t6963.c       ****     data_write (0);
 796               		.loc 1 493 0
 797 02f2 80E0      		ldi r24,0
 798 02f4 0E94 0000 		call data_write
 799               	.LVL88:
 495:t6963.c       ****     cmd_write (CMD_SET_GRAPHIC_AREA);
 800               		.loc 1 495 0
 801 02f8 83E4      		ldi r24,lo8(67)
 802 02fa 93E0      		ldi r25,lo8(3)
 803 02fc 0E94 0000 		call cmd_write
 804               	.LVL89:
 509:t6963.c       ****     cmd_write (CMD_MODE_SET);
 805               		.loc 1 509 0
 806 0300 80E8      		ldi r24,lo8(-128)
 807 0302 93E0      		ldi r25,lo8(3)
 808 0304 0E94 0000 		call cmd_write
 809               	.LVL90:
 518:t6963.c       ****    cmd_write (CMD_DISPLAY_GRAPHIC);
 810               		.loc 1 518 0
 811 0308 88E9      		ldi r24,lo8(-104)
 812 030a 93E0      		ldi r25,lo8(3)
 813 030c 0C94 0000 		jmp cmd_write
 814               	.LVL91:
 815               		.cfi_endproc
 816               	.LFE20:
 818               	.global	t6963_read_row
 820               	t6963_read_row:
 821               	.LFB23:
 633:t6963.c       **** 
 634:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 635:t6963.c       **** /// Read a row of from the display.
 636:t6963.c       **** /// The row is read colum wise where x will start at (x & 0xf8)
 637:t6963.c       **** ///
 638:t6963.c       **** /// @param [in] x_column The column to read (x % 8)
 639:t6963.c       **** /// @param [in] y The row to read.
 640:t6963.c       **** /// @param [in] length The number of columns to read.
 641:t6963.c       **** /// @param [in] buf Location to read into.
 642:t6963.c       **** /// @param [in] mode Merging modification operation to perform.
 643:t6963.c       **** ///
 644:t6963.c       **** ///             0x00 - MODE_REVERSE
 645:t6963.c       **** ///                    No merge required, reverse the data.
 646:t6963.c       **** ///                    buffer[x] = ~read_data
 647:t6963.c       **** ///                    Reverse is applied irrespective of the
 648:t6963.c       **** ///                    combinational modes (OR, XOR, NAND).
 649:t6963.c       **** ///                    So the data is returned un-reversed.
 650:t6963.c       **** ///
 651:t6963.c       **** ///             0x01 - MODE_COPY
 652:t6963.c       **** ///                    No merge required.
 653:t6963.c       **** ///                    buffer[x] = read_data
 654:t6963.c       **** ///
 655:t6963.c       **** ///             0x86 - MODE_NAND
 656:t6963.c       **** ///                    Merge required - NAND bits cleared in buffer
 657:t6963.c       **** ///                    buffer[x] = ~buffer[x] & read_data
 658:t6963.c       **** ///
 659:t6963.c       **** ///             0x80 - MODE_OR
 660:t6963.c       **** ///                    Merge - OR bits set in buffer
 661:t6963.c       **** ///                    buffer[x] = buffer[x] | read_data
 662:t6963.c       **** ///
 663:t6963.c       **** ///             0x82 - MODE_XOR
 664:t6963.c       **** ///                    Merge - XOR bits set in buffer
 665:t6963.c       **** ///                    buffer[x] = buffer[x] ^ read_data
 666:t6963.c       **** ///
 667:t6963.c       **** void
 668:t6963.c       **** t6963_read_row (uint8_t x_column, uint8_t y, uint16_t length, uint8_t *buf, uint8_t mode)
 669:t6963.c       **** {
 822               		.loc 1 669 0
 823               		.cfi_startproc
 824               	.LVL92:
 825 0310 DF92      		push r13
 826               	.LCFI29:
 827               		.cfi_def_cfa_offset 3
 828               		.cfi_offset 13, -2
 829 0312 EF92      		push r14
 830               	.LCFI30:
 831               		.cfi_def_cfa_offset 4
 832               		.cfi_offset 14, -3
 833 0314 FF92      		push r15
 834               	.LCFI31:
 835               		.cfi_def_cfa_offset 5
 836               		.cfi_offset 15, -4
 837 0316 0F93      		push r16
 838               	.LCFI32:
 839               		.cfi_def_cfa_offset 6
 840               		.cfi_offset 16, -5
 841 0318 1F93      		push r17
 842               	.LCFI33:
 843               		.cfi_def_cfa_offset 7
 844               		.cfi_offset 17, -6
 845 031a CF93      		push r28
 846               	.LCFI34:
 847               		.cfi_def_cfa_offset 8
 848               		.cfi_offset 28, -7
 849 031c DF93      		push r29
 850               	.LCFI35:
 851               		.cfi_def_cfa_offset 9
 852               		.cfi_offset 29, -8
 853               	/* prologue: function */
 854               	/* frame size = 0 */
 855               	/* stack size = 7 */
 856               	.L__stack_usage = 7
 857 031e 7A01      		movw r14,r20
 858 0320 E901      		movw r28,r18
 670:t6963.c       ****     uint8_t data;
 671:t6963.c       **** 
 672:t6963.c       ****     // This sets our pointer to the location containing
 673:t6963.c       ****     set_column_pointer (x_column, y);
 859               		.loc 1 673 0
 860 0322 0E94 0000 		call set_column_pointer
 861               	.LVL93:
 674:t6963.c       **** 
 675:t6963.c       ****     // Use a different command depending on how many bytes are being read.
 676:t6963.c       ****     // For a length of 1 then simply perform a single read command. If the
 677:t6963.c       ****     // length is >= 2 then it is quicker to perform an auto read function.
 678:t6963.c       ****     if (length == 1)
 862               		.loc 1 678 0
 863 0326 81E0      		ldi r24,1
 864 0328 E816      		cp r14,r24
 865 032a F104      		cpc r15,__zero_reg__
 866 032c 01F4      		brne .L36
 679:t6963.c       ****     {
 680:t6963.c       ****         cmd_write (CMD_DATA_READ);      // A non-incrementing read.
 867               		.loc 1 680 0
 868 032e 85EC      		ldi r24,lo8(-59)
 869 0330 93E0      		ldi r25,lo8(3)
 870 0332 0E94 0000 		call cmd_write
 871               	.LVL94:
 681:t6963.c       ****         data = data_read();             // Get the data from controller
 872               		.loc 1 681 0
 873 0336 0E94 0000 		call data_read
 874               	.LVL95:
 682:t6963.c       **** 
 683:t6963.c       ****         // Apply any reverse setting.
 684:t6963.c       ****         if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 875               		.loc 1 684 0
 876 033a 00FF      		sbrs r16,0
 685:t6963.c       ****             data = ~data;
 877               		.loc 1 685 0
 878 033c 8095      		com r24
 879               	.LVL96:
 880               	.L37:
 686:t6963.c       **** 
 687:t6963.c       ****         // Handle any buffer merging on the read.
 688:t6963.c       ****         if ((mode & MODE_MODIFIER) != 0)
 881               		.loc 1 688 0
 882 033e 902F      		mov r25,r16
 883 0340 9671      		andi r25,lo8(22)
 884 0342 01F0      		breq .L38
 689:t6963.c       ****             data = merge_row (*buf, data, mode);
 885               		.loc 1 689 0
 886 0344 402F      		mov r20,r16
 887 0346 682F      		mov r22,r24
 888 0348 8881      		ld r24,Y
 889               	.LVL97:
 890 034a 0E94 0000 		call merge_row
 891               	.LVL98:
 892               	.L38:
 690:t6963.c       **** 
 691:t6963.c       ****         // Assign the data to the buffer.
 692:t6963.c       ****         *buf = data;
 893               		.loc 1 692 0
 894 034e 8883      		st Y,r24
 895               	/* epilogue start */
 693:t6963.c       ****     }
 694:t6963.c       ****     else
 695:t6963.c       ****     {
 696:t6963.c       ****         int ii;
 697:t6963.c       **** 
 698:t6963.c       ****         // Perform an auto read to collect the data.
 699:t6963.c       ****         cmd_write (CMD_DATA_AUTO_READ);
 700:t6963.c       **** 
 701:t6963.c       ****         // Iterate over all of the data
 702:t6963.c       ****         for (ii = 0; ii < length; ii++)
 703:t6963.c       ****         {
 704:t6963.c       ****             data = data_read();         // Pick up the data
 705:t6963.c       **** 
 706:t6963.c       ****             // Reverse the data if required.
 707:t6963.c       ****             if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 708:t6963.c       ****                 data = ~data;
 709:t6963.c       ****             
 710:t6963.c       ****             // Handle any buffer merging on the read.
 711:t6963.c       ****             if ((mode & MODE_MODIFIER) != 0)
 712:t6963.c       ****                 data = merge_row (buf[ii], data, mode);
 713:t6963.c       **** 
 714:t6963.c       ****             // Assign the data to the buffer.
 715:t6963.c       ****             buf[ii] = data;
 716:t6963.c       ****         }
 717:t6963.c       ****         // End of auto mode
 718:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);
 719:t6963.c       ****     }
 720:t6963.c       **** }
 896               		.loc 1 720 0
 897 0350 DF91      		pop r29
 898 0352 CF91      		pop r28
 899               	.LVL99:
 900 0354 1F91      		pop r17
 901 0356 0F91      		pop r16
 902               	.LVL100:
 903 0358 FF90      		pop r15
 904 035a EF90      		pop r14
 905               	.LVL101:
 906 035c DF90      		pop r13
 907 035e 0895      		ret
 908               	.LVL102:
 909               	.L36:
 910               	.LBB9:
 699:t6963.c       ****         cmd_write (CMD_DATA_AUTO_READ);
 911               		.loc 1 699 0
 912 0360 81EB      		ldi r24,lo8(-79)
 913 0362 94E0      		ldi r25,lo8(4)
 914 0364 0E94 0000 		call cmd_write
 915               	.LVL103:
 916 0368 EC0E      		add r14,r28
 917 036a FD1E      		adc r15,r29
 918               	.LVL104:
 707:t6963.c       ****             if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 919               		.loc 1 707 0
 920 036c 102F      		mov r17,r16
 921 036e 1170      		andi r17,lo8(1)
 711:t6963.c       ****             if ((mode & MODE_MODIFIER) != 0)
 922               		.loc 1 711 0
 923 0370 802F      		mov r24,r16
 924 0372 8671      		andi r24,lo8(22)
 925 0374 D82E      		mov r13,r24
 926               	.LVL105:
 927               	.L40:
 702:t6963.c       ****         for (ii = 0; ii < length; ii++)
 928               		.loc 1 702 0 discriminator 1
 929 0376 CE15      		cp r28,r14
 930 0378 DF05      		cpc r29,r15
 931 037a 01F0      		breq .L51
 704:t6963.c       ****             data = data_read();         // Pick up the data
 932               		.loc 1 704 0
 933 037c 0E94 0000 		call data_read
 934               	.LVL106:
 707:t6963.c       ****             if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 935               		.loc 1 707 0
 936 0380 1111      		cpse r17,__zero_reg__
 937 0382 00C0      		rjmp .L41
 708:t6963.c       ****                 data = ~data;
 938               		.loc 1 708 0
 939 0384 8095      		com r24
 940               	.LVL107:
 941               	.L41:
 711:t6963.c       ****             if ((mode & MODE_MODIFIER) != 0)
 942               		.loc 1 711 0
 943 0386 DD20      		tst r13
 944 0388 01F0      		breq .L42
 712:t6963.c       ****                 data = merge_row (buf[ii], data, mode);
 945               		.loc 1 712 0
 946 038a 402F      		mov r20,r16
 947 038c 682F      		mov r22,r24
 948 038e 8881      		ld r24,Y
 949               	.LVL108:
 950 0390 0E94 0000 		call merge_row
 951               	.LVL109:
 952               	.L42:
 715:t6963.c       ****             buf[ii] = data;
 953               		.loc 1 715 0
 954 0394 8993      		st Y+,r24
 955               	.LVL110:
 956 0396 00C0      		rjmp .L40
 957               	.LVL111:
 958               	.L51:
 718:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);
 959               		.loc 1 718 0
 960 0398 82EB      		ldi r24,lo8(-78)
 961 039a 93E0      		ldi r25,lo8(3)
 962               	/* epilogue start */
 963               	.LBE9:
 964               		.loc 1 720 0
 965 039c DF91      		pop r29
 966 039e CF91      		pop r28
 967               	.LVL112:
 968 03a0 1F91      		pop r17
 969 03a2 0F91      		pop r16
 970               	.LVL113:
 971 03a4 FF90      		pop r15
 972 03a6 EF90      		pop r14
 973 03a8 DF90      		pop r13
 974               	.LBB10:
 718:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);
 975               		.loc 1 718 0
 976 03aa 0C94 0000 		jmp cmd_write
 977               	.LVL114:
 978               	.LBE10:
 979               		.cfi_endproc
 980               	.LFE23:
 982               	.global	t6963_write_row
 984               	t6963_write_row:
 985               	.LFB24:
 721:t6963.c       **** 
 722:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 723:t6963.c       **** /// Write a row to the display.
 724:t6963.c       **** /// The row is written colum wise where x will start at (x & 0xf8)
 725:t6963.c       **** ///
 726:t6963.c       **** /// @param [in] x_column The column to write (x % 8)
 727:t6963.c       **** /// @param [in] y The row to read.
 728:t6963.c       **** /// @param [in] length The number of columns to read.
 729:t6963.c       **** /// @param [in] buf Location to write from.
 730:t6963.c       **** ///
 731:t6963.c       **** void
 732:t6963.c       **** t6963_write_row (uint8_t x_column, uint8_t y, uint16_t length, uint8_t *buf, uint8_t mode)
 733:t6963.c       **** {
 986               		.loc 1 733 0
 987               		.cfi_startproc
 988               	.LVL115:
 989 03ae EF92      		push r14
 990               	.LCFI36:
 991               		.cfi_def_cfa_offset 3
 992               		.cfi_offset 14, -2
 993 03b0 FF92      		push r15
 994               	.LCFI37:
 995               		.cfi_def_cfa_offset 4
 996               		.cfi_offset 15, -3
 997 03b2 0F93      		push r16
 998               	.LCFI38:
 999               		.cfi_def_cfa_offset 5
 1000               		.cfi_offset 16, -4
 1001 03b4 CF93      		push r28
 1002               	.LCFI39:
 1003               		.cfi_def_cfa_offset 6
 1004               		.cfi_offset 28, -5
 1005 03b6 DF93      		push r29
 1006               	.LCFI40:
 1007               		.cfi_def_cfa_offset 7
 1008               		.cfi_offset 29, -6
 1009               	/* prologue: function */
 1010               	/* frame size = 0 */
 1011               	/* stack size = 5 */
 1012               	.L__stack_usage = 5
 1013 03b8 7A01      		movw r14,r20
 1014 03ba E901      		movw r28,r18
 734:t6963.c       ****     // This sets our pointer to the location containing
 735:t6963.c       ****     set_column_pointer (x_column, y);
 1015               		.loc 1 735 0
 1016 03bc 0E94 0000 		call set_column_pointer
 1017               	.LVL116:
 736:t6963.c       **** 
 737:t6963.c       ****     // Use a different command depending on how many bytes are being written.
 738:t6963.c       ****     // For a length of 1 then simply perform a single write command. If the
 739:t6963.c       ****     // length is >= 2 then it is quicker to perform an auto write function.
 740:t6963.c       ****     if (length == 1)
 1018               		.loc 1 740 0
 1019 03c0 81E0      		ldi r24,1
 1020 03c2 E816      		cp r14,r24
 1021 03c4 F104      		cpc r15,__zero_reg__
 1022 03c6 01F4      		brne .L53
 741:t6963.c       ****     {
 742:t6963.c       ****         // Write the data first and then send the command.
 743:t6963.c       ****         data_write (*buf);              // Send data to controller
 1023               		.loc 1 743 0
 1024 03c8 8881      		ld r24,Y
 1025 03ca 0E94 0000 		call data_write
 1026               	.LVL117:
 744:t6963.c       ****         cmd_write (CMD_DATA_WRITE);     // A non-incrementing write.
 1027               		.loc 1 744 0
 1028 03ce 84EC      		ldi r24,lo8(-60)
 1029 03d0 93E0      		ldi r25,lo8(3)
 1030 03d2 00C0      		rjmp .L57
 1031               	.L53:
 1032               	.LBB11:
 745:t6963.c       ****     }
 746:t6963.c       ****     else
 747:t6963.c       ****     {
 748:t6963.c       ****         int ii;
 749:t6963.c       **** 
 750:t6963.c       ****         // Perform an auto read to collect the data.
 751:t6963.c       ****         cmd_write (CMD_DATA_AUTO_WRITE);
 1033               		.loc 1 751 0
 1034 03d4 80EB      		ldi r24,lo8(-80)
 1035 03d6 98E0      		ldi r25,lo8(8)
 1036 03d8 0E94 0000 		call cmd_write
 1037               	.LVL118:
 1038 03dc EC0E      		add r14,r28
 1039 03de FD1E      		adc r15,r29
 1040               	.LVL119:
 1041               	.LBB12:
 752:t6963.c       **** 
 753:t6963.c       ****         // Iterate over all of the data
 754:t6963.c       ****         for (ii = 0; ii < length; ii++)
 755:t6963.c       ****         {
 756:t6963.c       ****             uint8_t data = *buf++;
 757:t6963.c       **** 
 758:t6963.c       ****             // Perform a reverse if required.
 759:t6963.c       ****             if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 1042               		.loc 1 759 0
 1043 03e0 0170      		andi r16,lo8(1)
 1044               	.LVL120:
 1045               	.L54:
 1046               	.LBE12:
 754:t6963.c       ****         for (ii = 0; ii < length; ii++)
 1047               		.loc 1 754 0 discriminator 1
 1048 03e2 CE15      		cp r28,r14
 1049 03e4 DF05      		cpc r29,r15
 1050 03e6 01F0      		breq .L58
 1051               	.LVL121:
 1052               	.LBB13:
 756:t6963.c       ****             uint8_t data = *buf++;
 1053               		.loc 1 756 0
 1054 03e8 8991      		ld r24,Y+
 1055               	.LVL122:
 1056               		.loc 1 759 0
 1057 03ea 0111      		cpse r16,__zero_reg__
 1058 03ec 00C0      		rjmp .L55
 760:t6963.c       ****                 data = ~data;
 1059               		.loc 1 760 0
 1060 03ee 8095      		com r24
 1061               	.LVL123:
 1062               	.L55:
 761:t6963.c       **** 
 762:t6963.c       ****             // Write the data.
 763:t6963.c       ****             data_write (data);
 1063               		.loc 1 763 0
 1064 03f0 0E94 0000 		call data_write
 1065               	.LVL124:
 1066 03f4 00C0      		rjmp .L54
 1067               	.L58:
 1068               	.LBE13:
 764:t6963.c       ****         }
 765:t6963.c       **** 
 766:t6963.c       ****         // End of auto mode
 767:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);
 1069               		.loc 1 767 0
 1070 03f6 82EB      		ldi r24,lo8(-78)
 1071 03f8 93E0      		ldi r25,lo8(3)
 1072               	.LVL125:
 1073               	.L57:
 1074               	/* epilogue start */
 1075               	.LBE11:
 768:t6963.c       ****     }
 769:t6963.c       **** }
 1076               		.loc 1 769 0
 1077 03fa DF91      		pop r29
 1078 03fc CF91      		pop r28
 1079               	.LVL126:
 1080 03fe 0F91      		pop r16
 1081 0400 FF90      		pop r15
 1082 0402 EF90      		pop r14
 1083               	.LBB14:
 767:t6963.c       ****         cmd_write (CMD_DATA_AUTO_RESET);
 1084               		.loc 1 767 0
 1085 0404 0C94 0000 		jmp cmd_write
 1086               	.LVL127:
 1087               	.LBE14:
 1088               		.cfi_endproc
 1089               	.LFE24:
 1091               	.global	t6963_rewrite_row
 1093               	t6963_rewrite_row:
 1094               	.LFB25:
 770:t6963.c       **** 
 771:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 772:t6963.c       **** /// Read and then write a single row of from the display.
 773:t6963.c       **** /// The row is read colum wise where x is (x & 0xf8)
 774:t6963.c       **** ///
 775:t6963.c       **** /// This methof is really provided for the single row (length=1) however for
 776:t6963.c       **** /// consistancy then we provide a multi-length version.
 777:t6963.c       **** ///
 778:t6963.c       **** /// @param [in] x_column The column to read (x % 8)
 779:t6963.c       **** /// @param [in] y The row to re-write.
 780:t6963.c       **** /// @param [in] length The number of columns to re-write.
 781:t6963.c       **** /// @param [in] buf Location to read into.
 782:t6963.c       **** /// @param [in] mode Merging modification operation to perform.
 783:t6963.c       **** ///
 784:t6963.c       **** ///             0x00 - MODE_REVERSE
 785:t6963.c       **** ///                    No merge required, reverse the data.
 786:t6963.c       **** ///                    buffer[x] = ~read_data
 787:t6963.c       **** ///                    Reverse is applied irrespective of the
 788:t6963.c       **** ///                    combinational modes (OR, XOR, NAND).
 789:t6963.c       **** ///                    So the data is returned un-reversed.
 790:t6963.c       **** ///
 791:t6963.c       **** ///             0x01 - MODE_COPY
 792:t6963.c       **** ///                    No merge required.
 793:t6963.c       **** ///                    buffer[x] = read_data
 794:t6963.c       **** ///
 795:t6963.c       **** ///             0x86 - MODE_NAND
 796:t6963.c       **** ///                    Merge required - NAND bits cleared in buffer
 797:t6963.c       **** ///                    buffer[x] = ~buffer[x] & read_data
 798:t6963.c       **** ///
 799:t6963.c       **** ///             0x80 - MODE_OR
 800:t6963.c       **** ///                    Merge - OR bits set in buffer
 801:t6963.c       **** ///                    buffer[x] = buffer[x] | read_data
 802:t6963.c       **** ///
 803:t6963.c       **** ///             0x82 - MODE_XOR
 804:t6963.c       **** ///                    Merge - XOR bits set in buffer
 805:t6963.c       **** ///                    buffer[x] = buffer[x] ^ read_data
 806:t6963.c       **** ///
 807:t6963.c       **** void
 808:t6963.c       **** t6963_rewrite_row (uint8_t x_column, uint8_t y, uint16_t length, uint8_t *buf, uint8_t mode)
 809:t6963.c       **** {
 1095               		.loc 1 809 0
 1096               		.cfi_startproc
 1097               	.LVL128:
 1098 0408 BF92      		push r11
 1099               	.LCFI41:
 1100               		.cfi_def_cfa_offset 3
 1101               		.cfi_offset 11, -2
 1102 040a CF92      		push r12
 1103               	.LCFI42:
 1104               		.cfi_def_cfa_offset 4
 1105               		.cfi_offset 12, -3
 1106 040c DF92      		push r13
 1107               	.LCFI43:
 1108               		.cfi_def_cfa_offset 5
 1109               		.cfi_offset 13, -4
 1110 040e EF92      		push r14
 1111               	.LCFI44:
 1112               		.cfi_def_cfa_offset 6
 1113               		.cfi_offset 14, -5
 1114 0410 FF92      		push r15
 1115               	.LCFI45:
 1116               		.cfi_def_cfa_offset 7
 1117               		.cfi_offset 15, -6
 1118 0412 0F93      		push r16
 1119               	.LCFI46:
 1120               		.cfi_def_cfa_offset 8
 1121               		.cfi_offset 16, -7
 1122 0414 1F93      		push r17
 1123               	.LCFI47:
 1124               		.cfi_def_cfa_offset 9
 1125               		.cfi_offset 17, -8
 1126 0416 CF93      		push r28
 1127               	.LCFI48:
 1128               		.cfi_def_cfa_offset 10
 1129               		.cfi_offset 28, -9
 1130 0418 DF93      		push r29
 1131               	.LCFI49:
 1132               		.cfi_def_cfa_offset 11
 1133               		.cfi_offset 29, -10
 1134               	/* prologue: function */
 1135               	/* frame size = 0 */
 1136               	/* stack size = 9 */
 1137               	.L__stack_usage = 9
 1138 041a D82E      		mov r13,r24
 1139 041c C62E      		mov r12,r22
 1140 041e 7A01      		movw r14,r20
 1141 0420 E901      		movw r28,r18
 1142 0422 102F      		mov r17,r16
 1143 0424 802F      		mov r24,r16
 1144               	.LVL129:
 1145 0426 8671      		andi r24,lo8(22)
 1146 0428 B82E      		mov r11,r24
 810:t6963.c       ****     // Use a different command depending on how many bytes are being read.
 811:t6963.c       ****     // For a length of 1 then simply perform a single read command. If the
 812:t6963.c       ****     // length is >= 2 then it is quicker to perform an auto read function.
 813:t6963.c       ****     if (length == 1)
 1147               		.loc 1 813 0
 1148 042a 4130      		cpi r20,1
 1149 042c 5105      		cpc r21,__zero_reg__
 1150 042e 01F4      		brne .L60
 1151               	.LVL130:
 1152               	.LBB18:
 1153               	.LBB19:
 814:t6963.c       ****     {
 815:t6963.c       ****         uint8_t data;
 816:t6963.c       **** 
 817:t6963.c       ****         // This sets our pointer to the location containing
 818:t6963.c       ****         set_column_pointer (x_column, y);
 1154               		.loc 1 818 0
 1155 0430 8D2D      		mov r24,r13
 1156 0432 0E94 0000 		call set_column_pointer
 1157               	.LVL131:
 1158 0436 0170      		andi r16,lo8(1)
 1159               	.LVL132:
 819:t6963.c       **** 
 820:t6963.c       ****         if ((mode & MODE_MODIFIER) != 0)
 1160               		.loc 1 820 0
 1161 0438 BB20      		tst r11
 1162 043a 01F0      		breq .L61
 821:t6963.c       ****         {
 822:t6963.c       ****             cmd_write (CMD_DATA_READ);      // A non-incrementing read.
 1163               		.loc 1 822 0
 1164 043c 85EC      		ldi r24,lo8(-59)
 1165 043e 93E0      		ldi r25,lo8(3)
 1166 0440 0E94 0000 		call cmd_write
 1167               	.LVL133:
 823:t6963.c       ****             data = data_read();             // Get the data from controller
 1168               		.loc 1 823 0
 1169 0444 0E94 0000 		call data_read
 1170               	.LVL134:
 824:t6963.c       **** 
 825:t6963.c       ****             // Apply any reverse setting
 826:t6963.c       ****             if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 1171               		.loc 1 826 0
 1172 0448 0111      		cpse r16,__zero_reg__
 1173 044a 00C0      		rjmp .L62
 827:t6963.c       ****                 data = ~data;
 1174               		.loc 1 827 0
 1175 044c 8095      		com r24
 1176               	.LVL135:
 1177               	.L62:
 828:t6963.c       **** 
 829:t6963.c       ****             // Handle any buffer merging on the read.
 830:t6963.c       ****             data = merge_row (*buf, data, mode);
 1178               		.loc 1 830 0
 1179 044e 412F      		mov r20,r17
 1180 0450 682F      		mov r22,r24
 1181 0452 8881      		ld r24,Y
 1182               	.LVL136:
 1183 0454 0E94 0000 		call merge_row
 1184               	.LVL137:
 1185 0458 00C0      		rjmp .L63
 1186               	.LVL138:
 1187               	.L61:
 831:t6963.c       ****         }
 832:t6963.c       ****         else
 833:t6963.c       ****             data = *buf;
 1188               		.loc 1 833 0
 1189 045a 8881      		ld r24,Y
 1190               	.LVL139:
 1191               	.L63:
 834:t6963.c       **** 
 835:t6963.c       ****         if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 1192               		.loc 1 835 0
 1193 045c 0111      		cpse r16,__zero_reg__
 1194 045e 00C0      		rjmp .L64
 836:t6963.c       ****             data = ~data;
 1195               		.loc 1 836 0
 1196 0460 8095      		com r24
 1197               	.LVL140:
 1198               	.L64:
 837:t6963.c       **** 
 838:t6963.c       ****         // Write the data first and then send the command.
 839:t6963.c       ****         data_write (data);              // Send data to controller
 1199               		.loc 1 839 0
 1200 0462 0E94 0000 		call data_write
 1201               	.LVL141:
 840:t6963.c       ****         cmd_write (CMD_DATA_WRITE);     // A non-incrementing write.
 1202               		.loc 1 840 0
 1203 0466 84EC      		ldi r24,lo8(-60)
 1204 0468 93E0      		ldi r25,lo8(3)
 1205               	/* epilogue start */
 1206               	.LBE19:
 1207               	.LBE18:
 841:t6963.c       ****     }
 842:t6963.c       ****     else
 843:t6963.c       ****     {
 844:t6963.c       ****         // Simply do a read_row() followed by write_row(). Only perform the
 845:t6963.c       ****         // read if there is a data merge operation.
 846:t6963.c       ****         if ((mode & MODE_MODIFIER) != 0)
 847:t6963.c       ****         {
 848:t6963.c       ****             // Read for the merge.
 849:t6963.c       ****             t6963_read_row (x_column, y, length, buf, mode);
 850:t6963.c       ****         }
 851:t6963.c       **** 
 852:t6963.c       ****         // Write the merged data.
 853:t6963.c       ****         t6963_write_row (x_column, y, length, buf, mode);
 854:t6963.c       ****     }
 855:t6963.c       **** }
 1208               		.loc 1 855 0
 1209 046a DF91      		pop r29
 1210 046c CF91      		pop r28
 1211               	.LVL142:
 1212 046e 1F91      		pop r17
 1213               	.LVL143:
 1214 0470 0F91      		pop r16
 1215 0472 FF90      		pop r15
 1216 0474 EF90      		pop r14
 1217               	.LVL144:
 1218 0476 DF90      		pop r13
 1219               	.LVL145:
 1220 0478 CF90      		pop r12
 1221               	.LVL146:
 1222 047a BF90      		pop r11
 1223               	.LBB21:
 1224               	.LBB20:
 840:t6963.c       ****         cmd_write (CMD_DATA_WRITE);     // A non-incrementing write.
 1225               		.loc 1 840 0
 1226 047c 0C94 0000 		jmp cmd_write
 1227               	.LVL147:
 1228               	.L60:
 1229               	.LBE20:
 1230               	.LBE21:
 846:t6963.c       ****         if ((mode & MODE_MODIFIER) != 0)
 1231               		.loc 1 846 0
 1232 0480 BB20      		tst r11
 1233 0482 01F0      		breq .L65
 849:t6963.c       ****             t6963_read_row (x_column, y, length, buf, mode);
 1234               		.loc 1 849 0
 1235 0484 8D2D      		mov r24,r13
 1236 0486 0E94 0000 		call t6963_read_row
 1237               	.LVL148:
 1238               	.L65:
 853:t6963.c       ****         t6963_write_row (x_column, y, length, buf, mode);
 1239               		.loc 1 853 0
 1240 048a 012F      		mov r16,r17
 1241               	.LVL149:
 1242 048c 9E01      		movw r18,r28
 1243 048e A701      		movw r20,r14
 1244 0490 6C2D      		mov r22,r12
 1245 0492 8D2D      		mov r24,r13
 1246 0494 0E94 0000 		call t6963_write_row
 1247               	.LVL150:
 1248               	/* epilogue start */
 1249               		.loc 1 855 0
 1250 0498 DF91      		pop r29
 1251 049a CF91      		pop r28
 1252               	.LVL151:
 1253 049c 1F91      		pop r17
 1254               	.LVL152:
 1255 049e 0F91      		pop r16
 1256               	.LVL153:
 1257 04a0 FF90      		pop r15
 1258 04a2 EF90      		pop r14
 1259               	.LVL154:
 1260 04a4 DF90      		pop r13
 1261               	.LVL155:
 1262 04a6 CF90      		pop r12
 1263               	.LVL156:
 1264 04a8 BF90      		pop r11
 1265 04aa 0895      		ret
 1266               		.cfi_endproc
 1267               	.LFE25:
 1269               	.global	t6963_set_row
 1271               	t6963_set_row:
 1272               	.LFB26:
 856:t6963.c       **** 
 857:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 858:t6963.c       **** /// Sets/Draws a single row to the screen.
 859:t6963.c       **** /// The row is read colum wise where x is (x & 0xf8)
 860:t6963.c       **** ///
 861:t6963.c       **** /// @param [in] x_column The column to read (x % 8)
 862:t6963.c       **** /// @param [in] y The row to re-write.
 863:t6963.c       **** /// @param [in] data The data to write.
 864:t6963.c       **** /// @param [in] mask The bit mask of the valid bits of the data.
 865:t6963.c       **** /// @param [in] mode Merging modification operation to perform.
 866:t6963.c       **** ///
 867:t6963.c       **** ///             0x00 - MODE_REVERSE
 868:t6963.c       **** ///                    No merge required, reverse the data.
 869:t6963.c       **** ///                    buffer[x] = ~read_data
 870:t6963.c       **** ///                    Reverse is applied irrespective of the
 871:t6963.c       **** ///                    combinational modes (OR, XOR, NAND).
 872:t6963.c       **** ///                    So the data is returned un-reversed.
 873:t6963.c       **** ///
 874:t6963.c       **** ///             0x01 - MODE_COPY
 875:t6963.c       **** ///                    No merge required.
 876:t6963.c       **** ///                    buffer[x] = read_data
 877:t6963.c       **** ///
 878:t6963.c       **** ///             0x02 - MODE_MERGE
 879:t6963.c       **** ///                    A copy with merge required.
 880:t6963.c       **** ///                    buffer[x] = read_data
 881:t6963.c       **** ///
 882:t6963.c       **** ///             0x04 - MODE_OR
 883:t6963.c       **** ///                    Merge - OR bits set in buffer
 884:t6963.c       **** ///                    buffer[x] = buffer[x] | read_data
 885:t6963.c       **** ///
 886:t6963.c       **** ///             0x08 - MODE_XOR
 887:t6963.c       **** ///                    Merge - XOR bits set in buffer
 888:t6963.c       **** ///                    buffer[x] = buffer[x] ^ read_data
 889:t6963.c       **** ///
 890:t6963.c       **** ///             0x0c - MODE_NAND
 891:t6963.c       **** ///                    Merge required - NAND bits cleared in buffer
 892:t6963.c       **** ///                    buffer[x] = ~buffer[x] & read_data
 893:t6963.c       **** ///
 894:t6963.c       **** void
 895:t6963.c       **** t6963_set_row (uint8_t x_column, uint8_t y, uint8_t data, uint8_t mask, uint8_t mode)
 896:t6963.c       **** {
 1273               		.loc 1 896 0
 1274               		.cfi_startproc
 1275               	.LVL157:
 1276 04ac FF92      		push r15
 1277               	.LCFI50:
 1278               		.cfi_def_cfa_offset 3
 1279               		.cfi_offset 15, -2
 1280 04ae 0F93      		push r16
 1281               	.LCFI51:
 1282               		.cfi_def_cfa_offset 4
 1283               		.cfi_offset 16, -3
 1284 04b0 1F93      		push r17
 1285               	.LCFI52:
 1286               		.cfi_def_cfa_offset 5
 1287               		.cfi_offset 17, -4
 1288 04b2 CF93      		push r28
 1289               	.LCFI53:
 1290               		.cfi_def_cfa_offset 6
 1291               		.cfi_offset 28, -5
 1292 04b4 DF93      		push r29
 1293               	.LCFI54:
 1294               		.cfi_def_cfa_offset 7
 1295               		.cfi_offset 29, -6
 1296               	/* prologue: function */
 1297               	/* frame size = 0 */
 1298               	/* stack size = 5 */
 1299               	.L__stack_usage = 5
 1300 04b6 C42F      		mov r28,r20
 1301 04b8 122F      		mov r17,r18
 897:t6963.c       ****     // This sets our pointer to the location containing
 898:t6963.c       ****     set_column_pointer (x_column, y);
 1302               		.loc 1 898 0
 1303 04ba 0E94 0000 		call set_column_pointer
 1304               	.LVL158:
 899:t6963.c       ****     
 900:t6963.c       ****     // Handle any buffer merging on the read.
 901:t6963.c       ****     if ((mode & MODE_MODIFIER) != 0)
 1305               		.loc 1 901 0
 1306 04be 802F      		mov r24,r16
 1307 04c0 8671      		andi r24,lo8(22)
 1308 04c2 902F      		mov r25,r16
 1309 04c4 9170      		andi r25,lo8(1)
 1310 04c6 F92E      		mov r15,r25
 1311 04c8 8823      		tst r24
 1312 04ca 01F0      		breq .L70
 1313               	.LBB22:
 902:t6963.c       ****     {
 903:t6963.c       ****         uint8_t screen_data;
 904:t6963.c       **** 
 905:t6963.c       ****         // We need to perform a merge
 906:t6963.c       ****         cmd_write (CMD_DATA_READ);  // A non-incrementing read.
 1314               		.loc 1 906 0
 1315 04cc 85EC      		ldi r24,lo8(-59)
 1316 04ce 93E0      		ldi r25,lo8(3)
 1317 04d0 0E94 0000 		call cmd_write
 1318               	.LVL159:
 907:t6963.c       ****         screen_data = data_read();  // Get the data from controller
 1319               		.loc 1 907 0
 1320 04d4 0E94 0000 		call data_read
 1321               	.LVL160:
 1322 04d8 D82F      		mov r29,r24
 1323               	.LVL161:
 908:t6963.c       **** 
 909:t6963.c       ****         // Apply any reverse setting; if the reverse bit is set then we
 910:t6963.c       ****         // negate the data
 911:t6963.c       ****         if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 1324               		.loc 1 911 0
 1325 04da F110      		cpse r15,__zero_reg__
 1326 04dc 00C0      		rjmp .L71
 912:t6963.c       ****             screen_data = ~screen_data;
 1327               		.loc 1 912 0
 1328 04de D095      		com r29
 1329               	.LVL162:
 1330               	.L71:
 913:t6963.c       **** 
 914:t6963.c       ****         // Perform the merge
 915:t6963.c       ****         if ((mode & MODE_OP_MASK) != 0)
 1331               		.loc 1 915 0
 1332 04e0 802F      		mov r24,r16
 1333 04e2 8670      		andi r24,lo8(6)
 1334 04e4 01F0      		breq .L72
 916:t6963.c       ****             data = merge_row (data, screen_data, mode);
 1335               		.loc 1 916 0
 1336 04e6 402F      		mov r20,r16
 1337 04e8 6D2F      		mov r22,r29
 1338 04ea 8C2F      		mov r24,r28
 1339 04ec 0E94 0000 		call merge_row
 1340               	.LVL163:
 1341 04f0 C82F      		mov r28,r24
 1342               	.LVL164:
 1343               	.L72:
 917:t6963.c       ****         
 918:t6963.c       ****         // MODE_MERGE - Merge in the data in a copy mode
 919:t6963.c       ****         data = (data & mask) | (screen_data & ~mask);
 1344               		.loc 1 919 0
 1345 04f2 C123      		and r28,r17
 1346               	.LVL165:
 1347 04f4 212F      		mov r18,r17
 1348 04f6 2095      		com r18
 1349 04f8 2D23      		and r18,r29
 1350 04fa C22B      		or r28,r18
 1351               	.LVL166:
 1352               	.L70:
 1353               	.LBE22:
 920:t6963.c       ****     }
 921:t6963.c       **** 
 922:t6963.c       ****     // Apply any reverse setting; if the reverse bit is set then we
 923:t6963.c       ****     // negate the data
 924:t6963.c       ****     if ((mode & MODE_NORMAL_MASK) == MODE_REVERSE)
 1354               		.loc 1 924 0
 1355 04fc F110      		cpse r15,__zero_reg__
 1356 04fe 00C0      		rjmp .L73
 925:t6963.c       ****         data = ~data;
 1357               		.loc 1 925 0
 1358 0500 C095      		com r28
 1359               	.LVL167:
 1360               	.L73:
 926:t6963.c       **** 
 927:t6963.c       ****     // Write the data first and then send the command.
 928:t6963.c       ****     data_write (data);                  // Send data to controller
 1361               		.loc 1 928 0
 1362 0502 8C2F      		mov r24,r28
 1363 0504 0E94 0000 		call data_write
 1364               	.LVL168:
 929:t6963.c       ****     cmd_write (CMD_DATA_WRITE);
 1365               		.loc 1 929 0
 1366 0508 84EC      		ldi r24,lo8(-60)
 1367 050a 93E0      		ldi r25,lo8(3)
 1368               	/* epilogue start */
 930:t6963.c       **** }
 1369               		.loc 1 930 0
 1370 050c DF91      		pop r29
 1371 050e CF91      		pop r28
 1372               	.LVL169:
 1373 0510 1F91      		pop r17
 1374               	.LVL170:
 1375 0512 0F91      		pop r16
 1376               	.LVL171:
 1377 0514 FF90      		pop r15
 929:t6963.c       ****     cmd_write (CMD_DATA_WRITE);
 1378               		.loc 1 929 0
 1379 0516 0C94 0000 		jmp cmd_write
 1380               	.LVL172:
 1381               		.cfi_endproc
 1382               	.LFE26:
 1384               	.global	t6963_set_pixel
 1386               	t6963_set_pixel:
 1387               	.LFB21:
 562:t6963.c       **** {
 1388               		.loc 1 562 0
 1389               		.cfi_startproc
 1390               	.LVL173:
 1391 051a 0F93      		push r16
 1392               	.LCFI55:
 1393               		.cfi_def_cfa_offset 3
 1394               		.cfi_offset 16, -2
 1395 051c CF93      		push r28
 1396               	.LCFI56:
 1397               		.cfi_def_cfa_offset 4
 1398               		.cfi_offset 28, -3
 1399 051e DF93      		push r29
 1400               	.LCFI57:
 1401               		.cfi_def_cfa_offset 5
 1402               		.cfi_offset 29, -4
 1403               	/* prologue: function */
 1404               	/* frame size = 0 */
 1405               	/* stack size = 3 */
 1406               	.L__stack_usage = 3
 1407 0520 042F      		mov r16,r20
 563:t6963.c       ****     uint8_t xbit = x & 7;               // The sub-column
 1408               		.loc 1 563 0
 1409 0522 C82F      		mov r28,r24
 1410 0524 C770      		andi r28,lo8(7)
 1411               	.LVL174:
 569:t6963.c       ****     if ((mode & MODE_OP_MASK) == 0)
 1412               		.loc 1 569 0
 1413 0526 942F      		mov r25,r20
 1414 0528 9670      		andi r25,lo8(6)
 1415 052a D0E0      		ldi r29,0
 1416 052c 01F4      		brne .L81
 1417               	.LBB23:
 576:t6963.c       ****         set_pointer(x, y);
 1418               		.loc 1 576 0
 1419 052e 0E94 0000 		call set_pointer
 1420               	.LVL175:
 581:t6963.c       ****         if ((mode & MODE_NORMAL_MASK) != MODE_REVERSE)
 1421               		.loc 1 581 0
 1422 0532 00FF      		sbrs r16,0
 1423 0534 00C0      		rjmp .L83
 582:t6963.c       ****             data |= 0x08;
 1424               		.loc 1 582 0
 1425 0536 28EF      		ldi r18,lo8(-8)
 1426 0538 33E0      		ldi r19,lo8(3)
 1427 053a 00C0      		rjmp .L82
 1428               	.L83:
 578:t6963.c       ****         data = CMD_BIT_SET_RESET;       // Bitset command.
 1429               		.loc 1 578 0
 1430 053c 20EF      		ldi r18,lo8(-16)
 1431 053e 33E0      		ldi r19,lo8(3)
 1432               	.L82:
 1433               	.LVL176:
 585:t6963.c       ****         data |= 7 - xbit;              // Add the bit index into byte
 1434               		.loc 1 585 0
 1435 0540 87E0      		ldi r24,lo8(7)
 1436 0542 90E0      		ldi r25,0
 1437 0544 8C1B      		sub r24,r28
 1438 0546 9D0B      		sbc r25,r29
 587:t6963.c       ****         cmd_write(data);                // Send the command.
 1439               		.loc 1 587 0
 1440 0548 822B      		or r24,r18
 1441 054a 932B      		or r25,r19
 1442               	/* epilogue start */
 1443               	.LBE23:
 602:t6963.c       **** }
 1444               		.loc 1 602 0
 1445 054c DF91      		pop r29
 1446 054e CF91      		pop r28
 1447               	.LVL177:
 1448 0550 0F91      		pop r16
 1449               	.LVL178:
 1450               	.LBB24:
 587:t6963.c       ****         cmd_write(data);                // Send the command.
 1451               		.loc 1 587 0
 1452 0552 0C94 0000 		jmp cmd_write
 1453               	.LVL179:
 1454               	.L81:
 1455               	.LBE24:
 1456               	.LBB25:
 599:t6963.c       ****                        pgm_read_byte(&bit_shift_rev_single_maskP [xbit]), 
 1457               		.loc 1 599 0
 1458 0556 FE01      		movw r30,r28
 1459 0558 E050      		subi r30,lo8(-(bit_shift_rev_single_maskP))
 1460 055a F040      		sbci r31,hi8(-(bit_shift_rev_single_maskP))
 1461               	/* #APP */
 1462               	 ;  599 "t6963.c" 1
 1463 055c 2491      		lpm r18, Z
 1464               		
 1465               	 ;  0 "" 2
 1466               	.LVL180:
 1467               	/* #NOAPP */
 1468               	.LBE25:
 598:t6963.c       ****         t6963_set_row (x >> 3, y, 0xff, 
 1469               		.loc 1 598 0
 1470 055e 0061      		ori r16,lo8(16)
 1471               	.LVL181:
 1472 0560 4FEF      		ldi r20,lo8(-1)
 1473               	.LVL182:
 1474 0562 8695      		lsr r24
 1475 0564 8695      		lsr r24
 1476 0566 8695      		lsr r24
 1477               	.LVL183:
 1478 0568 0E94 0000 		call t6963_set_row
 1479               	.LVL184:
 1480               	/* epilogue start */
 602:t6963.c       **** }
 1481               		.loc 1 602 0
 1482 056c DF91      		pop r29
 1483 056e CF91      		pop r28
 1484               	.LVL185:
 1485 0570 0F91      		pop r16
 1486 0572 0895      		ret
 1487               		.cfi_endproc
 1488               	.LFE21:
 1490               	.global	t6963_vbitblt
 1492               	t6963_vbitblt:
 1493               	.LFB29:
 931:t6963.c       **** 
 932:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
 933:t6963.c       **** /// Flip bitbit data from vertical to horizontal layout. This flits
 934:t6963.c       **** /// vertically organised bitblt data to be horizontal. Thi requires a lot of
 935:t6963.c       **** /// shifing. There are some clever 64-bit multiplacation functions aroudn
 936:t6963.c       **** /// that perform this transformation but is not for the Arduino. This
 937:t6963.c       **** /// implementation using brute force bit moving to achieve the rotation.
 938:t6963.c       **** ///
 939:t6963.c       **** /// A reference to buffer that is passed in is re-organised and returned to
 940:t6963.c       **** /// the caller in-place.
 941:t6963.c       **** ///
 942:t6963.c       **** /// @param [in] buf An 8x8 buffer of data to be reorganised.
 943:t6963.c       **** ///
 944:t6963.c       **** static __inline__ void
 945:t6963.c       **** flip_8x8_v_to_h (uint8_t *buf)
 946:t6963.c       **** {
 947:t6963.c       ****     uint8_t dest [8];
 948:t6963.c       ****     int8_t xx;
 949:t6963.c       ****     int8_t yy;
 950:t6963.c       **** 
 951:t6963.c       ****     // Flip the bits.
 952:t6963.c       ****     yy = 7;
 953:t6963.c       ****     do
 954:t6963.c       ****     {
 955:t6963.c       ****         uint8_t datum = buf[yy];
 956:t6963.c       ****         xx = 7;
 957:t6963.c       ****         do
 958:t6963.c       ****         {
 959:t6963.c       ****             dest[xx] = (dest[xx] >> 1) | (datum & 0x80);
 960:t6963.c       ****             datum <<= 1;
 961:t6963.c       ****         }
 962:t6963.c       ****         while (--xx >= 0);
 963:t6963.c       ****     }
 964:t6963.c       ****     while (--yy >= 0);
 965:t6963.c       **** 
 966:t6963.c       ****     // Copy the results back
 967:t6963.c       ****     xx = 7;
 968:t6963.c       ****     do
 969:t6963.c       ****     {
 970:t6963.c       ****         buf[xx] = dest[xx];
 971:t6963.c       ****     }
 972:t6963.c       ****     while (--xx >= 0);
 973:t6963.c       **** }
 974:t6963.c       **** 
 975:t6963.c       **** //////////////////////////////////////////////////////////////////////////////
 976:t6963.c       **** /// Bitblt a line. This is a worker function for bitblt that prepares a line
 977:t6963.c       **** /// of data to be written to the screen managing the merge of screen data at
 978:t6963.c       **** /// the start and end of the bitblt data.
 979:t6963.c       **** ///
 980:t6963.c       **** /// @param [in] x The x-coordinate on the screen.
 981:t6963.c       **** /// @param [in] y The y-coordinate on the screen.
 982:t6963.c       **** /// @param [in] width The width of the data in pixels.
 983:t6963.c       **** /// @param [in] data A pointer to the bitblit row.
 984:t6963.c       **** /// @param [in] mode The merging mode of the data.
 985:t6963.c       **** ///
 986:t6963.c       **** static void
 987:t6963.c       **** bitblt_line (uint8_t x, uint8_t y, uint8_t width, uint8_t *data, uint8_t mode)
 988:t6963.c       **** {
 989:t6963.c       ****     uint8_t ii;                         // Local iterator
 990:t6963.c       **** 
 991:t6963.c       ****     // See if there is a left merge.
 992:t6963.c       ****     ii = x & 7;                         // Get the shift on the left
 993:t6963.c       ****     x >>= 3;                            // Convert to column address
 994:t6963.c       ****     if (ii != 0)
 995:t6963.c       ****     {
 996:t6963.c       ****         uint8_t valid_mask;             // Mask for the valid bits to write.
 997:t6963.c       **** 
 998:t6963.c       ****         // Create mask for start block i.e. 0xff >> ii
 999:t6963.c       ****         valid_mask = pgm_read_byte (&bit_shift_maskP[ii]);
1000:t6963.c       ****         width += ii;                    // Add the sub-block start
1001:t6963.c       **** 
1002:t6963.c       ****         // Add any right mask if we have a short block.
1003:t6963.c       ****         if (width <= 8)
1004:t6963.c       ****         {
1005:t6963.c       ****             // Add any right mask if we have a short block.
1006:t6963.c       ****             if (width < 8)
1007:t6963.c       ****             {
1008:t6963.c       ****                 // This is a short block, the data does not occupy the block.
1009:t6963.c       ****                 // Modify the mask to handle the right of the data.
1010:t6963.c       ****                 // i.e. ((1 << (8 - width)) - 1)
1011:t6963.c       ****                 valid_mask &= ~pgm_read_byte (&bit_shift_maskP[width]);
1012:t6963.c       ****             }
1013:t6963.c       **** 
1014:t6963.c       ****             // Write the start of row.
1015:t6963.c       ****             t6963_set_row (x, y, *data++, valid_mask, mode | MODE_MERGE);
1016:t6963.c       ****             return;
1017:t6963.c       ****         }
1018:t6963.c       **** 
1019:t6963.c       ****         // More than 1 block, compute the new length
1020:t6963.c       ****         width -= 8;
1021:t6963.c       ****         // This is a partial update so merge the data into the screen data.
1022:t6963.c       ****         t6963_set_row (x++, y, *data++, valid_mask, mode | MODE_MERGE);
1023:t6963.c       ****     }
1024:t6963.c       **** 
1025:t6963.c       ****     // Process the whole blocks; convert to column count
1026:t6963.c       ****     if ((ii = (width >> 3)) > 0)
1027:t6963.c       ****     {
1028:t6963.c       ****         // Re-write the row, this will determine if we need to merge or not.
1029:t6963.c       ****         t6963_rewrite_row (x, y, ii, data, mode);
1030:t6963.c       ****     }
1031:t6963.c       **** 
1032:t6963.c       ****     // Process any remaining block
1033:t6963.c       ****     width &= 7;
1034:t6963.c       ****     if (width > 0)
1035:t6963.c       ****     {
1036:t6963.c       ****         uint8_t valid_mask;             // Mask for the valid bits to write.
1037:t6963.c       **** 
1038:t6963.c       ****         // This is a partial update so merge the data into the screen data.
1039:t6963.c       ****         // Create the mask of invalid bits is  (1 << (8 - width)) - 1 i.e. bit_shift_mask;
1040:t6963.c       ****         valid_mask = ~pgm_read_byte (&bit_shift_maskP[width]);
1041:t6963.c       ****         t6963_set_row (x + ii, y, data[ii], valid_mask, mode | MODE_MERGE);
1042:t6963.c       ****     }
1043:t6963.c       **** }
1044:t6963.c       **** 
1045:t6963.c       **** //////////////////////////////////////////////////////////////////////////////
1046:t6963.c       **** /// Vertical bitblt does a bit transfer from data to display memory. If NULL
1047:t6963.c       **** /// is passed as data, bitblt assumes the data is to come from the serial
1048:t6963.c       **** /// port, and will take it from there. Bitblt will not return until it gets
1049:t6963.c       **** /// all the bytes it wants.
1050:t6963.c       **** ///
1051:t6963.c       **** /// @param [in] x,y is upper left corner of image in pixels. Bitblt counts
1052:t6963.c       **** ///             coordinates in the standard fashion. ie (0,0) is upper left,
1053:t6963.c       **** ///             +x it to the right +y is down width is width in pixels.
1054:t6963.c       **** ///
1055:t6963.c       **** /// @param [in] mode determines how the bits in the image combine with the
1056:t6963.c       **** ///             bits already present on the display.
1057:t6963.c       **** ///
1058:t6963.c       **** ///             0x00 - MODE_REVERSE
1059:t6963.c       **** ///                    No merge required, reverse the data.
1060:t6963.c       **** ///                    buffer[x] = ~read_data
1061:t6963.c       **** ///                    Reverse is applied irrespective of the
1062:t6963.c       **** ///                    combinational modes (OR, XOR, NAND).
1063:t6963.c       **** ///                    So the data is returned un-reversed.
1064:t6963.c       **** ///
1065:t6963.c       **** ///             0x01 - MODE_COPY
1066:t6963.c       **** ///                    No merge required.
1067:t6963.c       **** ///                    buffer[x] = read_data
1068:t6963.c       **** ///
1069:t6963.c       **** ///             0x02 - MODE_OR
1070:t6963.c       **** ///                    Merge - OR bits set in buffer
1071:t6963.c       **** ///                    buffer[x] = buffer[x] | read_data
1072:t6963.c       **** ///
1073:t6963.c       **** ///             0x04 - MODE_XOR
1074:t6963.c       **** ///                    Merge - XOR bits set in buffer
1075:t6963.c       **** ///                    buffer[x] = buffer[x] ^ read_data
1076:t6963.c       **** ///
1077:t6963.c       **** ///             0x08 - MODE_NAND
1078:t6963.c       **** ///                    Merge required - NAND bits cleared in buffer
1079:t6963.c       **** ///                    buffer[x] = ~buffer[x] & read_data
1080:t6963.c       **** ///
1081:t6963.c       **** ///             0x10 - MODE_FILL
1082:t6963.c       **** ///                    Interpret the data as a mask and fill.
1083:t6963.c       **** void
1084:t6963.c       **** t6963_vbitblt (uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t mode, uint8_t *data)
1085:t6963.c       **** {
 1494               		.loc 1 1085 0
 1495               		.cfi_startproc
 1496               	.LVL186:
 1497 0574 2F92      		push r2
 1498               	.LCFI58:
 1499               		.cfi_def_cfa_offset 3
 1500               		.cfi_offset 2, -2
 1501 0576 3F92      		push r3
 1502               	.LCFI59:
 1503               		.cfi_def_cfa_offset 4
 1504               		.cfi_offset 3, -3
 1505 0578 4F92      		push r4
 1506               	.LCFI60:
 1507               		.cfi_def_cfa_offset 5
 1508               		.cfi_offset 4, -4
 1509 057a 5F92      		push r5
 1510               	.LCFI61:
 1511               		.cfi_def_cfa_offset 6
 1512               		.cfi_offset 5, -5
 1513 057c 6F92      		push r6
 1514               	.LCFI62:
 1515               		.cfi_def_cfa_offset 7
 1516               		.cfi_offset 6, -6
 1517 057e 7F92      		push r7
 1518               	.LCFI63:
 1519               		.cfi_def_cfa_offset 8
 1520               		.cfi_offset 7, -7
 1521 0580 8F92      		push r8
 1522               	.LCFI64:
 1523               		.cfi_def_cfa_offset 9
 1524               		.cfi_offset 8, -8
 1525 0582 9F92      		push r9
 1526               	.LCFI65:
 1527               		.cfi_def_cfa_offset 10
 1528               		.cfi_offset 9, -9
 1529 0584 AF92      		push r10
 1530               	.LCFI66:
 1531               		.cfi_def_cfa_offset 11
 1532               		.cfi_offset 10, -10
 1533 0586 BF92      		push r11
 1534               	.LCFI67:
 1535               		.cfi_def_cfa_offset 12
 1536               		.cfi_offset 11, -11
 1537 0588 CF92      		push r12
 1538               	.LCFI68:
 1539               		.cfi_def_cfa_offset 13
 1540               		.cfi_offset 12, -12
 1541 058a DF92      		push r13
 1542               	.LCFI69:
 1543               		.cfi_def_cfa_offset 14
 1544               		.cfi_offset 13, -13
 1545 058c EF92      		push r14
 1546               	.LCFI70:
 1547               		.cfi_def_cfa_offset 15
 1548               		.cfi_offset 14, -14
 1549 058e FF92      		push r15
 1550               	.LCFI71:
 1551               		.cfi_def_cfa_offset 16
 1552               		.cfi_offset 15, -15
 1553 0590 0F93      		push r16
 1554               	.LCFI72:
 1555               		.cfi_def_cfa_offset 17
 1556               		.cfi_offset 16, -16
 1557 0592 1F93      		push r17
 1558               	.LCFI73:
 1559               		.cfi_def_cfa_offset 18
 1560               		.cfi_offset 17, -17
 1561 0594 CF93      		push r28
 1562               	.LCFI74:
 1563               		.cfi_def_cfa_offset 19
 1564               		.cfi_offset 28, -18
 1565 0596 DF93      		push r29
 1566               	.LCFI75:
 1567               		.cfi_def_cfa_offset 20
 1568               		.cfi_offset 29, -19
 1569 0598 CDB7      		in r28,__SP_L__
 1570 059a DEB7      		in r29,__SP_H__
 1571               	.LCFI76:
 1572               		.cfi_def_cfa_register 28
 1573 059c A797      		sbiw r28,39
 1574               	.LCFI77:
 1575               		.cfi_def_cfa_offset 59
 1576 059e 0FB6      		in __tmp_reg__,__SREG__
 1577 05a0 F894      		cli
 1578 05a2 DEBF      		out __SP_H__,r29
 1579 05a4 0FBE      		out __SREG__,__tmp_reg__
 1580 05a6 CDBF      		out __SP_L__,r28
 1581               	/* prologue: function */
 1582               	/* frame size = 39 */
 1583               	/* stack size = 57 */
 1584               	.L__stack_usage = 57
 1585 05a8 162F      		mov r17,r22
 1586 05aa 4D8F      		std Y+29,r20
 1587 05ac 2E8F      		std Y+30,r18
 1588 05ae 098F      		std Y+25,r16
 1589 05b0 5701      		movw r10,r14
1086:t6963.c       ****     uint8_t left_margin;                // Remainder bits on the left
1087:t6963.c       ****     uint8_t right_remain;               // Number of remaining bits on line
1088:t6963.c       ****     uint8_t length;                     // Block aligned length.
1089:t6963.c       ****     uint8_t row;                        // The current row being processed.
1090:t6963.c       ****     uint8_t col;                        // The current column being processed.
1091:t6963.c       ****     uint8_t row_inc;                    // The row increment
1092:t6963.c       **** 
1093:t6963.c       ****     // Calculate the left margin and left aligned length
1094:t6963.c       ****     left_margin = (x & 7);              // The left margin
 1590               		.loc 1 1094 0
 1591 05b2 982F      		mov r25,r24
 1592 05b4 9770      		andi r25,lo8(7)
 1593 05b6 9E8B      		std Y+22,r25
 1594               	.LVL187:
1095:t6963.c       ****     length = left_margin + width;       // Length of the left block aligned
 1595               		.loc 1 1095 0
 1596 05b8 940F      		add r25,r20
 1597               	.LVL188:
 1598 05ba 9D8B      		std Y+21,r25
 1599               	.LVL189:
1096:t6963.c       **** 
1097:t6963.c       ****     // Compute the row increment based on the length of the image
1098:t6963.c       ****     row_inc = (length + 7) >> 3;
 1600               		.loc 1 1098 0
 1601 05bc 292E      		mov r2,r25
 1602 05be 312C      		mov r3,__zero_reg__
 1603 05c0 2101      		movw r4,r2
 1604 05c2 E7E0      		ldi r30,7
 1605 05c4 4E0E      		add r4,r30
 1606 05c6 511C      		adc r5,__zero_reg__
 1607 05c8 23E0      		ldi r18,3
 1608               		1:
 1609 05ca 5594      		asr r5
 1610 05cc 4794      		ror r4
 1611 05ce 2A95      		dec r18
 1612 05d0 01F4      		brne 1b
 1613               	.LVL190:
1099:t6963.c       **** 
1100:t6963.c       ****     // The margin to the right
1101:t6963.c       ****     right_remain = length & 7;          // Remaining bits on line
 1614               		.loc 1 1101 0
 1615 05d2 9770      		andi r25,lo8(7)
 1616               	.LVL191:
 1617 05d4 9F8F      		std Y+31,r25
 1618               	.LVL192:
 1619               	.LBB39:
 1620               	.LBB40:
 1621               	.LBB41:
 993:t6963.c       ****     x >>= 3;                            // Convert to column address
 1622               		.loc 1 993 0
 1623 05d6 982E      		mov r9,r24
 1624 05d8 9694      		lsr r9
 1625 05da 9694      		lsr r9
 1626 05dc 9694      		lsr r9
 1627               	.LBB42:
1022:t6963.c       ****         t6963_set_row (x++, y, *data++, valid_mask, mode | MODE_MERGE);
 1628               		.loc 1 1022 0
 1629 05de 91E0      		ldi r25,lo8(1)
 1630               	.LVL193:
 1631 05e0 990D      		add r25,r9
 1632 05e2 99A3      		std Y+33,r25
 1633               	.LBE42:
 1634               	.LBE41:
 1635               	.LBE40:
 1636               	.LBE39:
1102:t6963.c       ****     // right_margin = (8 - (right_remain)) & 0x7;
1103:t6963.c       **** 
1104:t6963.c       ****     // Iterate over all of the rows.
1105:t6963.c       ****     for (row = 0; row < height; row += 8)
 1637               		.loc 1 1105 0
 1638 05e4 188E      		std Y+24,__zero_reg__
 1639 05e6 1F8A      		std Y+23,__zero_reg__
 1640               	.LBB69:
 1641               	.LBB56:
 1642               	.LBB57:
1106:t6963.c       ****     {
1107:t6963.c       ****         uint16_t buf_index;             // Index to buffer
1108:t6963.c       ****         uint8_t max_rows;               // The maximum number of rows
1109:t6963.c       ****         uint8_t ii;                     // General iterator
1110:t6963.c       **** 
1111:t6963.c       ****         /* Convert all of the data */
1112:t6963.c       ****         for (col = 0; col < length; col += 8)
1113:t6963.c       ****         {
1114:t6963.c       ****             uint8_t right_index;
1115:t6963.c       ****             uint8_t left_index;
1116:t6963.c       ****             uint8_t fbuf [8];
1117:t6963.c       **** 
1118:t6963.c       ****             // Process the first row.
1119:t6963.c       ****             left_index = 0;
1120:t6963.c       ****             if (col == 0)
1121:t6963.c       ****                 left_index = left_margin;
1122:t6963.c       ****             right_index = 8;
1123:t6963.c       ****             if ((length - col) < 8)
1124:t6963.c       ****                 right_index = right_remain;
1125:t6963.c       **** 
1126:t6963.c       ****             // Read in the data.
1127:t6963.c       ****             do
1128:t6963.c       ****             {
1129:t6963.c       ****                 uint8_t datum;
1130:t6963.c       **** 
1131:t6963.c       ****                 // Write the data data to the buffer
1132:t6963.c       ****                 if (data == NULL)
1133:t6963.c       ****                 {
1134:t6963.c       ****                     // Collect the data from serial.
1135:t6963.c       ****                     datum = serial_getc ();
1136:t6963.c       ****                 }
1137:t6963.c       ****                 else
1138:t6963.c       ****                 {
1139:t6963.c       ****                     // Collect the data from the parameter.
1140:t6963.c       ****                     datum = *data;
1141:t6963.c       **** 
1142:t6963.c       ****                     // Advance the datum if we are not in fill mode.
1143:t6963.c       ****                     if ((mode & MODE_FILL) == 0)
1144:t6963.c       ****                         data++;
1145:t6963.c       ****                 }
1146:t6963.c       **** 
1147:t6963.c       ****                 // Save the data in the local buffer prior to conversion
1148:t6963.c       ****                 fbuf [left_index] = datum;
 1643               		.loc 1 1148 0
 1644 05e8 6E01      		movw r12,r28
 1645 05ea E9E0      		ldi r30,9
 1646 05ec CE0E      		add r12,r30
 1647 05ee D11C      		adc r13,__zero_reg__
 1648 05f0 9E01      		movw r18,r28
 1649 05f2 2F5F      		subi r18,-1
 1650 05f4 3F4F      		sbci r19,-1
 1651 05f6 3A8B      		std Y+18,r19
 1652 05f8 298B      		std Y+17,r18
 1653 05fa CE01      		movw r24,r28
 1654               	.LVL194:
 1655 05fc 4196      		adiw r24,17
 1656 05fe 9C8B      		std Y+20,r25
 1657 0600 8B8B      		std Y+19,r24
 1658               	.LBE57:
 1659               	.LBE56:
 1660               	.LBB63:
 1661               	.LBB53:
 1662               	.LBB47:
 1663               	.LBB43:
 999:t6963.c       ****         valid_mask = pgm_read_byte (&bit_shift_maskP[ii]);
 1664               		.loc 1 999 0
 1665 0602 FE89      		ldd r31,Y+22
 1666 0604 EF2F      		mov r30,r31
 1667 0606 F0E0      		ldi r31,0
 1668 0608 E050      		subi r30,lo8(-(bit_shift_maskP))
 1669 060a F040      		sbci r31,hi8(-(bit_shift_maskP))
 1670 060c FC8F      		std Y+28,r31
 1671 060e EB8F      		std Y+27,r30
 1672               	.LVL195:
 1673               	.L85:
 1674 0610 FF88      		ldd r15,Y+23
 1675 0612 FF0C      		lsl r15
 1676 0614 FF0C      		lsl r15
 1677 0616 FF0C      		lsl r15
 1678               	.LVL196:
 1679               	.LBE43:
 1680               	.LBE47:
 1681               	.LBE53:
 1682               	.LBE63:
 1683               	.LBE69:
1105:t6963.c       ****     for (row = 0; row < height; row += 8)
 1684               		.loc 1 1105 0 discriminator 1
 1685 0618 9E8D      		ldd r25,Y+30
 1686 061a F916      		cp r15,r25
 1687 061c 00F0      		brlo .+2
 1688 061e 00C0      		rjmp .L84
1105:t6963.c       ****     for (row = 0; row < height; row += 8)
 1689               		.loc 1 1105 0 is_stmt 0
 1690 0620 00E0      		ldi r16,0
 1691               	.LBB70:
 1692               	.LBB64:
 1693               	.LBB58:
1143:t6963.c       ****                     if ((mode & MODE_FILL) == 0)
 1694               		.loc 1 1143 0 is_stmt 1
 1695 0622 998D      		ldd r25,Y+25
 1696 0624 9870      		andi r25,lo8(8)
 1697 0626 E92E      		mov r14,r25
 1698               	.L110:
 1699               	.LVL197:
 1700               	.LBE58:
 1701               	.LBE64:
1112:t6963.c       ****         for (col = 0; col < length; col += 8)
 1702               		.loc 1 1112 0 discriminator 1
 1703 0628 9D89      		ldd r25,Y+21
 1704 062a 0917      		cp r16,r25
 1705 062c 00F0      		brlo .+2
 1706 062e 00C0      		rjmp .L124
 1707               	.LVL198:
 1708               	.LBB65:
1120:t6963.c       ****             if (col == 0)
 1709               		.loc 1 1120 0
 1710 0630 0023      		tst r16
 1711 0632 01F0      		breq .L111
1119:t6963.c       ****             left_index = 0;
 1712               		.loc 1 1119 0
 1713 0634 812C      		mov r8,__zero_reg__
 1714 0636 00C0      		rjmp .L86
 1715               	.L111:
 1716               	.LBE65:
 1717               	.LBE70:
1094:t6963.c       ****     left_margin = (x & 7);              // The left margin
 1718               		.loc 1 1094 0
 1719 0638 8E88      		ldd r8,Y+22
 1720               	.L86:
 1721               	.LVL199:
 1722               	.LBB71:
 1723               	.LBB66:
1123:t6963.c       ****             if ((length - col) < 8)
 1724               		.loc 1 1123 0
 1725 063a C101      		movw r24,r2
 1726 063c 801B      		sub r24,r16
 1727 063e 9109      		sbc r25,__zero_reg__
 1728 0640 0897      		sbiw r24,8
 1729 0642 04F0      		brlt .L112
1122:t6963.c       ****             right_index = 8;
 1730               		.loc 1 1122 0
 1731 0644 88E0      		ldi r24,lo8(8)
 1732 0646 682E      		mov r6,r24
 1733 0648 00C0      		rjmp .L91
 1734               	.L112:
1124:t6963.c       ****                 right_index = right_remain;
 1735               		.loc 1 1124 0
 1736 064a 6F8C      		ldd r6,Y+31
 1737               	.LVL200:
 1738               	.L91:
 1739               	.LBB59:
1132:t6963.c       ****                 if (data == NULL)
 1740               		.loc 1 1132 0
 1741 064c A114      		cp r10,__zero_reg__
 1742 064e B104      		cpc r11,__zero_reg__
 1743 0650 01F4      		brne .L88
1135:t6963.c       ****                     datum = serial_getc ();
 1744               		.loc 1 1135 0
 1745 0652 0E94 0000 		call serial_getc
 1746               	.LVL201:
 1747 0656 00C0      		rjmp .L89
 1748               	.LVL202:
 1749               	.L88:
1140:t6963.c       ****                     datum = *data;
 1750               		.loc 1 1140 0
 1751 0658 F501      		movw r30,r10
 1752 065a 8081      		ld r24,Z
 1753               	.LVL203:
1143:t6963.c       ****                     if ((mode & MODE_FILL) == 0)
 1754               		.loc 1 1143 0
 1755 065c E110      		cpse r14,__zero_reg__
 1756 065e 00C0      		rjmp .L89
1144:t6963.c       ****                         data++;
 1757               		.loc 1 1144 0
 1758 0660 FFEF      		ldi r31,-1
 1759 0662 AF1A      		sub r10,r31
 1760 0664 BF0A      		sbc r11,r31
 1761               	.LVL204:
 1762               	.L89:
 1763               		.loc 1 1148 0
 1764 0666 F601      		movw r30,r12
 1765 0668 E80D      		add r30,r8
 1766 066a F11D      		adc r31,__zero_reg__
 1767 066c 8083      		st Z,r24
 1768               	.LBE59:
1149:t6963.c       ****             }
1150:t6963.c       ****             while (++left_index < right_index);
 1769               		.loc 1 1150 0
 1770 066e 8394      		inc r8
 1771               	.LVL205:
 1772 0670 8614      		cp r8,r6
 1773 0672 00F0      		brlo .L91
 1774 0674 DE01      		movw r26,r28
 1775 0676 5196      		adiw r26,17
 1776               	.LVL206:
 1777               	.L95:
 1778               	.LBB60:
 1779               	.LBB61:
 1780               	.LBB62:
 955:t6963.c       ****         uint8_t datum = buf[yy];
 1781               		.loc 1 955 0
 1782 0678 8E91      		ld r24,-X
 1783               	.LVL207:
 1784 067a F601      		movw r30,r12
 1785               	.LVL208:
 1786               	.L93:
 959:t6963.c       ****             dest[xx] = (dest[xx] >> 1) | (datum & 0x80);
 1787               		.loc 1 959 0
 1788 067c 982F      		mov r25,r24
 1789 067e 9078      		andi r25,lo8(-128)
 1790 0680 2291      		ld r18,-Z
 1791 0682 2695      		lsr r18
 1792 0684 922B      		or r25,r18
 1793 0686 9083      		st Z,r25
 960:t6963.c       ****             datum <<= 1;
 1794               		.loc 1 960 0
 1795 0688 880F      		lsl r24
 1796               	.LVL209:
 962:t6963.c       ****         while (--xx >= 0);
 1797               		.loc 1 962 0
 1798 068a 2989      		ldd r18,Y+17
 1799 068c 3A89      		ldd r19,Y+18
 1800 068e E217      		cp r30,r18
 1801 0690 F307      		cpc r31,r19
 1802 0692 01F4      		brne .L93
 1803               	.LBE62:
 964:t6963.c       ****     while (--yy >= 0);
 1804               		.loc 1 964 0
 1805 0694 AC15      		cp r26,r12
 1806 0696 BD05      		cpc r27,r13
 1807 0698 01F4      		brne .L95
 1808 069a DE01      		movw r26,r28
 1809 069c 5196      		adiw r26,17
 1810 069e F601      		movw r30,r12
 1811               	.LVL210:
 1812               	.L97:
 970:t6963.c       ****         buf[xx] = dest[xx];
 1813               		.loc 1 970 0
 1814 06a0 8291      		ld r24,-Z
 1815 06a2 8E93      		st -X,r24
 972:t6963.c       ****     while (--xx >= 0);
 1816               		.loc 1 972 0
 1817 06a4 8989      		ldd r24,Y+17
 1818 06a6 9A89      		ldd r25,Y+18
 1819 06a8 E817      		cp r30,r24
 1820 06aa F907      		cpc r31,r25
 1821 06ac 01F4      		brne .L97
 1822               	.LBE61:
 1823               	.LBE60:
1151:t6963.c       **** 
1152:t6963.c       ****             // Flip the data from vertical to horizontal
1153:t6963.c       ****             flip_8x8_v_to_h (fbuf);
1154:t6963.c       **** 
1155:t6963.c       ****             // Organise in the correct position in the horizontal line such
1156:t6963.c       ****             // that the horizontal blocks are separated by a line width.
1157:t6963.c       ****             buf_index = col >> 3;
 1824               		.loc 1 1157 0
 1825 06ae 802F      		mov r24,r16
 1826 06b0 8695      		lsr r24
 1827 06b2 8695      		lsr r24
 1828 06b4 8695      		lsr r24
 1829 06b6 90E0      		ldi r25,0
 1830               	.LVL211:
 1831 06b8 F601      		movw r30,r12
 1832               	.LVL212:
 1833               	.L99:
1158:t6963.c       ****             for (ii = 0; ii < 8; ii++)
1159:t6963.c       ****             {
1160:t6963.c       ****                 draw_buffer [buf_index] = fbuf[ii];
 1834               		.loc 1 1160 0 discriminator 2
 1835 06ba 2191      		ld r18,Z+
 1836 06bc DC01      		movw r26,r24
 1837 06be A050      		subi r26,lo8(-(draw_buffer))
 1838 06c0 B040      		sbci r27,hi8(-(draw_buffer))
 1839 06c2 2C93      		st X,r18
1161:t6963.c       ****                 buf_index += row_inc;
 1840               		.loc 1 1161 0 discriminator 2
 1841 06c4 840D      		add r24,r4
 1842 06c6 951D      		adc r25,r5
 1843               	.LVL213:
1158:t6963.c       ****             for (ii = 0; ii < 8; ii++)
 1844               		.loc 1 1158 0 discriminator 2
 1845 06c8 2B89      		ldd r18,Y+19
 1846 06ca 3C89      		ldd r19,Y+20
 1847 06cc E217      		cp r30,r18
 1848 06ce F307      		cpc r31,r19
 1849 06d0 01F4      		brne .L99
 1850               	.LBE66:
1112:t6963.c       ****         for (col = 0; col < length; col += 8)
 1851               		.loc 1 1112 0
 1852 06d2 085F      		subi r16,lo8(-(8))
 1853               	.LVL214:
 1854 06d4 00C0      		rjmp .L110
 1855               	.LVL215:
 1856               	.L124:
 1857 06d6 8E8D      		ldd r24,Y+30
 1858 06d8 8F19      		sub r24,r15
 1859 06da 8930      		cpi r24,lo8(9)
 1860 06dc 00F0      		brlo .L101
 1861 06de 88E0      		ldi r24,lo8(8)
 1862               	.L101:
 1863 06e0 810F      		add r24,r17
 1864 06e2 8AA3      		std Y+34,r24
1162:t6963.c       ****             }
1163:t6963.c       ****         }
1164:t6963.c       **** 
1165:t6963.c       ****         // Display the data row. Calculate the chung of data we have buffered
1166:t6963.c       ****         // and the position in the buffer.
1167:t6963.c       ****         max_rows = height - row;
1168:t6963.c       ****         if (max_rows > 8)
1169:t6963.c       ****             max_rows = 8;
1170:t6963.c       **** 
1171:t6963.c       ****         // Iterate over the rows
1172:t6963.c       ****         for (buf_index = 0, ii = 0; ii < max_rows; ii++)
 1865               		.loc 1 1172 0
 1866 06e4 612C      		mov r6,__zero_reg__
 1867 06e6 712C      		mov r7,__zero_reg__
 1868               	.LBB67:
 1869               	.LBB54:
 1870               	.LBB48:
1041:t6963.c       ****         t6963_set_row (x + ii, y, data[ii], valid_mask, mode | MODE_MERGE);
 1871               		.loc 1 1041 0
 1872 06e8 998D      		ldd r25,Y+25
 1873 06ea 9061      		ori r25,lo8(16)
 1874 06ec 9A8F      		std Y+26,r25
 1875               	.LBE48:
 1876               	.LBB50:
1020:t6963.c       ****         width -= 8;
 1877               		.loc 1 1020 0
 1878 06ee 9D89      		ldd r25,Y+21
 1879 06f0 9850      		subi r25,lo8(-(-8))
 1880 06f2 9BA3      		std Y+35,r25
 1881               	.LBB44:
1011:t6963.c       ****                 valid_mask &= ~pgm_read_byte (&bit_shift_maskP[width]);
 1882               		.loc 1 1011 0
 1883 06f4 F101      		movw r30,r2
 1884 06f6 E050      		subi r30,lo8(-(bit_shift_maskP))
 1885 06f8 F040      		sbci r31,hi8(-(bit_shift_maskP))
 1886 06fa FDA3      		std Y+37,r31
 1887 06fc ECA3      		std Y+36,r30
 1888               	.LVL216:
 1889               	.L102:
 1890               	.LBE44:
 1891               	.LBE50:
 1892               	.LBE54:
 1893               	.LBE67:
 1894               		.loc 1 1172 0 discriminator 1
 1895 06fe 9AA1      		ldd r25,Y+34
 1896 0700 1917      		cp r17,r25
 1897 0702 01F4      		brne .+2
 1898 0704 00C0      		rjmp .L125
1173:t6963.c       ****         {
1174:t6963.c       ****             // Write the line.
1175:t6963.c       ****             bitblt_line (x, y++, width, &draw_buffer [buf_index], mode);
 1899               		.loc 1 1175 0 discriminator 2
 1900 0706 9301      		movw r18,r6
 1901 0708 2050      		subi r18,lo8(-(draw_buffer))
 1902 070a 3040      		sbci r19,hi8(-(draw_buffer))
 1903 070c 7901      		movw r14,r18
 1904 070e 91E0      		ldi r25,lo8(1)
 1905 0710 910F      		add r25,r17
 1906 0712 98A3      		std Y+32,r25
 1907               	.LVL217:
 1908 0714 D901      		movw r26,r18
 1909               	.LBB68:
 1910               	.LBB55:
 994:t6963.c       ****     if (ii != 0)
 1911               		.loc 1 994 0 discriminator 2
 1912 0716 9E89      		ldd r25,Y+22
 1913               	.LVL218:
 1914 0718 9923      		tst r25
 1915 071a 01F0      		breq .L113
 1916               	.LVL219:
 1917               	.LBB51:
 1918               	.LBB45:
 999:t6963.c       ****         valid_mask = pgm_read_byte (&bit_shift_maskP[ii]);
 1919               		.loc 1 999 0
 1920 071c EB8D      		ldd r30,Y+27
 1921 071e FC8D      		ldd r31,Y+28
 1922               	/* #APP */
 1923               	 ;  999 "t6963.c" 1
 1924 0720 2491      		lpm r18, Z
 1925               		
 1926               	 ;  0 "" 2
 1927               	.LVL220:
 1928               	/* #NOAPP */
 1929               	.LBE45:
1003:t6963.c       ****         if (width <= 8)
 1930               		.loc 1 1003 0
 1931 0722 9D89      		ldd r25,Y+21
 1932 0724 9930      		cpi r25,lo8(9)
 1933 0726 00F4      		brsh .L104
1006:t6963.c       ****             if (width < 8)
 1934               		.loc 1 1006 0
 1935 0728 9830      		cpi r25,lo8(8)
 1936 072a 01F0      		breq .L105
 1937               	.LVL221:
 1938               	.LBB46:
1011:t6963.c       ****                 valid_mask &= ~pgm_read_byte (&bit_shift_maskP[width]);
 1939               		.loc 1 1011 0
 1940 072c ECA1      		ldd r30,Y+36
 1941 072e FDA1      		ldd r31,Y+37
 1942               	/* #APP */
 1943               	 ;  1011 "t6963.c" 1
 1944 0730 8491      		lpm r24, Z
 1945               		
 1946               	 ;  0 "" 2
 1947               	.LVL222:
 1948               	/* #NOAPP */
 1949               	.LBE46:
 1950 0732 8095      		com r24
 1951               	.LVL223:
 1952 0734 2823      		and r18,r24
 1953               	.LVL224:
 1954               	.L105:
1015:t6963.c       ****             t6963_set_row (x, y, *data++, valid_mask, mode | MODE_MERGE);
 1955               		.loc 1 1015 0
 1956 0736 0A8D      		ldd r16,Y+26
 1957 0738 F701      		movw r30,r14
 1958 073a 4081      		ld r20,Z
 1959 073c 612F      		mov r22,r17
 1960 073e 892D      		mov r24,r9
 1961 0740 00C0      		rjmp .L123
 1962               	.LVL225:
 1963               	.L104:
1020:t6963.c       ****         width -= 8;
 1964               		.loc 1 1020 0
 1965 0742 7BA1      		ldd r23,Y+35
 1966               	.LVL226:
1022:t6963.c       ****         t6963_set_row (x++, y, *data++, valid_mask, mode | MODE_MERGE);
 1967               		.loc 1 1022 0
 1968 0744 FFEF      		ldi r31,-1
 1969 0746 EF1A      		sub r14,r31
 1970 0748 FF0A      		sbc r15,r31
 1971               	.LVL227:
 1972 074a 0A8D      		ldd r16,Y+26
 1973 074c 4C91      		ld r20,X
 1974 074e 612F      		mov r22,r17
 1975 0750 892D      		mov r24,r9
 1976 0752 7FA3      		std Y+39,r23
 1977 0754 0E94 0000 		call t6963_set_row
 1978               	.LVL228:
 1979 0758 99A1      		ldd r25,Y+33
 1980 075a 7FA1      		ldd r23,Y+39
 1981 075c 00C0      		rjmp .L103
 1982               	.LVL229:
 1983               	.L113:
 1984               	.LBE51:
 994:t6963.c       ****     if (ii != 0)
 1985               		.loc 1 994 0
 1986 075e 7D8D      		ldd r23,Y+29
 993:t6963.c       ****     x >>= 3;                            // Convert to column address
 1987               		.loc 1 993 0
 1988 0760 992D      		mov r25,r9
 1989               	.LVL230:
 1990               	.L103:
1026:t6963.c       ****     if ((ii = (width >> 3)) > 0)
 1991               		.loc 1 1026 0
 1992 0762 872E      		mov r8,r23
 1993 0764 8694      		lsr r8
 1994 0766 8694      		lsr r8
 1995 0768 8694      		lsr r8
 1996               	.LVL231:
 1997 076a 01F0      		breq .L107
1029:t6963.c       ****         t6963_rewrite_row (x, y, ii, data, mode);
 1998               		.loc 1 1029 0
 1999 076c 482D      		mov r20,r8
 2000 076e 50E0      		ldi r21,0
 2001 0770 098D      		ldd r16,Y+25
 2002 0772 9701      		movw r18,r14
 2003 0774 612F      		mov r22,r17
 2004 0776 892F      		mov r24,r25
 2005 0778 7FA3      		std Y+39,r23
 2006 077a 9EA3      		std Y+38,r25
 2007 077c 0E94 0000 		call t6963_rewrite_row
 2008               	.LVL232:
 2009 0780 9EA1      		ldd r25,Y+38
 2010 0782 7FA1      		ldd r23,Y+39
 2011               	.L107:
1033:t6963.c       ****     width &= 7;
 2012               		.loc 1 1033 0
 2013 0784 7770      		andi r23,lo8(7)
 2014               	.LVL233:
1034:t6963.c       ****     if (width > 0)
 2015               		.loc 1 1034 0
 2016 0786 01F0      		breq .L106
 2017               	.LVL234:
 2018               	.LBB52:
 2019               	.LBB49:
1040:t6963.c       ****         valid_mask = ~pgm_read_byte (&bit_shift_maskP[width]);
 2020               		.loc 1 1040 0
 2021 0788 E72F      		mov r30,r23
 2022 078a F0E0      		ldi r31,0
 2023 078c E050      		subi r30,lo8(-(bit_shift_maskP))
 2024 078e F040      		sbci r31,hi8(-(bit_shift_maskP))
 2025               	/* #APP */
 2026               	 ;  1040 "t6963.c" 1
 2027 0790 2491      		lpm r18, Z
 2028               		
 2029               	 ;  0 "" 2
 2030               	.LVL235:
 2031               	/* #NOAPP */
 2032               	.LBE49:
 2033 0792 2095      		com r18
 2034               	.LVL236:
1041:t6963.c       ****         t6963_set_row (x + ii, y, data[ii], valid_mask, mode | MODE_MERGE);
 2035               		.loc 1 1041 0
 2036 0794 D701      		movw r26,r14
 2037 0796 A80D      		add r26,r8
 2038 0798 B11D      		adc r27,__zero_reg__
 2039 079a 0A8D      		ldd r16,Y+26
 2040 079c 4C91      		ld r20,X
 2041 079e 612F      		mov r22,r17
 2042 07a0 882D      		mov r24,r8
 2043 07a2 890F      		add r24,r25
 2044               	.LVL237:
 2045               	.L123:
 2046 07a4 0E94 0000 		call t6963_set_row
 2047               	.LVL238:
 2048               	.L106:
 2049               	.LBE52:
 2050               	.LBE55:
 2051               	.LBE68:
1176:t6963.c       ****             buf_index += row_inc;
 2052               		.loc 1 1176 0 discriminator 2
 2053 07a8 640C      		add r6,r4
 2054 07aa 751C      		adc r7,r5
 2055               	.LVL239:
1175:t6963.c       ****             bitblt_line (x, y++, width, &draw_buffer [buf_index], mode);
 2056               		.loc 1 1175 0 discriminator 2
 2057 07ac 18A1      		ldd r17,Y+32
 2058 07ae 00C0      		rjmp .L102
 2059               	.LVL240:
 2060               	.L125:
 2061 07b0 EF89      		ldd r30,Y+23
 2062 07b2 F88D      		ldd r31,Y+24
 2063 07b4 3196      		adiw r30,1
 2064 07b6 F88F      		std Y+24,r31
 2065 07b8 EF8B      		std Y+23,r30
 2066               	.LVL241:
 2067 07ba 00C0      		rjmp .L85
 2068               	.LVL242:
 2069               	.L84:
 2070               	/* epilogue start */
 2071               	.LBE71:
1177:t6963.c       ****         }
1178:t6963.c       ****     }
1179:t6963.c       **** }
 2072               		.loc 1 1179 0
 2073 07bc A796      		adiw r28,39
 2074 07be 0FB6      		in __tmp_reg__,__SREG__
 2075 07c0 F894      		cli
 2076 07c2 DEBF      		out __SP_H__,r29
 2077 07c4 0FBE      		out __SREG__,__tmp_reg__
 2078 07c6 CDBF      		out __SP_L__,r28
 2079 07c8 DF91      		pop r29
 2080 07ca CF91      		pop r28
 2081 07cc 1F91      		pop r17
 2082               	.LVL243:
 2083 07ce 0F91      		pop r16
 2084 07d0 FF90      		pop r15
 2085               	.LVL244:
 2086 07d2 EF90      		pop r14
 2087 07d4 DF90      		pop r13
 2088 07d6 CF90      		pop r12
 2089 07d8 BF90      		pop r11
 2090 07da AF90      		pop r10
 2091               	.LVL245:
 2092 07dc 9F90      		pop r9
 2093 07de 8F90      		pop r8
 2094 07e0 7F90      		pop r7
 2095 07e2 6F90      		pop r6
 2096 07e4 5F90      		pop r5
 2097 07e6 4F90      		pop r4
 2098               	.LVL246:
 2099 07e8 3F90      		pop r3
 2100 07ea 2F90      		pop r2
 2101               	.LVL247:
 2102 07ec 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE29:
 2106               	.global	t6963_hline
 2108               	t6963_hline:
 2109               	.LFB30:
1180:t6963.c       **** 
1181:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
1182:t6963.c       **** /// Draw a horizontal line
1183:t6963.c       **** ///
1184:t6963.c       **** /// @param [in] x The first x-coordinate.
1185:t6963.c       **** /// @param [in] y The first y-coordinate.
1186:t6963.c       **** /// @param [in] x1 The 2nd x-coordinate.
1187:t6963.c       **** /// @param [in] mode The drawing mode.
1188:t6963.c       **** ///
1189:t6963.c       **** void
1190:t6963.c       **** t6963_hline (uint8_t x, uint8_t y, uint8_t x1, uint8_t mode)
1191:t6963.c       **** {
 2110               		.loc 1 1191 0
 2111               		.cfi_startproc
 2112               	.LVL248:
 2113 07ee EF92      		push r14
 2114               	.LCFI78:
 2115               		.cfi_def_cfa_offset 3
 2116               		.cfi_offset 14, -2
 2117 07f0 FF92      		push r15
 2118               	.LCFI79:
 2119               		.cfi_def_cfa_offset 4
 2120               		.cfi_offset 15, -3
 2121 07f2 0F93      		push r16
 2122               	.LCFI80:
 2123               		.cfi_def_cfa_offset 5
 2124               		.cfi_offset 16, -4
 2125 07f4 1F93      		push r17
 2126               	.LCFI81:
 2127               		.cfi_def_cfa_offset 6
 2128               		.cfi_offset 17, -5
 2129 07f6 CF93      		push r28
 2130               	.LCFI82:
 2131               		.cfi_def_cfa_offset 7
 2132               		.cfi_offset 28, -6
 2133 07f8 DF93      		push r29
 2134               	.LCFI83:
 2135               		.cfi_def_cfa_offset 8
 2136               		.cfi_offset 29, -7
 2137               	/* prologue: function */
 2138               	/* frame size = 0 */
 2139               	/* stack size = 6 */
 2140               	.L__stack_usage = 6
 2141 07fa 162F      		mov r17,r22
 2142 07fc F22E      		mov r15,r18
 2143               	.LVL249:
1192:t6963.c       ****     uint8_t width;                      // Width of line.
1193:t6963.c       ****     // Use the draw_buffer. We offset at 128 because all functions that use
1194:t6963.c       ****     // the draw buffer are restricted to 128 bytes. The biggest user is
1195:t6963.c       ****     // polygon fill.
1196:t6963.c       ****     uint8_t *buffer = (draw_buffer + 128);
1197:t6963.c       ****     //uint8_t buffer [SCREEN_COLUMNS];  // Stack based if we have room
1198:t6963.c       **** 
1199:t6963.c       ****     // Check for a single pixeland handle imediately, no savings to be made.
1200:t6963.c       ****     if (x == x1)
 2144               		.loc 1 1200 0
 2145 07fe 8413      		cpse r24,r20
 2146 0800 00C0      		rjmp .L127
1201:t6963.c       ****     {
1202:t6963.c       ****         t6963_set_pixel (x, y, mode);
 2147               		.loc 1 1202 0
 2148 0802 422F      		mov r20,r18
 2149               	.LVL250:
 2150               	/* epilogue start */
1203:t6963.c       ****         return;
1204:t6963.c       ****     }
1205:t6963.c       **** 
1206:t6963.c       ****     // Swap the bytes to ensure x is smaller than x1.
1207:t6963.c       ****     if (x > x1)
1208:t6963.c       ****         swap_bytes (x, x1);
1209:t6963.c       **** 
1210:t6963.c       **** #if 0
1211:t6963.c       ****     // Simply using set_pixel; used for testing to confirm that this function is OK.
1212:t6963.c       ****     while (x <= x1)
1213:t6963.c       ****         t6963_set_pixel (x++, y, mode);
1214:t6963.c       ****     return;
1215:t6963.c       **** #endif
1216:t6963.c       **** 
1217:t6963.c       ****     width = (x1 - x) + 1;               // Calculate the width
1218:t6963.c       ****     x1 = x & 7;                         // Get the offset to start of block
1219:t6963.c       ****     x >>= 3;                            // Get the column index
1220:t6963.c       ****     if (x1 != 0)                        // Not on boundary?
1221:t6963.c       ****     {
1222:t6963.c       ****         uint8_t valid_mask;             // Mask for the valid bits to write.
1223:t6963.c       **** 
1224:t6963.c       ****         // Compute the valid mask i.e. 0xff >> x1
1225:t6963.c       ****         valid_mask = pgm_read_byte (&bit_shift_maskP[x1]);
1226:t6963.c       ****         width += x1;                    // Add the sub-block start to width
1227:t6963.c       **** 
1228:t6963.c       ****         // Add any right mask if we have a short block
1229:t6963.c       ****         if (width < 8)
1230:t6963.c       ****         {
1231:t6963.c       ****             // This is a short block, the data does not occupy the block.
1232:t6963.c       ****             // Modify the mask to handle the right of the data.
1233:t6963.c       ****             // i.e. valid_mask &= ~((1 << (8 - width)) - 1);
1234:t6963.c       ****             valid_mask &= ~pgm_read_byte (&bit_shift_maskP[width]);
1235:t6963.c       ****         }
1236:t6963.c       ****         
1237:t6963.c       ****         // Write the start of row.
1238:t6963.c       ****         t6963_set_row (x, y, valid_mask, valid_mask, mode | MODE_MERGE);
1239:t6963.c       ****         
1240:t6963.c       ****         // Deal quickly with a single block.
1241:t6963.c       ****         if (width <= 8)
1242:t6963.c       ****             return;                     // Finished, quit now.
1243:t6963.c       ****         width -= 8;
1244:t6963.c       ****         x++;
1245:t6963.c       ****     }
1246:t6963.c       ****     
1247:t6963.c       ****     // Process the whole blocks; convert to a column count
1248:t6963.c       ****     if ((x1 = (width >> 3)) > 0)
1249:t6963.c       ****     {
1250:t6963.c       ****         uint8_t offset = 0;
1251:t6963.c       ****         
1252:t6963.c       ****         do
1253:t6963.c       ****         {
1254:t6963.c       ****             buffer[offset++] = 0xff;
1255:t6963.c       ****         }
1256:t6963.c       ****         while (--x1 > 0);
1257:t6963.c       ****         
1258:t6963.c       ****         // Write the data
1259:t6963.c       ****         t6963_rewrite_row (x, y, offset, buffer, mode);
1260:t6963.c       ****         
1261:t6963.c       ****         // Advance x over the data written.
1262:t6963.c       ****         x += offset;
1263:t6963.c       ****     }
1264:t6963.c       **** 
1265:t6963.c       ****     // Process any remaining block
1266:t6963.c       ****     width &= 0x07;
1267:t6963.c       ****     if (width > 0)
1268:t6963.c       ****     {
1269:t6963.c       ****         uint8_t valid_mask;
1270:t6963.c       ****         
1271:t6963.c       ****         // Create the mask of valid bits.
1272:t6963.c       ****         // buffer[offset++] = ~((uint8_t)(1 << (8 - width)) - 1);
1273:t6963.c       ****         valid_mask = ~pgm_read_byte (&bit_shift_maskP[width]);
1274:t6963.c       ****         t6963_set_row (x, y, valid_mask, valid_mask, mode|MODE_MERGE);
1275:t6963.c       ****     }
1276:t6963.c       **** }
 2151               		.loc 1 1276 0
 2152 0804 DF91      		pop r29
 2153 0806 CF91      		pop r28
 2154 0808 1F91      		pop r17
 2155 080a 0F91      		pop r16
 2156 080c FF90      		pop r15
 2157 080e EF90      		pop r14
1202:t6963.c       ****         t6963_set_pixel (x, y, mode);
 2158               		.loc 1 1202 0
 2159 0810 0C94 0000 		jmp t6963_set_pixel
 2160               	.LVL251:
 2161               	.L127:
1207:t6963.c       ****     if (x > x1)
 2162               		.loc 1 1207 0
 2163 0814 4817      		cp r20,r24
 2164 0816 00F4      		brsh .L128
1208:t6963.c       ****         swap_bytes (x, x1);
 2165               		.loc 1 1208 0
 2166 0818 8427      		eor r24,r20
 2167               	.LVL252:
 2168 081a 4827      		eor r20,r24
 2169               	.LVL253:
 2170 081c 8427      		eor r24,r20
 2171               	.LVL254:
 2172               	.L128:
1217:t6963.c       ****     width = (x1 - x) + 1;               // Calculate the width
 2173               		.loc 1 1217 0
 2174 081e D1E0      		ldi r29,lo8(1)
 2175 0820 D40F      		add r29,r20
 2176 0822 D81B      		sub r29,r24
 2177               	.LVL255:
1218:t6963.c       ****     x1 = x & 7;                         // Get the offset to start of block
 2178               		.loc 1 1218 0
 2179 0824 982F      		mov r25,r24
 2180 0826 9770      		andi r25,lo8(7)
 2181               	.LVL256:
1219:t6963.c       ****     x >>= 3;                            // Get the column index
 2182               		.loc 1 1219 0
 2183 0828 C82F      		mov r28,r24
 2184 082a C695      		lsr r28
 2185 082c C695      		lsr r28
 2186 082e C695      		lsr r28
 2187               	.LVL257:
1220:t6963.c       ****     if (x1 != 0)                        // Not on boundary?
 2188               		.loc 1 1220 0
 2189 0830 9923      		tst r25
 2190 0832 01F0      		breq .L129
 2191               	.LVL258:
 2192               	.LBB72:
 2193               	.LBB73:
1225:t6963.c       ****         valid_mask = pgm_read_byte (&bit_shift_maskP[x1]);
 2194               		.loc 1 1225 0
 2195 0834 E92F      		mov r30,r25
 2196 0836 F0E0      		ldi r31,0
 2197 0838 E050      		subi r30,lo8(-(bit_shift_maskP))
 2198 083a F040      		sbci r31,hi8(-(bit_shift_maskP))
 2199               	/* #APP */
 2200               	 ;  1225 "t6963.c" 1
 2201 083c 4491      		lpm r20, Z
 2202               		
 2203               	 ;  0 "" 2
 2204               	.LVL259:
 2205               	/* #NOAPP */
 2206               	.LBE73:
1226:t6963.c       ****         width += x1;                    // Add the sub-block start to width
 2207               		.loc 1 1226 0
 2208 083e D90F      		add r29,r25
 2209               	.LVL260:
1229:t6963.c       ****         if (width < 8)
 2210               		.loc 1 1229 0
 2211 0840 D830      		cpi r29,lo8(8)
 2212 0842 00F4      		brsh .L130
 2213               	.LVL261:
 2214               	.LBB74:
1234:t6963.c       ****             valid_mask &= ~pgm_read_byte (&bit_shift_maskP[width]);
 2215               		.loc 1 1234 0
 2216 0844 ED2F      		mov r30,r29
 2217 0846 F0E0      		ldi r31,0
 2218 0848 E050      		subi r30,lo8(-(bit_shift_maskP))
 2219 084a F040      		sbci r31,hi8(-(bit_shift_maskP))
 2220               	/* #APP */
 2221               	 ;  1234 "t6963.c" 1
 2222 084c E491      		lpm r30, Z
 2223               		
 2224               	 ;  0 "" 2
 2225               	.LVL262:
 2226               	/* #NOAPP */
 2227               	.LBE74:
 2228 084e E095      		com r30
 2229               	.LVL263:
 2230 0850 4E23      		and r20,r30
 2231               	.LVL264:
 2232               	.L130:
1238:t6963.c       ****         t6963_set_row (x, y, valid_mask, valid_mask, mode | MODE_MERGE);
 2233               		.loc 1 1238 0
 2234 0852 0F2D      		mov r16,r15
 2235 0854 0061      		ori r16,lo8(16)
 2236 0856 242F      		mov r18,r20
 2237 0858 612F      		mov r22,r17
 2238 085a 8C2F      		mov r24,r28
 2239 085c 0E94 0000 		call t6963_set_row
 2240               	.LVL265:
1241:t6963.c       ****         if (width <= 8)
 2241               		.loc 1 1241 0
 2242 0860 D930      		cpi r29,lo8(9)
 2243 0862 00F0      		brlo .L126
1243:t6963.c       ****         width -= 8;
 2244               		.loc 1 1243 0
 2245 0864 D850      		subi r29,lo8(-(-8))
 2246               	.LVL266:
1244:t6963.c       ****         x++;
 2247               		.loc 1 1244 0
 2248 0866 CF5F      		subi r28,lo8(-(1))
 2249               	.LVL267:
 2250               	.L129:
 2251               	.LBE72:
1248:t6963.c       ****     if ((x1 = (width >> 3)) > 0)
 2252               		.loc 1 1248 0
 2253 0868 ED2E      		mov r14,r29
 2254 086a E694      		lsr r14
 2255 086c E694      		lsr r14
 2256 086e E694      		lsr r14
 2257               	.LVL268:
 2258 0870 01F0      		breq .L133
 2259 0872 A0E0      		ldi r26,0
 2260               	.LBB75:
1254:t6963.c       ****             buffer[offset++] = 0xff;
 2261               		.loc 1 1254 0
 2262 0874 9FEF      		ldi r25,lo8(-1)
 2263               	.LVL269:
 2264               	.L135:
1254:t6963.c       ****             buffer[offset++] = 0xff;
 2265               		.loc 1 1254 0 is_stmt 0 discriminator 1
 2266 0876 81E0      		ldi r24,lo8(1)
 2267 0878 8A0F      		add r24,r26
 2268               	.LVL270:
 2269 087a B0E0      		ldi r27,0
 2270 087c A050      		subi r26,lo8(-(draw_buffer+128))
 2271 087e B040      		sbci r27,hi8(-(draw_buffer+128))
 2272               	.LVL271:
 2273 0880 9C93      		st X,r25
 2274               	.LVL272:
1256:t6963.c       ****         while (--x1 > 0);
 2275               		.loc 1 1256 0 is_stmt 1 discriminator 1
 2276 0882 8E15      		cp r24,r14
 2277 0884 01F0      		breq .L134
1254:t6963.c       ****             buffer[offset++] = 0xff;
 2278               		.loc 1 1254 0
 2279 0886 A82F      		mov r26,r24
 2280 0888 00C0      		rjmp .L135
 2281               	.L134:
1259:t6963.c       ****         t6963_rewrite_row (x, y, offset, buffer, mode);
 2282               		.loc 1 1259 0
 2283 088a 4E2D      		mov r20,r14
 2284 088c 50E0      		ldi r21,0
 2285 088e 0F2D      		mov r16,r15
 2286 0890 20E0      		ldi r18,lo8(draw_buffer+128)
 2287 0892 30E0      		ldi r19,hi8(draw_buffer+128)
 2288               	.LVL273:
 2289 0894 612F      		mov r22,r17
 2290 0896 8C2F      		mov r24,r28
 2291               	.LVL274:
 2292 0898 0E94 0000 		call t6963_rewrite_row
 2293               	.LVL275:
1262:t6963.c       ****         x += offset;
 2294               		.loc 1 1262 0
 2295 089c CE0D      		add r28,r14
 2296               	.LVL276:
 2297               	.L133:
 2298               	.LBE75:
1266:t6963.c       ****     width &= 0x07;
 2299               		.loc 1 1266 0
 2300 089e D770      		andi r29,lo8(7)
 2301               	.LVL277:
1267:t6963.c       ****     if (width > 0)
 2302               		.loc 1 1267 0
 2303 08a0 01F0      		breq .L126
 2304               	.LVL278:
 2305               	.LBB76:
 2306               	.LBB77:
1273:t6963.c       ****         valid_mask = ~pgm_read_byte (&bit_shift_maskP[width]);
 2307               		.loc 1 1273 0
 2308 08a2 ED2F      		mov r30,r29
 2309 08a4 F0E0      		ldi r31,0
 2310 08a6 E050      		subi r30,lo8(-(bit_shift_maskP))
 2311 08a8 F040      		sbci r31,hi8(-(bit_shift_maskP))
 2312               	/* #APP */
 2313               	 ;  1273 "t6963.c" 1
 2314 08aa 4491      		lpm r20, Z
 2315               		
 2316               	 ;  0 "" 2
 2317               	.LVL279:
 2318               	/* #NOAPP */
 2319               	.LBE77:
 2320 08ac 4095      		com r20
 2321               	.LVL280:
1274:t6963.c       ****         t6963_set_row (x, y, valid_mask, valid_mask, mode|MODE_MERGE);
 2322               		.loc 1 1274 0
 2323 08ae 0F2D      		mov r16,r15
 2324 08b0 0061      		ori r16,lo8(16)
 2325 08b2 242F      		mov r18,r20
 2326 08b4 612F      		mov r22,r17
 2327 08b6 8C2F      		mov r24,r28
 2328 08b8 0E94 0000 		call t6963_set_row
 2329               	.LVL281:
 2330               	.L126:
 2331               	/* epilogue start */
 2332               	.LBE76:
 2333               		.loc 1 1276 0
 2334 08bc DF91      		pop r29
 2335               	.LVL282:
 2336 08be CF91      		pop r28
 2337               	.LVL283:
 2338 08c0 1F91      		pop r17
 2339               	.LVL284:
 2340 08c2 0F91      		pop r16
 2341 08c4 FF90      		pop r15
 2342               	.LVL285:
 2343 08c6 EF90      		pop r14
 2344 08c8 0895      		ret
 2345               		.cfi_endproc
 2346               	.LFE30:
 2348               	.global	t6963_vline
 2350               	t6963_vline:
 2351               	.LFB31:
1277:t6963.c       **** 
1278:t6963.c       **** /////////////////////////////////////////////////////////////////////////////
1279:t6963.c       **** /// Draw a vertical line. The fastest way to draw this is to set pixels.
1280:t6963.c       **** ///
1281:t6963.c       **** /// @param [in] x The first x-coordinate.
1282:t6963.c       **** /// @param [in] y The first y-coordinate.
1283:t6963.c       **** /// @param [in] y1 The 2nd y-coordinate.
1284:t6963.c       **** /// @param [in] mode The drawing mode.
1285:t6963.c       **** ///
1286:t6963.c       **** void
1287:t6963.c       **** t6963_vline (uint8_t x, uint8_t y, uint8_t y1, uint8_t mode)
1288:t6963.c       **** {
 2352               		.loc 1 1288 0
 2353               		.cfi_startproc
 2354               	.LVL286:
 2355 08ca FF92      		push r15
 2356               	.LCFI84:
 2357               		.cfi_def_cfa_offset 3
 2358               		.cfi_offset 15, -2
 2359 08cc 0F93      		push r16
 2360               	.LCFI85:
 2361               		.cfi_def_cfa_offset 4
 2362               		.cfi_offset 16, -3
 2363 08ce 1F93      		push r17
 2364               	.LCFI86:
 2365               		.cfi_def_cfa_offset 5
 2366               		.cfi_offset 17, -4
 2367 08d0 CF93      		push r28
 2368               	.LCFI87:
 2369               		.cfi_def_cfa_offset 6
 2370               		.cfi_offset 28, -5
 2371 08d2 DF93      		push r29
 2372               	.LCFI88:
 2373               		.cfi_def_cfa_offset 7
 2374               		.cfi_offset 29, -6
 2375 08d4 1F92      		push __zero_reg__
 2376               	.LCFI89:
 2377               		.cfi_def_cfa_offset 8
 2378 08d6 CDB7      		in r28,__SP_L__
 2379 08d8 DEB7      		in r29,__SP_H__
 2380               	.LCFI90:
 2381               		.cfi_def_cfa_register 28
 2382               	/* prologue: function */
 2383               	/* frame size = 1 */
 2384               	/* stack size = 6 */
 2385               	.L__stack_usage = 6
 2386 08da F82E      		mov r15,r24
 2387 08dc 042F      		mov r16,r20
1289:t6963.c       ****     // Swap the bytes so that we can iterate
1290:t6963.c       ****     if (y > y1)
 2388               		.loc 1 1290 0
 2389 08de 4617      		cp r20,r22
 2390 08e0 00F4      		brsh .L148
1291:t6963.c       ****         swap_bytes (y, y1);
 2391               		.loc 1 1291 0
 2392 08e2 6427      		eor r22,r20
 2393               	.LVL287:
 2394 08e4 0627      		eor r16,r22
 2395               	.LVL288:
 2396 08e6 6027      		eor r22,r16
 2397               	.LVL289:
 2398               	.L148:
1292:t6963.c       **** 
1293:t6963.c       ****     // Iterate between the two y coordinates.
1294:t6963.c       ****     while (y <= y1)
 2399               		.loc 1 1294 0 discriminator 1
 2400 08e8 0617      		cp r16,r22
 2401 08ea 00F0      		brlo .L150
1295:t6963.c       ****     {
1296:t6963.c       ****         t6963_set_pixel (x, y++, mode);
 2402               		.loc 1 1296 0
 2403 08ec 11E0      		ldi r17,lo8(1)
 2404 08ee 160F      		add r17,r22
 2405               	.LVL290:
 2406 08f0 422F      		mov r20,r18
 2407 08f2 8F2D      		mov r24,r15
 2408 08f4 2983      		std Y+1,r18
 2409 08f6 0E94 0000 		call t6963_set_pixel
 2410               	.LVL291:
 2411 08fa 612F      		mov r22,r17
 2412 08fc 2981      		ldd r18,Y+1
 2413 08fe 00C0      		rjmp .L148
 2414               	.LVL292:
 2415               	.L150:
 2416               	/* epilogue start */
1297:t6963.c       ****     }
1298:t6963.c       **** }
 2417               		.loc 1 1298 0
 2418 0900 0F90      		pop __tmp_reg__
 2419 0902 DF91      		pop r29
 2420 0904 CF91      		pop r28
 2421 0906 1F91      		pop r17
 2422 0908 0F91      		pop r16
 2423               	.LVL293:
 2424 090a FF90      		pop r15
 2425               	.LVL294:
 2426 090c 0895      		ret
 2427               		.cfi_endproc
 2428               	.LFE31:
 2430               		.data
 2433               	status_value:
 2434 0000 03        		.byte	3
 2435               		.comm	line_buffer,16,1
 2436               		.text
 2437               	.Letext0:
 2438               		.file 2 "/usr/local/CrossPack-AVR-20131216/lib/gcc/avr/4.8.1/include/stddef.h"
 2439               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 2440               		.file 4 "glcd.h"
 2441               		.file 5 "/usr/local/CrossPack-AVR-20131216/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:00000000 t6963.c
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:2      *ABS*:0000003e __SP_H__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:3      *ABS*:0000003d __SP_L__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:4      *ABS*:0000003f __SREG__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:6      *ABS*:00000001 __zero_reg__
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:11     .text:00000000 status_check
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:2433   .data:00000000 status_value
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:64     .text:0000002e data_write
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:148    .text:00000082 data_read
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:192    .text:000000aa cmd_write
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:271    .text:00000104 set_pointer
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:324    .text:00000134 set_column_pointer
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:374    .text:0000015e merge_row
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:422    .text:00000178 t6963_screen_clear
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:490    .text:000001b2 t6963_vscroll
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:642    .text:0000024e t6963_screen_reverse
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:760    .text:000002c6 t6963_init
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:820    .text:00000310 t6963_read_row
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:984    .text:000003ae t6963_write_row
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:1093   .text:00000408 t6963_rewrite_row
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:1271   .text:000004ac t6963_set_row
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:1386   .text:0000051a t6963_set_pixel
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:1492   .text:00000574 t6963_vbitblt
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:2108   .text:000007ee t6963_hline
/var/folders/9p/f4tvsj_905g4jdfps82fw6pr0000gn/T//ccfCe1hH.s:2350   .text:000008ca t6963_vline
                            *COM*:00000010 line_buffer

UNDEFINED SYMBOLS
memset
x_dim
y_dim
bit_shift_rev_single_maskP
bit_shift_maskP
serial_getc
draw_buffer
__do_copy_data
__do_clear_bss
